<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/10/26/hui-su-suan-fa/"/>
      <url>/2022/10/26/hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法定义"><a href="#回溯算法定义" class="headerlink" title="回溯算法定义"></a>回溯算法定义</h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。<br><strong>所以，回溯函数也就是递归函数，指的都是一个函数</strong>。</p><h2 id="回溯解决的问题"><a href="#回溯解决的问题" class="headerlink" title="回溯解决的问题"></a>回溯解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>这里再解释一下组合和排列。<strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。即组合无序，排列有序。</p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h2 id="回溯法模版"><a href="#回溯法模版" class="headerlink" title="回溯法模版"></a>回溯法模版</h2><ol><li><p>回溯函数模板返回值以及参数</p><p>回溯算法中函数返回值一般为void。因为回溯算法需要的参数步容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p></li><li><p>回溯函数终止条件</p><p>既然是树形结构，那么遍历树形结构一定要有终止条件。所以回溯也有要终止条件。什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p></li><li><p>回溯搜索的遍历过程</p><p><img src="1.png"></p><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p></li></ol><p>那么可以写出总体的框架为:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void backtracking(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="组合1"><a href="#组合1" class="headerlink" title="组合1"></a>组合1</h3><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接</a><br>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>那么参照上面的树，这道题的解题思路如下图：</p><p><img src="2.png"></p><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p></li><li><p>回溯函数终止条件</p><p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p></li><li><p>回溯搜索的遍历过程</p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p></li></ol><p>所以代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {  combineHelper(n, k, 1);  return res;}public void combineHelper(int n, int k, int startIndex) {  //终止条件  if (path.size() == k) {    res.add(new ArrayList&lt;&gt;(path));    return;  }  for (int i = startIndex; i &lt;= n; i++) {//控制树的横向遍历    path.add(i);//处理节点    combineHelper(n, k, i + 1);//递归，控制树的纵向遍历，注意下一层搜索要从i+1开始    path.remove(path.size() - 1);//回溯，撤销处理的节点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中最难理解的地方就是对树的横向遍历和递归树的纵向遍历，可以手写几个例子就可以清楚到底是如何循环的。</p><h4 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。<br>接下来看一下剪枝过程</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。<br>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。则for循环变成</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i = startIndex; i &lt;= n - (k - path.size) + 1; i++)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="组合3"><a href="#组合3" class="headerlink" title="组合3"></a>组合3</h3><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>这里还是要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。int型变量startIndex用来记录下一层for循环搜索的起始位置，（集合就是[1,…,n] ），int型变量sum计算path中的和。</p></li><li><p>回溯函数终止条件</p><p>path这个数组的大小如果达到k并且总和sum等于target，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p></li><li><p>回溯搜索的遍历过程</p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i，更新sum值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {  combineHelper(n, k, 1, 0);  return res;}public void combineHelper(int target, int k, int startIndex, int sum) {  //剪枝操作  if (sum &gt; target) {    return;  }  //终止条件  if (path.size() == k) {    if (sum == target) {      res.add(new ArrayList&lt;&gt;(path));      return;    }   }  for (int i = startIndex; i &lt;= 9; i++) {//控制树的横向遍历    sum += i;    path.add(i);//处理节点    combineHelper(n, k, i + 1);//递归，控制树的纵向遍历，注意下一层搜索要从i+1开始    sum -= i;    path.remove(path.size() - 1);//回溯，撤销处理的节点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题的剪枝是比较容易想出来的，当sum的值大于target的时候就不需要往下遍历直接返回即可。</p></li></ol><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="3.png"></p><p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合，这里需要注意变量都是字符串，要知道容器的定义。这里需要一个int类型的index，这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。和上面的startIndex的意义不同。int型变量sum计算path中的和。</p></li><li><p>回溯函数终止条件</p><p>例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。那么终止条件就是如果index 等于 输入的数字个数</p></li><li><p>回溯搜索的遍历过程</p><p>首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。然后for循环来处理这个字符集，<strong>这里for循环，可不像是前面从startIndex开始遍历的</strong>。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而前两道题都是求同一个集合中的组合！</strong></p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">StringBuilder path = new StringBuilder();List&lt;String&gt; res = new ArrayList&lt;&gt;();public List&lt;String&gt; letterCombinations(String digits) {  if (digits == null || digits.length() == 0) {    return res;  }  Strinf[] letterMap = new String(){    "", // 0    "", // 1    "abc", // 2    "def", // 3    "ghi", // 4    "jkl", // 5    "mno", // 6    "pqrs", // 7    "tuv", // 8    "wxyz", // 9  }  combine(digits, 0, letterMap);  return res;}public void combineHelper(String digits, int index, String[] letterMap) {  //剪枝操作  if (sum &gt; target) {    return;  }  //终止条件  if (index == digits.length()) {    res.add(path.toString());    return;    }   }  String temp = letterMap[digits.charAt(index) - '0'];  for (int i = 0; i &lt; temp.length(); i++) {//控制树的横向遍历    path.append(temp.charAt(i));//处理节点    combineHelper(n, k, index + 1);//递归，控制树的纵向遍历，注意下一层搜索要从i+1开始    path.deleteCharAt(path.length() - 1);//回溯，撤销处理的节点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接</a></p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</p><p>示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>这里还是要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。int型变量startIndex用来记录下一层for循环搜索的起始位置，（集合就是[1,…,n] ），int型变量sum计算path中的和。</p><p><strong>本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p><p>如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a>。</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></p></li><li><p>回溯函数终止条件</p><p>从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。</p></li><li><p>回溯搜索的遍历过程</p><p>单层for循环依然是从startIndex开始，搜索candidates集合。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {  combineHelper(candidates, target, 0);  return res;}public void combine(int[] candidates, int target, int startIndex {  if (target == 0) {    res.add(new ArrayList&lt;&gt;(path));    return;  }  for (int i = startIndex, i &lt; candidates.length; i++) {    if (candidates[i] &gt; target) break;//如果不进行判断，会无限的循环下去，因为传入的是i而不是i+1，导致栈空间泄漏    path.add(candidates[i]);    combine(candidates, target - candidates[i], i);//本题要求同一个数字可以无限制重复选去，所以传入的就是i    path.remove(path.size() - 1);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组合总和2"><a href="#组合总和2" class="headerlink" title="组合总和2"></a>组合总和2</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。所以我们需要去重。<strong>去重，其实就是使用过的元素不能重复选取。</strong><br>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。<br>所以实现去重我们要在for循环里去实现。我们使用startIndex去记录下一层for循环的起始位置，那么当i &gt; startIndex的时候说明遍历到了树同层的下一个元素，这个时候再判断一下i - 1和i的元素值是否相同，相同则说明元素重复，不同则继续纵向遍历。那么代码实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {  combineHelper(candidates, target, 0);  return res;}public void combine(int[] candidates, int target, int startIndex {  if (target == 0) {    res.add(new ArrayList&lt;&gt;(path));    return;  }  for (int i = startIndex, i &lt; candidates.length; i++) {    if (i &gt; startIndex &amp;&amp; candidates[i - 1] == candidates[i]) {      continue;    }    path.add(candidates[i]);    combine(candidates, target - candidates[i], i + 1);//本题要求数字不可重复，所以传入的就是i + 1    path.remove(path.size() - 1);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><img src="4.jpg"></p><p>切个问题还是可以画成树进行解决，下面直接给出代码，依旧是用三步曲解决问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//这里用来记录路径使用双端队列Deque&lt;String&gt; path = new LinkedList&lt;&gt;();List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;String&gt;&gt; partition(String s) {  combine(s, 0);  return res;}public void combine(String s, int startIndex) {  if (startIndex &gt;= s.length()) {//当起始线超过了数组长度，说明已经有结果了    res.add(path);    return;  }  for (int i = startIndex; i &lt; s.length(); i++) {    if (isPalindrome(s, startIndex, i)) {//是回文串，添加到path中去      String temp = s.subString(startIndex, i + 1);//把回文子串截断，subString是左开右闭，所以+1      path.addLast(temp);    } else {      continue;//不是回文子串，继续循环    }    combine(s, i + 1);    path.removeLast();  }}public boolean isPalindrome(String s, int start, int end) {  for (int i = start, j = end; i &lt; j; i++, j--) {    if (s.charAt(i) != s.charAt(j)) {      return fasle;    }  }  return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p><p>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,”255.255.111.35”]</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>回溯三步曲</p><ul><li><p>递归参数</p><p>这里依然需要有startIndex作为下一层for循环的起始位置，除此之外还需要一个pointNum作为终止条件。</p></li><li><p>终止条件</p><p>这里不能使用分割线到列表末尾判断，需要根据点的数量，点的数量为3则代表已经分成了4段。</p></li><li><p>单层搜索逻辑</p><p>在for循环中首先进行截取，然后判断截取的子串是否合法，合法就在子串末尾加符号.表示已分割，不合法则结束本层循环。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; res = new ArrayList&lt;&gt;();public List&lt;String&gt; restoreIpAddresses(String s) {    combine(s, 0, 0);    return res;}public void combine(String s, int startIndex, int pointNum) {    if (pointNum == 3) {        //判断第四段是否合法        if (isValid(s, startIndex, s.length() - 1)) {            res.add(s);        }        return;    List&lt;String&gt; res = new ArrayList&lt;&gt;();public List&lt;String&gt; restoreIpAddresses(String s) {    combine(s, 0, 0);    return res;}public void combine(String s, int startIndex, int pointNum) {    if (pointNum == 3) {        //判断第四段是否合法        if (isValid(s, startIndex, s.length() - 1)) {            res.add(s);        }        return;    }    for (int i = startIndex; i &lt; s.length(); i++) {        if (isValid(s, startIndex, i)) {          //子串合法插入符号.            s = s.substring(0, i + 1) + "." + s.substring(i + 1);            pointNum++;            combine(s, i + 2, pointNum);//插入符号后，下一个子串的起始位置是i+2            pointNum--;//回溯，取消插入符号          //回溯，取消插入符号            s = s.substring(0, i + 1) + s.substring(i + 2);        } else {            break;        }    }}public boolean isValid(String s, int start, int end) {    if (start &gt; end) {        return false;    }    //段位以0为开头的数字不合法    if (s.charAt(start) == '0' &amp;&amp; start != end) {        return false;    }    //判断值是否大于255    String temp = s.substring(start, end + 1);    if (Integer.valueOf(temp) &gt; 255) {        return false;    }    //判断是否出现数字以外其他字符    for (int i = start; i &lt;= end; i++) {        if(s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') {            return false;        }    }    return true;}    }    for (int i = startIndex; i &lt; s.length(); i++) {        if (isValid(s, startIndex, i)) {            s = s.substring(startIndex, i + 1) + "." + s.substring(i + 1);//子串合法插入符号.            pointNum++;            combine(s, i + 2, pointNum);//插入符号后，下一个子串的起始位置是i+2            pointNum--;//回溯，取消插入符号            s = s.substring(startIndex, i + 1) + s.substring(i + 2);//回溯，取消插入符号        } else {            break;        }    }}public boolean isValid(String s, int start, int end) {    if (start &gt; end) {        return false;    }    //段位以0为开头的数字不合法    if (s.charAt(start) == '0' &amp;&amp; start != end) {        return false;    }    //判断值是否大于255    String temp = s.substring(start, end + 1);    if (Integer.valueOf(temp) &gt; 255) {        return false;    }    //判断是否出现数字以外其他字符    for (int i = start; i &lt;= end; i++) {        if(s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') {            return false;        }    }    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接(opens new window)</a></p><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点</strong></p><p><img src="5.png"></p><p>继续我们的递归三步曲</p><ul><li><p>递归参数</p><p>需要一个数组path为子集手机元素，二维数组res存放子集组合</p></li><li><p>终止条件</p><p>剩余集合为空的时候，就是叶子节点。</p></li><li><p>单层循环逻辑</p><p>直接收集子集元素就可以</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        backTracking(nums, 0);        return res;    }    public void backTracking(int[] nums, int startIndex) {        res.add(new ArrayList&lt;&gt;(path));//遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合        if (startIndex &gt;= nums.length) {            return;        }        for (int i = startIndex; i &lt; nums.length; i++) {            path.add(nums[i]);            backTracking(nums, i + 1);            path.remove(path.size() - 1);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS和BFS</title>
      <link href="/2022/10/26/dfs-shen-du-you-xian-sou-suo/"/>
      <url>/2022/10/26/dfs-shen-du-you-xian-sou-suo/</url>
      
        <content type="html"><![CDATA[<p>本片来讲一下DFS深度优先搜索和BFS广度优先搜索两种搜索算法。</p><h2 id="DFS和BFS的区别"><a href="#DFS和BFS的区别" class="headerlink" title="DFS和BFS的区别"></a>DFS和BFS的区别</h2><ul><li>DFS是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，在换方向（换方向的过程就涉及到了回溯）。</li><li>BFS是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS 英文全称为（Depth First Search），中文称深度优先搜索算法，其过程为沿着每一个可能的路径向下进行搜索，直到不能再深入为止，并且每一个节点只能访问一次。</p><h3 id="算法的搜索遍历图的步骤"><a href="#算法的搜索遍历图的步骤" class="headerlink" title="算法的搜索遍历图的步骤"></a>算法的搜索遍历图的步骤</h3><ol><li><p>首先找到出事节点A，</p></li><li><p>依次从A未被访问的邻接点出发，对图进行深度优先遍历</p></li><li><p>若有节点未被访问，则回溯到该节点，继续进行深度优先遍历</p></li><li><p>直到所有与定点A路径相通的节点都被访问过一次。</p></li></ol><h3 id="DFS模版"><a href="#DFS模版" class="headerlink" title="DFS模版"></a>DFS模版</h3><p>正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。所以借鉴回溯的三部曲，这里给出dfs的代码框架：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void dfs(参数) {  if (终止条件) {    收获结果；    return；  }  for (选择：本节点所有邻接节点) {    处理节点;    dfs(图， 选择的节点);//递归    回溯，撤销处理结果  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DFS三步曲"><a href="#DFS三步曲" class="headerlink" title="DFS三步曲"></a>DFS三步曲</h3><ol><li><p>确认递归函数和参数</p><p>一般情况，深搜需要二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，可以定义一个全局遍历，避免让函数参数过多。</p></li><li><p>确定终止条件</p><p>终止条件对每个问题都是不同的，相同的是我们要在这里存放结果</p></li><li><p>处理目前搜索节点出发的路径</p><p>这里就是框架中的for循环，去遍历目前搜索节点所能到的节点。然后加上回溯操作。</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这里举<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">Leetcode797.所有可能的路径</a>作为例题写一下代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;integer&gt;&gt; allPathsSourceTarget(int[][] graph) {  path.add(0);//每条路径都是从0开始的  dfs(graph, 0);  return res;}public void dfs(int[][] graph, int current) {  //终止条件  if (current == graph.length - 1) {    res.add(new ArrayList&lt;&gt;(path));//收获结果    return;  }  //处理搜索节点路径  for (int i = 0; i &lt; graph[current].length; i++) {    path.add(graph[x][i]);    dfs(graph, graph[x][i]);//取找和graph[x][i]节点相邻的节点    path.remove(path.size() - 1);//回溯，取消操作  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广搜（bfs）是一圈一圈的搜索过程，在二叉树中的表现就是层序遍历。</p><h3 id="广搜的使用场景"><a href="#广搜的使用场景" class="headerlink" title="广搜的使用场景"></a>广搜的使用场景</h3><p>广搜的搜索方式就适合于解决两个点之间的最短路径问题。因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p>广搜其实仅仅需要一个容器，能保存要遍历过的元素就可以，那么用队列，还是用栈，甚至用数组，都是可以的。</p><p>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p>如果用栈的话，可能就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。因为栈是先进后出，加入元素和弹出元素的顺序改变了。<br>这里给出使用队列去实现的广度优先搜索。实现的问题就是在四方格中，给定一个起点和终点，找到起点到终点的最短路径。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] dir ={{0, 1}, {1, 0},{-1, 0},{ 0, -1}};public int numIslands(char[][] grid) {        int count = 0;        boolean[][] visited = new boolean[grid.length][grid[0].length];        for (int i = 0; i &lt; grid.length; i++) {            for (int j = 0; j &lt; grid[0].length; j++) {                if (grid[i][j] == '1') {                    dfs(grid, i, j, visited);                    count++;                }            }        }        return count;    }public void dfs(char[][] grid, int x, int y, boolean[][] visited) {        Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;();        que.add(new int[]{x,y});        visited[x][y] = true;        while (!que.isEmpty()) {            int[] temp = que.remove();            int curX = temp[0];            int curY = temp[1];            for (int i = 0; i &lt; 4; i++) {                int nextX = curX + dir[i][0];                int nextY = curY + dir[i][1];                if (nextX &lt; 0 || nextX &gt;= grid.length || nextY &lt; 0 || nextY &gt;= grid[0].length) {                    if(!visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == '1') {                        que.add(new int[]{nextX, nextY});                        visited[nextX][nextY] = true;//放入队列立马将访问状态置为true                    }                }            }        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -BFS -DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/10/26/shu-zu-xiang-guan-suan-fa/"/>
      <url>/2022/10/26/shu-zu-xiang-guan-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>数组是存放在连续内存空间上的相同类型数据的集合。正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法</title>
      <link href="/2022/10/24/chang-jian-pai-xu-suan-fa/"/>
      <url>/2022/10/24/chang-jian-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>今天把常见的排序算法进行总结，包括时空复杂度和一些特殊情况下的优劣。</p><h2 id="low三人"><a href="#low三人" class="headerlink" title="low三人"></a>low三人</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是从数组元素第一个开始，两两比较，循环n-1次，每一次循环都会确定一个值的位置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void bubbleSort(intp[] list) {  int len = list.length;  for (int i = 0; i &lt; len - 1; i++) {    boolean flag = false;    for (int j = 0; j &lt; len - i; j++) {      if (list[j] &gt; list[j + 1]) {        int temp = list[j + 1];        list[j + 1] = list[j];        list[j] = temp;        flag = true;      }    }    if (flag == false) {     return;     }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>冒泡排序的时间复杂度是O(n2),最坏的情况是数组有序，所以可以进行优化，添加标识为判断是否存在交换，不存在交换则结束循环。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次选择一个数组中最小的数放入数组，所以外层循环n次。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void selectSort(int[] list) {  for (int i = 0; i &lt; list.length; i++){    int min = i;//min是最小那个数的索引    for (int j = 0; j &lt; list.length; j++) {      if (list[min] &gt; list[j]) {        min = j;      }    }    int temp = list[min];    list[min] = list[i];    list[i] = temp;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度是O(n2)，</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>假设插入排序就是抽牌理牌的过程，手中的牌是有序的，每次抽一张牌将它插到手中并保持有序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void insertSort(int[] list) {  for (int i = 1;i &lt; list.length; i++) {    int j = i - 1;    int cur = list[i];    while (j &gt; 0 &amp;&amp; list[j] &gt; temp) {      //把大牌向后调整      list[j + 1] = list[j];      j--;    }    list[j] = temp;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入排序的时间复杂度也是O(n2)，因为每次需要移动牌，从1 + 2 + … + n = n(n + 1)。</p><h2 id="牛三人"><a href="#牛三人" class="headerlink" title="牛三人"></a>牛三人</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的中心思想是取一个元素p（第一个元素），使元素p归位，列表被p分成两部分，左边都比p小，右边比p大；递归完成排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void fastSort(int[] list, int left, int right) {  if (left &lt; right) {    int mid = partition(list, left, right);    fastSort(list, left, mid - 1);    fastSort(list, mid + 1, right);  }}public void partition(int[] list, int left, int right) {  int temp = list[left];  while (left &lt; right) {    while (left &lt; right &amp;&amp; list[left] &lt;= temp) {      left++;    }    list[right] = list[left];    while (left &lt; right &amp;&amp; list[right] &gt;= temp) {      right--;    }    list[left] = list[right];  }  list[left] = temp;  return left;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快速排序的时间复杂度是O(nlogn)，快速排序存在最坏情况，也就是数组为倒序</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的思路是，将数组分成两部分，分别将左边和右边变有序，然后使用将两个有序数组合并为一个有序数组的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void mergeSort(int[] list, int left, int right, int temp) {  if (left &lt; right) {    int mid = (left + right) / 2;    mergeSort(list, left, mid, temp);//左有序    mergeSort(list, mid + 1, right, temp);//右有序    merge(list, left, mid, right, temp);  }}public void merger(int[] list, int left, int mid, int right, int[] temp) {  int i = left;  int j = mid + 1;  int count = 0;  while (i &lt;= mid &amp;&amp; j &lt;= right) {    if (list[i] &gt; list[j]) {      temp[count++] = list[j++];    } else {      temp[count++] = list[i++];    }  }  while (i &lt;= mid) {    temp[count++] = list[i++];  }  while (j &lt;= right) {    temp[count++] = list[j++];  }  //将排好的顺序放入原数组中  count = 0;  int leftI = left;  while (leftI &lt;= right) {    list[left++] = temp[count++];  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序的时间复杂度：O(nlogn)，归并有logn层，每一层循环n次。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>理解堆排序需要知道二叉树的一些相关知识，这里不讨论。堆排序分为大根堆和小根堆。顾名思义，大根堆是父节点元素一定比子节点大，小根堆则相反。堆排序我们首先需要根据数组构建出堆，然后进行调堆、出数的操作。二叉树有两种存储方式，一种是数组（本写法默认数组存放），一种是链式存储。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void sift(int[] list, int low, int high) {  int i = low;//表示根节点  int j = i * 2 + 1;//表示左孩子  int temp = list[i];  while (j &lt;= high) {    if (j + 1 &lt;= high &amp;&amp; list[j + 1] &gt; list[j]) {//右孩子大      j = j + 1;    }    if (list[j] &gt; temp) {//孩子节点比父节点大，交换节点，更新标识位      list[i] = list[j];      i = j;      j = i * 2 + 1;    } else {      list[i] = temp;//可省略      break;    }  }  list[i] = temp;}public void heapSort(int[] list) {  //从最后一个父节点向上建堆  for (int i = (list.length - 2) / 2; i &gt; -1; i--) {//最后一个元素是len-1，子节点-&gt;父节点公式：“(i - 1) / 2”    sift(list, i, list.length - 1);  }  //出数-不额外申请空间  for (int i = list.length - 1; i &gt; -1; i--) {    int temp = list[0];    list[0] = list[i];    list[i] = temp;    sift(list, 0, i - 1);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆排序的时间复杂度：sift函数是O(logn)，建堆为O(n),出数为O(n)，所以是2 * O(n*logn) = O(nlogn)。但快速排序比堆排序快一点。</p><h2 id="其他类型排序"><a href="#其他类型排序" class="headerlink" title="其他类型排序"></a>其他类型排序</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是分组插入排序算法，通过选取一个gap，将每组相邻距离为gap的元素进行直接插入排序，每进行完一次排序，gap的变为原来的一半，直到gap为1为止。希尔排序每趟不使元素有序，而是使整体数据越接近有序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void insertShellSort(int[] list, int gap) {  for (int i = gap; i &lt; list.length; i++) {    int j = i - gap;    int cur = list[i];    while (j &gt;= 0 &amp;&amp; list[j] &gt; cur) {      list[j + gap] = list[j];      j -= gap;    }    list[j + gap] = temp;  }}public void shellSort(int[] list) {  int gap = list.length / 2;  while (gap &gt; = 1) {    insertShellSort(list, gap);    gap /= 2;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希尔排序的时间复杂度与选取的gap序列有关，不同的gap时间复杂度不同，可以在wiki上看到现存gap的时间复杂度。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>首先将列表元素粉崽不同的桶中，在将桶中的元素排序。比较关键的是桶的大小和桶的个数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void binSort(int[] list, int bucketSize) {  //首先计算一下桶的个数  int maxNum = list[0], minNum = list[0];  for (int i = 0; i &lt; list.length; i++) {    maxNum = Math.max(list[i],maxNum);    minNum = Math.min(list[i],minNum);  }  List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//使用list模拟桶  //创建桶  int bucketNum = (maxNum - minNum) / bucketSize;  for (int i = 0;i &lt; bucketNum; i++) {    res.add(new ArrayList&lt;&gt;());  }  //将数依次放入桶中  for (int i = 0;i &lt; list.length; i++) {    res.get((list[i] - minNum) / bucketSize)).add(list[i]);  }  //对每个桶进行排序  for (int i = 0; i &lt; bucketNum; i++) {    Collections.sort(res.get(i));  }  //将桶中的数据放入数组  int index = 0;  for(int i = 0; i &lt; bucketNum; i++) {    for (int j = 0; j &lt; res.get(i).size(); j++) {      list[index++] = res.get(i).get(j);    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>桶排序的时间复杂度和数据分布有关系，对不同的数据分布采取不同的分桶策略。（k表示一个桶平均的长度）平均情况下时间复杂度为O(n + k)，最坏情况为：O(n2k)。空间复杂度是O(nk)。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序非常好理解，创建一个计数数组，将元素依次放入计数数组中，每放入一个数，计数数组值+1，最后遍历计数数组打印元素。因为数组本身是有序的，所以可以进行排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void countSort(int[] list) {  //找出最大的值目的是创建数组  int max = list[0];  for (int i : list) {    max = Math.max(i,max);  }  int[] res = new int[max];  for (int i : list) {    res[i]++;  }  for (int i = 0; i &lt; res.length; i++) {    for (int j = 0; j &lt; res[i]; j++) {      System.out.println(i);    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计数排序时间复杂度是O(n)，但是有限制，即n不能太大。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序的原理是先从个位排序，然后百位、千位…直到位数最大的长度为止。具体实现：创建10个桶表示每位数上的值0~9，依次取个位上的数放入桶中，然后将桶内元素排序并放回原数组，接着取十位、百位等等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void redixSort(int[] list) {  int maxNum = list[0];  for (int i : list) {    maxNum = Math.max(maxNum,i);  }  int count = 0;//循环计数  while (Math.pow(10, count) &lt;= maxNum) {    int bucketNum 10;    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    while (bucketNum &gt; 0) {      res.add(new ArrayList&lt;&gt;());      bucketNum--;    }    //取每一位的值并放入桶中    int digit = 0;    for (int i : list) {      digit = (int)(i / Math.pow(10,count)% 10 );      res.get(digit).add(i);    }    //将桶中的数组放入数组    int index = 0;    for (int i = 0;i &lt; bucketNum; i++) {      for (int j = 0; j&lt; res.get(i).size(); j++) {        list[index++] = res.get(i).get(j);      }    }    count++;//取下一位  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基数的时间复杂度是：O(nk)，k是最大数的数字位数。空间复杂度为O(k + n)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>排序算法到这里基本结束，时空复杂度和每个排序的最优最列情况要了解清楚，剩下的就是能通过伪代码记忆下来。每天做几道算法题巩固，那在笔试中就应该没有问题了。</p><p>Peace &amp; Love。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-第一行代码</title>
      <link href="/2022/10/23/android-di-yi-xing-dai-ma/"/>
      <url>/2022/10/23/android-di-yi-xing-dai-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="Chap1-Android-项目架构"><a href="#Chap1-Android-项目架构" class="headerlink" title="Chap1-Android 项目架构"></a>Chap1-Android 项目架构</h2><h3 id="gradle-idea"><a href="#gradle-idea" class="headerlink" title=".gradle/.idea"></a>.gradle/.idea</h3><p>这两个目录下放置的都是 Android Studio 自动生成的一些文件。</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>项目中的代码、资源等内容几乎都是放置在这个目录下的。  </p><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p>这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle 下载好，而是会自动根据本地的缓存情况决定是否需要联网下载 gradle。Android Studio 默认没有启用gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏→File→Settings→Build, Execution, Deployment→Gradle，进行配置更改。  </p><h3 id="gitgnore"><a href="#gitgnore" class="headerlink" title=".gitgnore"></a>.gitgnore</h3><p> 这个文件是用来将指定的目录或文件排除在版本控制之外的。</p><h3 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h3><p>这个文件是全局的 gradle 配置文件，在这里配置的属性将会影响到项目中所有的 gradle 编译脚本。  </p><h3 id="gradle、gradle-bat"><a href="#gradle、gradle-bat" class="headerlink" title=".gradle、gradle.bat"></a>.gradle、gradle.bat</h3><p>这两个文件是用来在命令行界面中执行 gradle 命令的，其中 gradlew 是在 Linux 或 Mac 系统 中使用的，gradlew.bat 是在 Windows 系统中使用的。  </p><h3 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title=".settings.gradle"></a>.settings.gradle</h3><p>这个文件用于指定项目中所有引入的模块。由于 HelloWorld 项目中就只有一个 app 模块，因此该文件中也就只引入了 app 这一个模块。通常情况下模块的引入都是自动完成的。  </p><h3 id="app-build-gradle文件"><a href="#app-build-gradle文件" class="headerlink" title="app/build.gradle文件"></a>app/build.gradle文件</h3><p>第一行应用了一 个插件，一般有两种值可选：com.android.application 表示这是一个应用程序模块， com.android.library 表示这是一个库模块。应用程序模块和库模块的最大区别在于，一个是可以直接运行的，一个只能作为代码库依附于别的应用程序模块来运行。</p><h3 id="android-闭包"><a href="#android-闭包" class="headerlink" title="android 闭包"></a>android 闭包</h3><p>在这个闭包中我们可以配置项目构建的各种属性。其中， compileSdkVersion 用于指定项目的编译版本，buildToolsVersion 用于指定项目构建工具的版本。</p><h3 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig 闭包"></a>defaultConfig 闭包</h3><p>applicationId 用于指定项目的包名，如果想在后面对其进行修改，那么就是在这里修改的。 minSdkVersion 用于指定项目最低兼容的 Android 系统版本。</p><p>targetSdkVersion 指定的值表示在该目标版本上已经做过了充分的测试， 系统将会为你的应用程序启用一些最新的功能和特性。</p><p>versionCode 用于指定项目的版本号，versionName 用于指定项目的版 本名，</p><h3 id="buildTypes-闭包。"><a href="#buildTypes-闭包。" class="headerlink" title="buildTypes 闭包。"></a>buildTypes 闭包。</h3><p>buildTypes 闭包中用于指定生成安装文件的相关配置，通常只会有两个子闭包，一个是 debug，一个是 release。</p><p>debug 闭包用于指定生成测试版安装文件的配置，release 闭包用于指定生成正式版安装文件的配置。另外， debug 闭包是可以忽略不写的。</p><p>release 闭包：</p><p>minifyEnabled 用于指定是否对项目的代码进行混淆，true 表 示混淆，false 表示不混淆。proguardFiles 用于指定混淆时使用的规则文件，这里指定了两个文件，第一个 proguard-android.txt 是在 Android SDK 目录下的，里面是所有项目通用的 混淆规则，第二个 proguard-rules.pro 是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则。</p><h3 id="dependencies-闭包"><a href="#dependencies-闭包" class="headerlink" title="dependencies 闭包"></a>dependencies 闭包</h3><p>这个闭包的功能非常强大，它可以指定当前项目所有的依赖关系。通常 Android Studio 项目一共有3种依 赖方式：本地依赖、库依赖和远程依赖。本地依赖可以对本地的 Jar 包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖则可以对 jcenter 库上的开源项目添加依赖关系。 </p><p>compile fileTree 是一个本地依赖声明，它表示将 libs 目录下所有.jar 后缀的文件都添加到项目的构建路径当中。</p><p>compile 则是远程依赖声明。加上这句声明后，Gradle 在构建项目时会首先检查一下本地是否已经有这个库的缓存，如果没有的话 则会去自动联网下载，然后再添加到项目的构建路径当中。</p><p>库依赖声明的基本格式是 compile project 后面加上要依赖的库名称，比如说有一个库模块的名字叫 helper， 那么添加这个库的依赖关系只需要加入 compile project(‘:helper’)这句声明即可。  </p><h2 id="Chap2-四大组件：活动"><a href="#Chap2-四大组件：活动" class="headerlink" title="Chap2-四大组件：活动"></a>Chap2-四大组件：活动</h2><h3 id="2-1活动基本用法"><a href="#2-1活动基本用法" class="headerlink" title="2.1活动基本用法"></a>2.1活动基本用法</h3><p>活动都要在 AndroidManifest.xml 中进行注册才能生效， 活动的注册声明要放在<application>标签内。</application></p><p>在注册活动之后还需要为程序配置主活动，这样在程序运行时才会找到第一个需要启动的活动。在<activity>标签中加入<intent-filter>标签并添加两句声明。lable属性用来修改标题。</intent-filter></activity></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>label</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Fruits<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.category.LAUNCHER<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-1销毁活动"><a href="#2-1-1销毁活动" class="headerlink" title="2.1.1销毁活动"></a>2.1.1销毁活动</h4><p>调用finish()方法。</p><h3 id="2-2menu菜单"><a href="#2-2menu菜单" class="headerlink" title="2.2menu菜单"></a>2.2menu菜单</h3><p>首先在 res 目录下新建一个 menu 文件夹，新建文件夹menu，接着新建一个Menu resource file</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span><span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中一个item表示一个菜单项，可以为其分配id做点击事件的处理。</p><p>在活动中需要重写onCreateOptionsMenu()。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 getMenuInflater()方法能够得到 MenuInflater 对象，再调用它的 inflate()方法就可以给当前活动创建菜单了。inflate()方法接收两个参数，第一个参数用于指定通过哪 一个资源文件来创建菜单，这里当然传入 R.menu.main。第二个参数用于指定菜单项将添加到哪一个 Menu 对象当中。方法返回 true，表示允许创建的菜单显示出来，返回 false，创建的菜单将无法显示。  </p><p>接着做菜单项的点击事件，我们需要重写onOptionsItemSelected() ，代码很简单无需解释。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.add_item:         break; default: } return true;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3Intent"><a href="#2-3Intent" class="headerlink" title="2.3Intent"></a>2.3Intent</h3><h4 id="2-3-1显式Intent"><a href="#2-3-1显式Intent" class="headerlink" title="2.3.1显式Intent"></a>2.3.1显式Intent</h4><p>Intent 有多个构造函数的重载，其中一个是 Intent(Context packageContext, Class cls)。这个构造函数接收两个参数，第一个参数 Context 要求提供一个启动活动的上下文，第二个参数 Class 则是指定想要启动的目标活动。然后使用Activity 类中提供的startActivity()方法，它接收一个 Intent 参数。</p><h4 id="2-3-2隐式Intent"><a href="#2-3-2隐式Intent" class="headerlink" title="2.3.2隐式Intent"></a>2.3.2隐式Intent</h4><p>不明确指出我们想要启动哪一个活动， 而是指定了一系列更为抽象的 action和category 等信息，然后交由系统去分析这个Intent， 并帮我们找出合适的活动去启动。在 AndroidManifest.xml 中通过在标签下配置的内容，可以指定当前活动能够响应的 action 和 category。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.SecondActivity<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.activitytest.ACTION_START<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.category.DEFAULT<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码指明了当前活动可以响应 com.example.activitytest.ACTION_ START 这个 action， <category>标签则包含了一些附加信息，只有和中的内容同时能够匹配 上 Intent 中指定的 action 和 category 时,活动才会相应Intent。那么此时Intent中的参数应该是定义的action。 每个 Intent 中只能指定一个 action，但却能指定多个 category。</category></p><p>除此之代还可以配置一个<data>标签，用于更精确地指定当前活动能够响应什么类型的数据。</data></p><ul><li> android:scheme。用于指定数据的协议部分，如上例中的 http 部分。  </li><li> android:host。用于指定数据的主机名部分，如上例中的 <a href="http://www.baidu.com/">www.baidu.com</a> 部分。</li><li> android:port。用于指定数据的端口部分，一般紧随在主机名之后。</li><li> android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。  </li><li> android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。     </li></ul><p>(android.intent.category.DEFAULT 是一种默认的 category，在调用 startActivity()方法的时候会自动将这个 category 添加到 Intent 中。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent intent = new Intent("com.example.activitytest.ACTION_START");//添加categoryintent.addCategory("com.example.activitytest.MY_CATEGORY"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3传递数据"><a href="#2-3-3传递数据" class="headerlink" title="2.3.3传递数据"></a>2.3.3传递数据</h4><p>使用putExtra()方法暂存数据，其接收两个参数，第一个参数是键，第二个参数才是真正要传递的数据。  </p><p>获取intent需要使用getIntent()，方法可以获取到用于启动本活动的 Intent，然后调用 getTypeExtra()方法，传入相应的键值，就可以得到传递的数据。</p><h4 id="2-3-4返回数据"><a href="#2-3-4返回数据" class="headerlink" title="2.3.4返回数据"></a>2.3.4返回数据</h4><p>返回数据给上一个活动可以调用startActivityForResult()，方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在回调中判断数据的来源。请求码需要是一个唯一值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic void onClick(View v) {    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);    startActivityForResult(intent, 1);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了返回数据需要调用setResult()。 方法接收两个参数， 第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这 两个值，第二个参数则把带有数据的 Intent 传递回去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void onClick(View v) {    Intent intent = new Intent();    intent.putExtra("data_return", "Hello FirstActivity");    setResult(RESULT_OK, intent); }//通过back返回活动传递数据@Overridepublic void onBackPressed() {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 startActivityForResult()方法来启动 SecondActivity，在 SecondActivity 被销毁之后会回调上一个活动的 onActivityResult()方法，因此需要在 FirstActivity 中重写这个方法来得到返回的数据。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void onActivityResult(int requestCode, int resultCode, Intent data) {    switch (requestCode) {    case 1:         beak;    default:    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>onActivityResult()方法带有三个参数，第一个参数 requestCode，即我们在启动活动时传入的请求码。第二个参数 resultCode，即我们在返回数据时传入的处理结果。第三个参数 data，即携带着返回数据的 Intent。因为会有很多活动返回的数据都会回调到 onActivityResult()这个方法 中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。  </p><h3 id="2-4活动生命周期"><a href="#2-4活动生命周期" class="headerlink" title="2.4活动生命周期"></a>2.4活动生命周期</h3><p>Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，也被称作返回栈。在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。每当按下 Back 键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。  </p><h3 id="2-5活动回收保存数据"><a href="#2-5活动回收保存数据" class="headerlink" title="2.5活动回收保存数据"></a>2.5活动回收保存数据</h3><p>Activity中提供了一个 onSaveInstanceState()回调方法，方法可以保证在活动被回收之前一定会被调用，因此可以通过这个方法来保存临时数据。  </p><p>onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如 putString()、 putInt()等。每个保存方法需要传入两个参数，第一个参数是键，第二个参数是数据内容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void onSaveInstanceState(Bundle outState) {    super.onSaveInstanceState(outState);    String tempData = "Something you just typed";    outState.putString("data_key", tempData);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  onCreate()方法中有一个 Bundle 类型的参数 ，在有保存的数据时会Bundle接收。</p><h3 id="2-6活动启动模式"><a href="#2-6活动启动模式" class="headerlink" title="2.6活动启动模式"></a>2.6活动启动模式</h3><h4 id="2-6-1standard"><a href="#2-6-1standard" class="headerlink" title="2.6.1standard"></a>2.6.1standard</h4><p>standard 模式（默认），每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</p><h4 id="2-6-2singleTop"><a href="#2-6-2singleTop" class="headerlink" title="2.6.2singleTop"></a>2.6.2singleTop</h4><p>在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。  只需要在<activity>标签中加入下面的代码。</activity></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">android:launchMode="singleTop" <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-6-3singleTask"><a href="#2-6-3singleTask" class="headerlink" title="2.6.3singleTask"></a>2.6.3singleTask</h4><p>每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。  </p><h4 id="2-6-4singleInstance"><a href="#2-6-4singleInstance" class="headerlink" title="2.6.4singleInstance"></a>2.6.4singleInstance</h4><p>singleInstance 模式的活动会启用一个新的返回栈来管理这个活动（singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈）。在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，解决了共享活动实例的问题。  </p><h3 id="2-7活动进阶编写"><a href="#2-7活动进阶编写" class="headerlink" title="2.7活动进阶编写"></a>2.7活动进阶编写</h3><h4 id="2-7-1知道是哪个活动"><a href="#2-7-1知道是哪个活动" class="headerlink" title="2.7.1知道是哪个活动"></a>2.7.1知道是哪个活动</h4><p> 新建一个Java Class，叫BaseActivity，让其继承 AppCompatActivity  并重写onCreate()方法，在方法中打印名称。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Log.d("BaseActivity", getClass().getSimpleName());} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着让所有活动继承BaseActivity，每当运行一个活动室就会自动打log。</p><h4 id="2-7-2随时退出活动"><a href="#2-7-2随时退出活动" class="headerlink" title="2.7.2随时退出活动"></a>2.7.2随时退出活动</h4><p>新建一个 ActivityCollector 类作为活动管理器, 在活动管理器中，通过一个 List 来暂存活动，然后提供addActivity()和removeActivity()方法用于从 List 中加入、移除活动，提供finishAll()方法用于将 List 中存储的活动全部销毁掉。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ActivityCollector {    public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();    public static void addActivity(Activity activity){        activities.add(activity);    }    public static void removeActivity(Activity activity){        activities.remove(activity);    }    public static void finishAll(){        for(Activity activity:activities){            if(!activity.isFinishing()){                activity.finish();            }        }        activities.clear();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>杀掉当前进程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">android.os.Process.killProcess(android.os.Process.myPid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-7-3最佳启动活动"><a href="#2-7-3最佳启动活动" class="headerlink" title="2.7.3最佳启动活动"></a>2.7.3最佳启动活动</h4><p>以防不知道在启动活动时不知道下一个活动需要什么数据，我们可以添加一个 actionStart()方法，在这个方法中完成了 Intent 的构 建，将活动中需要的数据都通过 actionStart()方法的参数传递过来，然后把它们存储到 Intent 中，最后调用 startActivity()方法启动 。 这样活动所需要的数据在方法参数中全部体现出来了，可以非常清晰地知道启动 活动需要传递哪些数据。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void actionStart(Context context, String data1, String data2) {    Intent intent = new Intent(context, SecondActivity.class);    intent.putExtra("param1", data1);    intent.putExtra("param2", data2);    context.startActivity(intent);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化后启动活动的代码只需要一行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SecondActivity.actionStart(FirstActivity.this, "data1", "data2"); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Chap3-布局-列表"><a href="#Chap3-布局-列表" class="headerlink" title="Chap3-布局+列表"></a>Chap3-布局+列表</h2><h4 id="3-1控件"><a href="#3-1控件" class="headerlink" title="3.1控件"></a>3.1控件</h4><h4 id="3-1-1Textview"><a href="#3-1-1Textview" class="headerlink" title="3.1.1Textview"></a>3.1.1Textview</h4><p>android:id：定义唯一标识符。</p><p>android:layout_width 和 android:layout_height ：指定控件的宽度和高度。</p><p>android:gravity ：指定文字的对齐方式， top、bottom、left、right、 center 等，可以用“|”来同时指定多个值，center效果等同于 center_ vertical|center_horizontal，表示文字在垂直和水平方向都居中对齐。  </p><p>android:textSize ：指定文字的大小，在 Android 中字体大小使用 sp 作为单位  。</p><p> android:textColor ：指定文字的颜色。</p><p> android:padding ：给控件的周围加上补白。</p><p>android:maxLines ：设置为 true 表示让这个 TextView 只能单行显示。 </p><p>android:ellipsize ：设定当文本内容超出控件宽度时，文本的缩略方式，这里指定成 end 表示在尾部进行缩略。  </p><h4 id="3-1-2Button"><a href="#3-1-2Button" class="headerlink" title="3.1.2Button"></a>3.1.2Button</h4><p> android:textAllCaps  :自动大小写转换开关</p><p>实现点击事件监听的两种方法，1：实现View.OnClickListener 接口 ，2 使用匿名类的方式。</p><h4 id="3-1-3EditText"><a href="#3-1-3EditText" class="headerlink" title="3.1.3EditText"></a>3.1.3EditText</h4><p>android:hint ：指定了一段提示性的文本。</p><p>android:maxLines： 指定 EditText 的最大行数 </p><h4 id="3-1-3ImageView"><a href="#3-1-3ImageView" class="headerlink" title="3.1.3ImageView"></a>3.1.3ImageView</h4><p>android:src ：指定一张图片。</p><h4 id="3-1-4ProgressBar"><a href="#3-1-4ProgressBar" class="headerlink" title="3.1.4ProgressBar"></a>3.1.4ProgressBar</h4><p> android:visibility  ：所有控件都有， visible（可见）、invisible（不可见、透明、占地） 和 gone（不可见、不占地）。</p><p> style：指定成进度条形式。</p><p> android:max ：给进度条设置一个最大值    </p><h4 id="3-1-5AlertDialog"><a href="#3-1-5AlertDialog" class="headerlink" title="3.1.5AlertDialog"></a>3.1.5AlertDialog</h4><p>AlertDialog.Builder创建一个 AlertDialog 的实例，设置标题、 内容、可否用 Back 键关闭对话框，接下来调用 setPositiveButton()、setNegativeButton()方法设置按钮的点击事件，最后调用 show()方法。     </p><h4 id="3-1-6ProgressDialog"><a href="#3-1-6ProgressDialog" class="headerlink" title="3.1.6ProgressDialog"></a>3.1.6ProgressDialog</h4><p>ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时。它的用法和 AlertDialog 也比较相似。（ setCancelable()中传入 false，表示 ProgressDialog 是不能通过 Back 键取消掉的，当数据加载完成后必须要调用 ProgressDialog 的 dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。）  </p><h3 id="3-2四种布局"><a href="#3-2四种布局" class="headerlink" title="3.2四种布局"></a>3.2四种布局</h3><h4 id="3-2-1LinearLayout"><a href="#3-2-1LinearLayout" class="headerlink" title="3.2.1LinearLayout"></a>3.2.1LinearLayout</h4><p>android:layout_gravity ：用于指定控件在布局中的对齐方式。  </p><p>android:layout_weight：使用比例的方式来指定控件的大小，两个控件宽度为0，将weight属性的值指定为1，这表示两个控件将在水平方向平分宽度。  </p><h4 id="3-2-2RelativeLayout"><a href="#3-2-2RelativeLayout" class="headerlink" title="3.2.2RelativeLayout"></a>3.2.2RelativeLayout</h4><p>通过相对定位的方式让控件出现在布局的任何位置。</p><p>android:layout_alignParentLeft： 和父布局的左对齐  </p><p>android:layout_alignParentTop：上</p><p>android:layout_alignParentRight ：和父布局的右对齐  </p><p>android:layout_ alignParentBottom：下</p><p>android:layout_centerInParent  ：居中 </p><p> android:layout_above ：让一个控件位于另一个控件的上方 ，id引用</p><p> android:layout_toLeftOf  ：控件位于另一个控件的左侧，同理还有右侧</p><p> android:layout_alignLeft ：让一个控件的左边缘和另一个控件的左边缘对齐 ，同理还有上下右侧。</p><h4 id="3-2-3FrameLayout"><a href="#3-2-3FrameLayout" class="headerlink" title="3.2.3FrameLayout"></a>3.2.3FrameLayout</h4><p>所有的控件都会默认摆放在布局的左上角。  </p><h4 id="3-2-4PercentFrameLayout"><a href="#3-2-4PercentFrameLayout" class="headerlink" title="3.2.4PercentFrameLayout"></a>3.2.4PercentFrameLayout</h4><p>允许直接指 定控件在布局中所占的百分比。</p><p>百分比布局只为 FrameLayout 和 RelativeLayout 进行了功能扩展，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局。</p><h3 id="3-3-布局进阶"><a href="#3-3-布局进阶" class="headerlink" title="3.3 布局进阶"></a>3.3 布局进阶</h3><h4 id="3-3-1引入布局"><a href="#3-3-1引入布局" class="headerlink" title="3.3.1引入布局"></a>3.3.1引入布局</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">layout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@layout/title<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3-2自定义控件"><a href="#3-3-2自定义控件" class="headerlink" title="3.3.2自定义控件"></a>3.3.2自定义控件</h4><p>新建 TitleLayout 继承自 LinearLayout，让它成为我们自定义的标题栏控件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TitleLayout extends LinearLayout {    public TitleLayout(Context context, AttributeSet attrs) {    super(context, attrs);    LayoutInflater.from(context).inflate(R.layout.title, this);    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout 控件就会调用这个构造函数。借助 LayoutInflater 来实现对标题栏布局进行动态加载。通过from()方法可以构建出一个 LayoutInflater 对象，然后调用 inflate()方法就可以动态加载一个布局文件，inflate()方法接收两个参数，第 一个参数是要加载的布局文件的 id，这里我们传入 R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里指定为 TitleLayout，直接传入this。  </p><p>接着在布局中插入我们的自定义控件。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.example.uicustomviews.TitleLayout</span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对控件的具体处理逻辑在TitleLayout中编写。</p><h4 id="3-4ListView"><a href="#3-4ListView" class="headerlink" title="3.4ListView"></a>3.4ListView</h4><h4 id="3-4-1基础"><a href="#3-4-1基础" class="headerlink" title="3.4.1基础"></a>3.4.1基础</h4><p>首先在布局中加入 ListView 控件 ，指定id、宽度、高度。在MainActivity中新建一个ListView实例并为其添加适配器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1, data);ListView listView = (ListView) findViewById(R.id.list_view);listView.setAdapter(adapter); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在ArrayAdapter 的构造函数中依次传入当前上下文、 ListView 子项布局的 id，以及要适配的数据。android.R.layout.simple_ list_item_1 作为 ListView 子项布局的 id，是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。  </p><h4 id="3-4-2进阶"><a href="#3-4-2进阶" class="headerlink" title="3.4.2进阶"></a>3.4.2进阶</h4><p>新建一个Fruit类包括名称和图片ID，创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public FruitAdapter(Context context, int textViewResourceId,    List&lt;Fruit&gt; objects) {    super(context, textViewResourceId, objects);    resourceId = textViewResourceId;} @Overridepublic View getView(int position, View convertView, ViewGroup parent) {    Fruit fruit = getItem(position); // 获取当前项的 Fruit 实例    View view = LayoutInflater.from(getContext()).inflate(resourceId, parent,        false);    ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);    TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);    fruitImage.setImageResource(fruit.getImageId());    fruitName.setText(fruit.getName());    return view; } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来。另外又重写了 getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView()方法中，首先通过 getItem()方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。 这里 LayoutInflater 的 inflate()方法接收 3 个参数，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了。  </p><h3 id="3-5RecycleView适配器"><a href="#3-5RecycleView适配器" class="headerlink" title="3.5RecycleView适配器"></a>3.5RecycleView适配器</h3><h4 id="3-5-1适配器定义"><a href="#3-5-1适配器定义" class="headerlink" title="3.5.1适配器定义"></a>3.5.1适配器定义</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; {     private List&lt;Fruit&gt; mFruitList;         static class ViewHolder extends RecyclerView.ViewHolder {     ImageView fruitImage;     TextView fruitName;     public ViewHolder(View view) {         super(view);         fruitImage = (ImageView) view.findViewById(R.id.fruit_image);         fruitName = (TextView) view.findViewById(R.id.fruit_name);         }    }     public FruitAdapter(List&lt;Fruit&gt; fruitList) {     mFruitList = fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {     View view = LayoutInflater.from(parent.getContext())         .inflate(R.layout.fruit_item, parent, false);     ViewHolder holder = new ViewHolder(view);     return holder; } @Override public void onBindViewHolder(ViewHolder holder, int position) {     Fruit fruit = mFruitList.get(position);     holder.fruitImage.setImageResource(fruit.getImageId());     holder.fruitName.setText(fruit.getName()); } @Override public int getItemCount() {     return mFruitList.size(); }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这里首先定义了一个内部类 ViewHolder，ViewHolder 要继承自 RecyclerView.ViewHolder。然后 ViewHolder 的构造函数中要传入一个 View 参数，这个参数通常就是 RecyclerView 子项。我们就可以通过 findViewById()方法来获取到布局中的 ImageView 和 TextView 的实例了。 FruitAdapter 中也有一个构造函数，这个方法用于把要展示的数据源传进来， 并赋值给一个全局变量 mFruitList，我们后续的操作都将在这个数据源的基础上进行。</p><p>由于 FruitAdapter 是继承自 RecyclerView.Adapter 的，那么就必须重写 onCreateViewHolder()、onBindViewHolder()和 getItemCount()这 3 个方法。</p><p>onCreateViewHolder()方法是用于创建 ViewHolder 实例的，在这个方法中将 fruit_item 布局加载进来，然后创建一个 ViewHolder 实例，并把加载出来的布局传入到构造函数当中，最后将 ViewHolder 的实例返回。</p><p>onBindViewHolder()方法是用于对RecyclerView 子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过 position 参数得到当前项的 Fruit 实例，然后再将数据设置到 ViewHolder 的 ImageView 和 TextView 当中即可。</p><p>getItemCount() 用于告诉 RecyclerView 一共有多少子项，直接返回数据源的长度就可以了。  </p><h4 id="3-5-2在MainActivity中调用："><a href="#3-5-2在MainActivity中调用：" class="headerlink" title="3.5.2在MainActivity中调用："></a>3.5.2在MainActivity中调用：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);LinearLayoutManager layoutManager = new LinearLayoutManager(this);recyclerView.setLayoutManager(layoutManager);FruitAdapter adapter = new FruitAdapter(fruitList);recyclerView.setAdapter(adapter); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先获取到 RecyclerView 的实例，然后创建了一个 LinearLayoutManager 对象，并将它设置到 RecyclerView 当中。LayoutManager 用于指定 RecyclerView 的布局方式，这里使用的 LinearLayoutManager 是线性布局，可以实现和 ListView 类似的效果。 接下来创建了 FruitAdapter 的实例，并将水果数据传入到 FruitAdapter 的构造函数中，最后调用 RecyclerView 的 setAdapter()方法来完成适配器设置，这样 RecyclerView 和数据之间的关联就建立完成了。  </p><h4 id="3-5-3点击事件"><a href="#3-5-3点击事件" class="headerlink" title="3.5.3点击事件"></a>3.5.3点击事件</h4><p>RecyclerView 并没有提供类似于 setOnItemClickListener() 这样的注册监听器方法，而是需要自己给子项具体的View 去注册点击事件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; {     private List&lt;Fruit&gt; mFruitList;     static class ViewHolder extends RecyclerView.ViewHolder {     View fruitView;     ImageView fruitImage;     TextView fruitName;     public ViewHolder(View view) {         super(view);                  fruitImage = (ImageView) view.findViewById(R.id.fruit_image);         fruitName = (TextView) view.findViewById(R.id.fruit_name);         }    }     public FruitAdapter(List&lt;Fruit&gt; fruitList) {     mFruitList = fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {     View view = LayoutInflater.from(parent.getContext())         .inflate(R.layout.fruit_item, parent, false);     final ViewHolder holder = new ViewHolder(view);     holder.fruitView.setOnClickListener(new View.OnClickListener() {         @Override         public void onClick(View v) {             int position = holder.getAdapterPosition();             Fruit fruit = mFruitList.get(position);             Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(),                 Toast.LENGTH_SHORT).show();         }     });      return holder; } @Override public void onBindViewHolder(ViewHolder holder, int position) {} @Override public int getItemCount() {}} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先修改ViewHolder，在 ViewHolder 中添加了 fruitView 变量来保存子项最外层布局的实例，然后在onCreateViewHolder()方法中注册点击事件。这里为最外层布局注册了点击事件，RecyclerView 的强大之处也在这里，它可以轻松实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的 position，然后通过 position 拿到相应的 Fruit 实例，再使用 Toast 分别弹出两种不同的内容以示区别。  </p><h2 id="Chap4-碎片"><a href="#Chap4-碎片" class="headerlink" title="Chap4-碎片"></a>Chap4-碎片</h2><h3 id="4-1碎片使用"><a href="#4-1碎片使用" class="headerlink" title="4.1碎片使用"></a>4.1碎片使用</h3><h4 id="4-1-1简单用法"><a href="#4-1-1简单用法" class="headerlink" title="4.1.1简单用法"></a>4.1.1简单用法</h4><p>先新建左右两侧碎片布局， left_fragment.xml、right_fragment.xml。再分别建两个碎片类 LeftFragment、RightFragment继承Fragment类。</p><p>重写父类方法加载刚刚的布局。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container,    Bundle savedInstanceState) {    View view = inflater.inflate(R.layout.left_fragment, container, false);    return view;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主活动界面中添加两个fragment控件。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fragment</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/left_fragment<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.fragmenttest.LeftFragment<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2动态添加碎片"><a href="#4-1-2动态添加碎片" class="headerlink" title="4.1.2动态添加碎片"></a>4.1.2动态添加碎片</h4><ol><li> 创建待添加的碎片实例。  </li><li> 获取FragmentManager，在活动中可以直接通过调用 getSupportFragmentManager()方法得到。  </li><li> 开启一个事务，通过调用 beginTransaction()方法开启。  </li><li> 向容器内添加或替换碎片，一般使用 replace()方法实现，需要传入容器的 id 和待添加的碎片实例。  </li><li> 提交事务，调用 commit()方法来完成。  </li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void replaceFragment(Fragment fragment) {    FragmentManager fragmentManager = getSupportFragmentManager();    FragmentTransaction transaction = fragmentManager.beginTransaction();    transaction.replace(R.id.right_layout, fragment);    transaction.commit();    //碎片中模拟返回栈    transaction.addToBackStack(null);}FragmentManager fragmentManager = getSupportFragmentManager();fragmentManager.beginTransaction()    .replace(R.id.fragment_container, ExampleFragment.class, null)    .setReorderingAllowed(true)    .addToBackStack("name") // name can be null    .commit();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addToBackStack()方法，它可以接收一个名字用于描述返回栈的状态，一般传入 null 即可。  </p><p>Each FragmentTransaction should use setReorderingAllowed(true)</p><h4 id="4-1-3碎片与活动间通信"><a href="#4-1-3碎片与活动间通信" class="headerlink" title="4.1.3碎片与活动间通信"></a>4.1.3碎片与活动间通信</h4><p>调用 FragmentManager 的 findFragmentById()方法，可以在活动中得到相应碎片的实例， 然后就能调用碎片里的方法。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">RightFragment rightFragment = (RightFragment) getSupportFragmentManager() .findFragmentById(R.id.right_fragment);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在每个碎片中都可以通过调用 getActivity()方法来得到和当前碎片相关联的活动实例。 ( 活动本身就是一个 Context 对象。  )</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">MainActivity activity = (MainActivity) getActivity();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找现有-fragment"><a href="#查找现有-fragment" class="headerlink" title="查找现有 fragment"></a>查找现有 fragment</h3><p>可以使用 findFragmentById() 获取对布局容器中当前 fragment 的引用。从 XML 扩充时，可使用 findFragmentById() 按给定的 ID 查找 fragment；在 FragmentTransaction 中添加时，可使用它按容器 ID 进行查找。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ExampleFragment fragment = (ExampleFragment) fragmentManager.findFragmentById(R.id.fragment_container);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以为 fragment 分配一个唯一的标记，并使用 findFragmentByTag() 获取引用。可以在布局中定义的 fragment 上使用 android:tag属性来分配标记，也可以在 FragmentTransaction 中的 add() 或 replace() 操作期间分配标记。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FragmentManager fragmentManager = getSupportFragmentManager();fragmentManager.beginTransaction()    .replace(R.id.fragment_container, ExampleFragment.class, null, "tag")    .setReorderingAllowed(true)    .addToBackStack(null)    .commit();...ExampleFragment fragment = (ExampleFragment) fragmentManager.findFragmentByTag("tag");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有关子-fragment-和同级-fragment-的特殊注意事项"><a href="#有关子-fragment-和同级-fragment-的特殊注意事项" class="headerlink" title="有关子 fragment 和同级 fragment 的特殊注意事项"></a>有关子 fragment 和同级 fragment 的特殊注意事项</h3><p>在任何给定的时间点，只允许一个 FragmentManager 控制 fragment 返回堆栈。如果应用在屏幕上同时显示多个同级 fragment，或者应用使用子 fragment，则必须指定一个 FragmentManager 来处理应用的主要导航。</p><p>如需在 fragment 事务内定义主要导航 fragment，请对事务调用 <a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/FragmentTransaction#setPrimaryNavigationFragment(androidx.fragment.app.Fragment)">setPrimaryNavigationFragment()</a> 方法，并传入一个 fragment 的实例，该 fragment 的 childFragmentManager 应具有主要控制权。</p><p>将导航结构视为一系列层，其中 activity 作为最外层，封装下面的每一层子 fragment。每一层都必须有一个主要导航 fragment。当发生返回事件时，最内层控制导航行为。一旦最内层再也没有可从其弹回的 fragment 事务，控制权就会向外回一层，此过程会一直重复，直至到达 activity 为止。</p><p>请注意，当同时显示两个或更多 fragment 时，其中只有一个可以是主要导航 fragment。如果将某个 fragment 设为主要导航 fragment，会移除对先前 fragment 的指定。如果将详情 fragment 设为主要导航 fragment，就会移除对主 fragment 的指定。</p><h3 id="支持多个返回堆栈"><a href="#支持多个返回堆栈" class="headerlink" title="支持多个返回堆栈"></a>支持多个返回堆栈</h3><p>使用 addToBackStack() 提交 FragmentTransaction，从而将 fragment 添加到返回堆栈：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">supportFragmentManager.beginTransaction()  .replace(R.id.fragment_container, ExampleFragment.class, null)  // setReorderingAllowed(true) and the optional string argument for  // addToBackStack() are both required if you want to use saveBackStack().  .addToBackStack("replacement")  .commit();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，可以通过调用 saveState() 来保存此 fragment 事务和 ExampleFragment 的状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">supportFragmentManager.saveBackStack("replacement");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用相同的名称参数调用 restoreBackStack()，以恢复所有弹出的事务以及所有保存的 fragment 状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">supportFragmentManager.restoreBackStack("replacement");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2碎片生命周期"><a href="#4-2碎片生命周期" class="headerlink" title="4.2碎片生命周期"></a>4.2碎片生命周期</h3><ul><li> onAttach()。当碎片和活动建立关联的时候调用。  </li><li> onCreateView()。为碎片创建视图（加载布局）时调用。  </li><li> onActivityCreated()。确保与碎片相关联的活动一定已经创建完毕的时候调用。 </li><li> onDestroyView()。当与碎片关联的视图被移除的时候调用。</li><li> onDetach()。当碎片和活动解除关联的时候调用。     </li></ul><h2 id="Chap5-广播"><a href="#Chap5-广播" class="headerlink" title="Chap5-广播"></a>Chap5-广播</h2><h3 id="5-1接收广播"><a href="#5-1接收广播" class="headerlink" title="5.1接收广播"></a>5.1接收广播</h3><p>注册广播的方式一般有两种，在代码中注册和在 AndroidManifest.xml 中注册，其中前者也被称为动态注册，后者也被称为静态注册。  </p><h4 id="5-1-1动态注册监听"><a href="#5-1-1动态注册监听" class="headerlink" title="5.1.1动态注册监听"></a>5.1.1动态注册监听</h4><p>新建一个类，让它继承自 BroadcastReceiver，并重写父类的 onReceive()方法就行了。这样当有广播到来时，onReceive()方法会被执行， 具体的逻辑就可以在这个方法中处理。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private NetworkChangeReceiver networkChangeReceiver;class NetworkChangeReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        //处理逻辑    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的类用来监听网络变化。</p><p>在onCreate（）中添加广播值设置IntentFilter</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">intentFilter = new IntentFilter();intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");networkChangeReceiver = new NetworkChangeReceiver();registerReceiver(networkChangeReceiver, intentFilter); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个 IntentFilter 的实例，给它添加一个值为 android.net.conn.CONNECTIVITY_CHANGE 的 action，当网络状态发生变化时，系统广播的值就是android.net.conn.CONNECTIVITY_CHANGE ，广播接收器想要监听什么广播，就在这里添加相应的 action。接下来创建了NetworkChangeReceiver 的实例，然后调用 registerReceiver()方法进行注册，将 NetworkChangeReceiver 的实例和 IntentFilter 的实例都传进去，这样 NetworkChangeReceiver 就会收到所有值为 android.net.conn.CONNECTIVITY_CHANGE 的广播。最后需要在onDestroy()取消注册广播。  </p><p>更进一步判断是否有网</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic void onReceive(Context context, Intent intent) {    ConnectivityManager connectionManager = (ConnectivityManager)    getSystemService(Context.CONNECTIVITY_SERVICE);    NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();    if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) {        Toast.makeText(context, "network is available",Toast.LENGTH_SHORT).show();    } else {        Toast.makeText(context, "network is unavailable",Toast.LENGTH_SHORT).show();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 getSystemService()方法得到了 ConnectivityManager 的实例，这是一个系统服务类，专门用于管理网络连接的。然后调用它的 getActiveNetworkInfo()方法可以得到 NetworkInfo 的实例，接着调用 NetworkInfo 的 isAvailable()方法， 就可以判断出当前是否有网络了，最后通过 Toast 的方式对用户进行提示。  </p><p><strong>(<strong><strong>注意权限问题</strong></strong>)</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//网络权限<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.permission.ACCESS_NETWORK_STATE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> //开机广播权限<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.permission.RECEIVE_BOOT_COMPLETED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-2静态注册"><a href="#5-1-2静态注册" class="headerlink" title="5.1.2静态注册"></a>5.1.2静态注册</h4><p> 可以让程序在未启动的情况下就能接收到广播 。通过右键New→Other→Broadcast Receiver  创建广播接收器。</p><p>这样会自动在 AndroidManifest.xml 文件中注册 ，然后我们可以在<receiver>中添加相应的action。</receiver></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>receiver</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.action.BOOT_COMPLETED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>receiver</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2发送自定义广播"><a href="#5-2发送自定义广播" class="headerlink" title="5.2发送自定义广播"></a>5.2发送自定义广播</h3><h4 id="5-2-1标准广播"><a href="#5-2-1标准广播" class="headerlink" title="5.2.1标准广播"></a>5.2.1标准广播</h4><p>在发送广播之前，需要先定义一个广播接收器来准备接收此广播。接着在  AndroidManifest.xml里的<receiver>中添加相应的action。接着在主活动中发广播。</receiver></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST");sendBroadcast(intent);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-2-2有序广播"><a href="#5-2-2有序广播" class="headerlink" title="5.2.2有序广播"></a>5.2.2有序广播</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">sendOrderedBroadcast(intent, null); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 第二个参数是一个与权限相关的字符串，传入null就行。因为是有序广播，所以可以在 AndroidManifest.xml里的<receiver>中设置优先级。</receiver></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span> <span class="token attr-name"><span class="token namespace">android:</span>priority</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样第一个接受的接收器可以设置是否允许广播继续传递。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//截断方法abortBroadcast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-3本地广播"><a href="#5-3本地广播" class="headerlink" title="5.3本地广播"></a>5.3本地广播</h3><p>本地广播发出的广播只能够在应用程序的内部进行传递，广播接收器也只能接收来自本应用程序发出的广播。</p><p>实现是通过使用了一个 LocalBroadcastManager 来对广播进行管理， 并提供了发送广播和注册广播接收器的方法。    </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private LocalBroadcastManager localBroadcastManager;    @Override    protected void onCreate(Bundle savedInstanceState) {        localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例        Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");        localBroadcastManager.sendBroadcast(intent); // 发送本地广播        intentFilter = new IntentFilter();        intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");        localReceiver = new LocalReceiver();        localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器 } class LocalReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和上面的动态注册广播差距不大，只不过变成了LocalBroadcastManager 来管理。</p><h2 id="Chap6-数据存储"><a href="#Chap6-数据存储" class="headerlink" title="Chap6-数据存储"></a>Chap6-数据存储</h2><h3 id="6-1文件存储"><a href="#6-1文件存储" class="headerlink" title="6.1文件存储"></a>6.1文件存储</h3><h4 id="6-1-1将数据存储到文件中"><a href="#6-1-1将数据存储到文件中" class="headerlink" title="6.1.1将数据存储到文件中"></a>6.1.1将数据存储到文件中</h4><p>Context 类中提供了一个 openFileOutput()方法，可以用于将数据存储到指定的文件中。 这个方法接收两个参数，第一个参数是文件名，指定的文件名不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下的。第二个参数是文件的操作模式，MODE_PRIVATE、 MODE_APPEND。</p><p>MODE_PRIVATE 是默认的操作模式，表示当指定同样文件名的时候， 写入的内容会覆盖原文件中内容。 MODE_APPEND 则表示如果该文件已存在，则追加内容，不存在就创建新文件。</p><p>openFileOutput ()方法返回的是一个 FileOutputStream 对象，得到了这个对象之后就 可以使用 Java 流的方式将数据写入到文件中。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void save() {    String data = "Data to save";    FileOutputStream out = null;    BufferedWriter writer = null;    try {        out = openFileOutput("data", Context.MODE_PRIVATE);        writer = new BufferedWriter(new OutputStreamWriter(out));        writer.write(data);    } catch (IOException e) {        e.printStackTrace();    } finally {        try {            if (writer != null) {            writer.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-2从文件中读数据"><a href="#6-1-2从文件中读数据" class="headerlink" title="6.1.2从文件中读数据"></a>6.1.2从文件中读数据</h4><p>Context 类中提供openFileInput()方法。它只接收一个参数，即文件名，然后系统会自动到/data/data//files/目录下去加载这个文件，并返回一个 FileInputStream 对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String load() {    FileInputStream in = null;    BufferedReader reader = null;    StringBuilder content = new StringBuilder();    try {        in = openFileInput("data");        reader = new BufferedReader(new InputStreamReader(in));        String line = "";        while ((line = reader.readLine()) != null) {            content.append(line);        }    } catch (IOException e) {        e.printStackTrace();    } finally {        if (reader != null) {            try {                reader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    return content.toString();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-SharedPreferences-存储"><a href="#6-2-SharedPreferences-存储" class="headerlink" title="6.2 SharedPreferences 存储"></a>6.2 SharedPreferences 存储</h3><p> SharedPreferences 是使用键值对的方式来存储数据。获取对象有三种方法</p><ol><li> <strong>Context 类中的 getSharedPreferences()方法</strong>  </li></ol><p> 方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建，SharedPreferences 文件都是存放/data/data//shared_prefs/ 目录下的。第二个参数用于指定操作模式，目前只有 MODE_PRIVATE 这一种模式可选，它是默认的操作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences 文件进行读写。</p><ol><li> <strong>Activity 类中的 getPreferences()方法</strong></li></ol><p> Context 中的 getSharedPreferences()方法相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的类名作为 SharedPreferences 的文件名。  </p><ol><li> <strong>PreferenceManager 类中的 getDefaultSharedPreferences()方法</strong>     </li></ol><p> 是一个静态方法，接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。  </p><h4 id="6-2-1存储数据步骤："><a href="#6-2-1存储数据步骤：" class="headerlink" title="6.2.1存储数据步骤："></a>6.2.1存储数据步骤：</h4><p> (1) 调用 SharedPreferences 对象的 edit()方法来获取一个 SharedPreferences.Editor 对象。</p><p> (2) 向 SharedPreferences.Editor 对象中添加数据，添加一个布尔型数据就使用 putBoolean()方法以此类推。</p><p> (3) 调用 apply()方法将添加的数据提交，从而完成数据存储操作。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SharedPreferences.Editor editor = getSharedPreferences("data",MODE_PRIVATE).edit();editor.putString("name", "Tom");editor.putInt("age", 28);editor.putBoolean("married", false);editor.apply();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-2读数据"><a href="#6-2-2读数据" class="headerlink" title="6.2.2读数据"></a>6.2.2读数据</h4><p>SharedPreferences 对象中 提供了一系列的 get 方法，用于对存储的数据进行读取。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE);String name = pref.getString("name", "");int age = pref.getInt("age", 0);boolean married = pref.getBoolean("married", false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3SQLite数据库存储"><a href="#6-3SQLite数据库存储" class="headerlink" title="6.3SQLite数据库存储"></a>6.3SQLite数据库存储</h3><p> Android提供了SQLiteOpenHelper帮助类， 借助这个类就可以非常简单地对数据库进行创建和升级。  </p><p>其中还有两个重要的实例方法：getReadableDatabase()和 getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。  </p><p>构造方法一般选择参数比较少的那个。 第一个参数是 Context。第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null。第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。  </p><h4 id="6-3-1使用SQLiteOpenHelper构建数据库："><a href="#6-3-1使用SQLiteOpenHelper构建数据库：" class="headerlink" title="6.3.1使用SQLiteOpenHelper构建数据库："></a>6.3.1使用SQLiteOpenHelper构建数据库：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyDatabaseHelper extends SQLiteOpenHelper {    //建表语句    public static final String CREATE_BOOK = "create table Book ("            + "id integer primary key autoincrement,"            + "author text,"            + "price real,"            + "pages integer,"            + "name text)";    //建表语句    public static final String CREATE_CATEGORY = "create table Category ("            + "id integer primary key autoincrement, "            + "category_name text, "            + "category_code integer)";    private Context mContext;    public MyDatabaseHelper(Context context, String name,                            SQLiteDatabase.CursorFactory factory,                            int version) {        super(context, name, factory, version);        mContext = context;    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);        db.execSQL(CREATE_CATEGORY);        Toast.makeText(mContext, "Create succeeded",                Toast.LENGTH_SHORT).show();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-3-2升级数据库"><a href="#6-3-2升级数据库" class="headerlink" title="6.3.2升级数据库"></a>6.3.2升级数据库</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {        db.execSQL("drop table if exists Book");        db.execSQL("drop table if exists Category");        onCreate(db);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一次对数据库升级都需要更改构造方法中的第四个参数，就是版本号的更新。</p><h4 id="6-3-3添加数据"><a href="#6-3-3添加数据" class="headerlink" title="6.3.3添加数据"></a>6.3.3添加数据</h4><p>SQLiteDatabase 中提供了insert()方法用于添加数据。它接收 3 个参数，第一个参数是表名。第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL，一直接传入 null 即可。第三个参数是一个 ContentValues 对象，它提供了一系列的 put()方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues(); // 开始组装第一条数据values.put("name", "The Da Vinci Code");values.put("author", "Dan Brown");values.put("pages", 454);values.put("price", 16.96);db.insert("Book", null, values); // 插入第一条数据values.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-3-4更新数据"><a href="#6-3-4更新数据" class="headerlink" title="6.3.4更新数据"></a>6.3.4更新数据</h4><p>SQLiteDatabase 中提供 update()方法用于对数据进行更新，这个方法接收 4 个参数，第一个参数是表名。第 二个参数是 ContentValues 对象，要把更新数据在这里组装进去。第三、第四个参数用于约束 更新某一行或某几行中的数据，不指定的话默认就是更新所有行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put("price",10.99);db.update("Book",values,"name = ?",new String[] {"The Da Vinco Code"});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-4-4删除数据"><a href="#6-4-4删除数据" class="headerlink" title="6.4.4删除数据"></a>6.4.4删除数据</h4><p>SQLiteDatabase 中提供delete()方法用于删除数据，这个方法接收 3 个参数， 第一个参数是表名， 第二、第三个参数又是用于约束删除某一行 或某几行的数据，不指定的话默认就是删除所有行。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">QLiteDatabase db = dbHelper.getWritableDatabase();db.delete("Book","pages &gt; ?",new String[]{"500"});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="6-4-5查询数据"><a href="#6-4-5查询数据" class="headerlink" title="6.4.5查询数据"></a>6.4.5查询数据</h4><p>SQLiteDatabase 提供 query()方法用于对数据进行查询。需要传入 7 个参数。第一个参数是表名。第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列。第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据。第五个参数用于指定需要去group by 的列，不指定则表示不对查询结果进行 group by 操作。第六个参数用于对 group by 之后的数据进行进一步的过滤，不指定则表示不进行过滤。第七个参数用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SQLiteDatabase db = dbHelper.getWritableDatabase();Cursor cursor = db.query("Book",null,null,null,null,null,null);if (cursor.moveToFirst()){    do {        //遍历Cursor对象，逐条打印        String name = cursor.getString(cursor.getColumnIndexOrThrow("name"));        String author = cursor.getString(cursor.getColumnIndexOrThrow("author"));        int pages = cursor.getInt(cursor.getColumnIndexOrThrow("pages"));        double price = cursor.getDouble(cursor.getColumnIndexOrThrow("pages"));    }while (cursor.moveToNext());}cursor.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询完之后就得到了一个 Cursor 对象，接着我 moveToFirst()方法将数据的指针移动到第一行，然后循环，遍历查询到的每一行数据。循环中可以通过 Cursor 的 getColumnIndex()方法获取到某一列在表中对应的位置索引，然后将索引传入到相应的取值方法中，就可以得到从数据库中读取到的数据了。  </p><h3 id="6-5LitePal"><a href="#6-5LitePal" class="headerlink" title="6.5LitePal"></a>6.5LitePal</h3><p>LitePal 是一款开源的 Android 数据库框架，采用了对象关系映射（ORM）的模式，并将平时开发最常用到的一些数据库功能进行了封装。</p><p><strong>build.gradle配置：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">implementation 'org.litepal.guolindev:core:3.2.3'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是会出现assets文件夹，litepal的配置文件就在里面。</p><p><strong>还要在 AndroidManifest.xml中配置：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">android:name="org.litepal.LitePalApplication"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-5-1创建升级数据库"><a href="#6-5-1创建升级数据库" class="headerlink" title="6.5.1创建升级数据库"></a>6.5.1创建升级数据库</h4><p>定义一个类（Java Bean形式），并实现getter、setter方法。接下来将类映射到模型列表中。使用<mapping> 标签来声明我们要配置的映射模型类 。下载可以直接创建数据库。</mapping></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LitePal.getDatabase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时如果想添加一个新表或者增加字段，可以直接在类中加入属性和创建一个新的类，并重新运行程序。</p><h4 id="6-5-2添加数据"><a href="#6-5-2添加数据" class="headerlink" title="6.5.2添加数据"></a>6.5.2添加数据</h4><p> 添加数据只需要创建出模型类的实例，再将所有要存储的数据设置好，最后调用一下 save()方法就可以了。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Book book = new Book();book.setName("The Da Vinci Code");book.setAuthor("Dan Brown");book.setPages(454);book.setPrice(16.96);//book.setPress("Unknown");book.save();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-5-3更新数据"><a href="#6-5-3更新数据" class="headerlink" title="6.5.3更新数据"></a>6.5.3更新数据</h4><p>方式：将已存储的对象重新设值，然后重新调用 save()方法。</p><p>对于 LitePal 来说，对象是否已存储就是根据调用 model.isSaved()方法的结果来判断的， 返回 true 就表示已存储，返回 false 就表示未存储。  </p><p>两种情况下会返回true：一种情况是已经调用过 model.save()方法去添加数据了，此时 model会被认为是已存储的对象。另一种情况是 model 对象是通过 LitePal 提供的查询 API 查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象。   </p><p>但上述方式只会改变已存储对象，有限制，所以使用另一种方式; updateAll()方法。 updateAll()方法中可以指定一个条件约束，如果不指定条件语句的话，就表示更新所有数据。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">book.setPress("Anchor");book.updateAll("name = ? and author = ?", "The Lost Symbol", "DanBrown"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>想将数据设置为默认值：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Book book = new Book();book.setToDefault("pages");book.updateAll();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-5-4删除数据"><a href="#6-5-4删除数据" class="headerlink" title="6.5.4删除数据"></a>6.5.4删除数据</h4><p>一种方式直接通过delete()删除。第二种是调用DataSupport.deleteAll()方法来删除数据 。 第一个参数用于指定删除哪张表中的数据，后面的参数用于指定约束条件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">DataSupport.deleteAll(Book.class, "price &lt; ?", "15");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-5-5查询数据"><a href="#6-5-5查询数据" class="headerlink" title="6.5.5查询数据"></a>6.5.5查询数据</h4><p><strong>查询全部数据</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Book&gt; books = DataSupport.findAll(Book.class);book.getName();...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>有用的API</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">DataSupport.findFirst(Book.class)            .findLast(Book.class)            .select("name", "author").find(Book.class)            .where("pages &gt; ?", "400").find(Book.class)            .order("price desc").find(Book.class)            .limit(3).find(Book.class)            .limit(3).offset(1).find(Book.class);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chap7-内容提供器"><a href="#Chap7-内容提供器" class="headerlink" title="Chap7-内容提供器"></a>Chap7-内容提供器</h2><p>用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性， 内容提供器可以选 择只对哪一部分数据进行共享。  </p><h3 id="7-1运行时权限"><a href="#7-1运行时权限" class="headerlink" title="7.1运行时权限"></a>7.1运行时权限</h3><h4 id="7-1-1运行时申请"><a href="#7-1-1运行时申请" class="headerlink" title="7.1.1运行时申请"></a>7.1.1运行时申请</h4><p><strong>申请流程：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断权限并申请if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {    ActivityCompat.requestPermissions(MainActivity.this, new    String[]{ Manifest.permission.CALL_PHONE }, 1);}//回调函数@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions,int[] grantResults) {    switch (requestCode) {        case 1:            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {            call();//逻辑方法            } else {                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();                }        break;    default:    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 第一步就是要先判断用户是不是已经授权了，借助 ContextCompat.checkSelfPermission()方法。方法接收两个参数， 第一个参数是 Context，第二个参数是具体的权限名，然后使用方法的返回值和 PackageManager. PERMISSION_GRANTED 做比较，相等就说明用户已经授权，不等就表示用户没有授权。 </p><p>如果已经授权直接去执行逻辑操作。如果没有授权的话，则需要调用 ActivityCompat. requestPermissions()方法来向用户申请授权。</p><p>requestPermissions()方法接收 3 个参数， 第一个参数要求是 Activity 的实例，第二个参数是一个 String 数组，我们把要申请的权限名放在数组中，第三个参数是请求码，只要是唯一值就可以了，这里传入了 1。 </p><p>调用requestPermissions()方法之后，系统会弹出一个权限申请的对话框，用户可以选择同意或拒绝，不论是哪种结果，最终都会回调到 onRequestPermissionsResult()方法中，而授权的结果则会封装在 grantResults参数当中。这里只需要判断一下最后的授权结果，如果用户同意的话就执行逻辑操作，如果用户拒绝的话放弃操作并弹出一条失败提示。  </p><h3 id="7-2访问其他程序中的数据"><a href="#7-2访问其他程序中的数据" class="headerlink" title="7.2访问其他程序中的数据"></a>7.2访问其他程序中的数据</h3><h4 id="7-2-1-ContentResolver"><a href="#7-2-1-ContentResolver" class="headerlink" title="7.2.1 ContentResolver"></a>7.2.1 ContentResolver</h4><p>想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，可以通过 Context 中的 getContentResolver()方法获取到该类的实例。ContentResolver 中提供了一系列的方法用于对数据进行 CRUD 操作。  </p><p>ContentResolver 中的增删改查方法是不接收表名参数的，而是使用一个 Uri 参数代替，这个参数被称为内容 URI。内容 URI 给内容提供器中的数据建立了唯一标识符，主要由两部分组成：authority 和 path。</p><p>authority 是用于对不同的应用程序做区分的， 一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个程序的包名是 com.example. app，那么该程序对应的 authority 就可以命名为 com.example.app. provider。path 则是用于对同一 应用程序中不同的表做区分的，通常都会添加到 authority 的后面。比如某个程序的数据库里存在 两张表：table1 和 table2，这时就可以将 path 分别命名为/table1 和/table2，然后把 authority 和 path 进行组合，内容 URI 就变成了 com.example.app.provider/table1 和 com.example.app.provider/table2。</p><p> 不过，目前还很难辨认出这两个字符串就是两个内容 URI，我们还需要在字符串的头部加上协议 声明。因此，内容 URI 最标准的格式写法如下：</p><ul><li>content://com.example.app.provider/table1  </li><li>content://com.example.app.provider/table2  </li></ul><p>内容 URI 的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以 id 结尾就表示期望访问该表中拥有相应 id 的数据。  </p><p>在得到了内容 URI 字符串之后，我们还需要将它解析成 Uri 对象才可以作为参数传入。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Uri uri = Uri.parse("content://com.example.app.provider/table1");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 只需要调用 Uri.parse()方法，就可以将内容 URI 字符串解析成 Uri 对象了。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cursor cursor = getContentResolver().query(         uri,         projection,         selection,         selectionArgs,         sortOrder); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 查询完成后返回的仍然是一个 Cursor 对象，这时我们就可以将数据从 Cursor 对象中逐个读取出来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while (cursor.moveToNext()) {    String column1 = cursor.getString(cursor.getColumnIndex("column1"));    int column2 = cursor.getInt(cursor.getColumnIndex("column2"));}cursor.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>增加</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ContentValues values = new ContentValues();values.put("column1", "text");getContentResolver().insert(uri, values);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>更新</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ContentValues values = new ContentValues();values.put("column1", "");getContentResolver().update(uri, values, "column1 = ? and column2 = ?", newString[] {"text", "1"}); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getContentResolver().delete(uri, "column2 = ?", new String[] { "1" });<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-3创建自己的内容提供器"><a href="#7-3创建自己的内容提供器" class="headerlink" title="7.3创建自己的内容提供器"></a>7.3创建自己的内容提供器</h3><p>可以通过新建一个类去继承 ContentProvider 的方式来创建一个自己的内容提供器。ContentProvider 类中有 6 个抽象方法，在继承它的时候，需要将这 6 个方法全部重写。</p><ol><li> <strong>onCreate()</strong>  </li></ol><p>初始化内容提供器的时候调用。在这里完成对数据库的创建和升级等操作，返回 true 表示内容提供器初始化成功，返回 false 则表示失败。  </p><ol start="2"><li><strong>query()</strong>  </li></ol><p>从内容提供器中查询数据。使用 uri 参数来确定查询哪张表，projection 参数用于确定查询哪些列，selection 和 selectionArgs 参数用于约束查询哪些行，sortOrder 参数用于对结果进行排序，查询的结果存放在 Cursor 对象中返回。  </p><ol start="3"><li><strong>insert()</strong>  </li></ol><p>向内容提供器中添加一条数据。使用 uri 参数来确定要添加到的表，待添加的数据保存在 values 参数中。添加完成后，返回一个用于表示这条新记录的 URI。  </p><ol start="4"><li><strong>update()</strong>  </li></ol><p>更新内容提供器中已有的数据。使用 uri 参数来确定更新哪一张表中的数据，新数据保存在 values 参数中，selection 和 selectionArgs 参数用于约束更新哪些行，受影响的行数将作 为返回值返回。  </p><ol><li> <strong>delete()</strong>  </li></ol><p>从内容提供器中删除数据。使用 uri 参数来确定删除哪一张表中的数据，selection 和 selectionArgs 参数用于约束删除哪些行，被删除的行数将作为返回值返回。  </p><ol start="5"><li><strong>getType()</strong>  </li></ol><p> 根据传入的内容 URI 来返回相应的 MIME 类型。  </p><p><strong>MIME:</strong> 主要由 3 部分组成规则如下：</p><p>必须以 vnd 开头。  </p><p>如果内容 URI 以路径结尾，则后接 android.cursor.dir/，如果内容 URI 以 id 结尾， 则后接 android.cursor.item/。   </p><p> 最后接上 vnd.<authority>.<path>。 </path></authority></p><p>UriMatcher 类就可以实现匹配内容 URI 的功能。UriMatcher 中提供了一个 addURI()方法，这个方法接收 3 个参数，可以分别把 authority、path 和一个自定义代码传进去。当调用 UriMatcher 的 match()方法时，就可以将一个 Uri 对象传入， 返回值是某个能够匹配这个 Uri 对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。 </p><p><strong>自定义代码</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DatabaseProvider extends ContentProvider {    public static final int BOOK_DIR = 0;    public static final int BOOK_ITEM = 1;    public static final int CATEGORY_DIR = 2;    public static final int CATEGORY_ITEM = 3;    public static final String AUTHORITY = "com.example.databasetest.provider";    private static UriMatcher uriMatcher;    private MyDatabaseHelper dbHelper;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(AUTHORITY, "book", BOOK_DIR);        uriMatcher.addURI(AUTHORITY, "book/#", BOOK_ITEM);        uriMatcher.addURI(AUTHORITY, "category", CATEGORY_DIR);        uriMatcher.addURI(AUTHORITY, "category/#", CATEGORY_ITEM);    }    @Override    public boolean onCreate() {        dbHelper = new MyDatabaseHelper(getContext(), "BookStore.db", null, 2);        return true;    }    @Override    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {        // 查询数据        SQLiteDatabase db = dbHelper.getReadableDatabase();        Cursor cursor = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                cursor = db.query("Book", projection, selection, selectionArgs, null, null, sortOrder);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                cursor = db.query("Book", projection, "id = ?", new String[] { bookId }, null, null, sortOrder);                break;            case CATEGORY_DIR:                cursor = db.query("Category", projection, selection, selectionArgs, null, null, sortOrder);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                cursor = db.query("Category", projection, "id = ?", new String[] { categoryId }, null, null, sortOrder);                break;            default:                break;        }        return cursor;    }    @Override    public Uri insert(Uri uri, ContentValues values) {        // 添加数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        Uri uriReturn = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:            case BOOK_ITEM:                long newBookId = db.insert("Book", null, values);                uriReturn = Uri.parse("content://" + AUTHORITY + "/book/" + newBookId);                break;            case CATEGORY_DIR:            case CATEGORY_ITEM:                long newCategoryId = db.insert("Category", null, values);                uriReturn = Uri.parse("content://" + AUTHORITY + "/category/" + newCategoryId);                break;            default:                break;        }        return uriReturn;    }    @Override    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {        // 更新数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int updatedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                updatedRows = db.update("Book", values, selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                updatedRows = db.update("Book", values, "id = ?", new String[] { bookId });                break;            case CATEGORY_DIR:                updatedRows = db.update("Category", values, selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                updatedRows = db.update("Category", values, "id = ?", new String[] { categoryId });                break;            default:                break;        }        return updatedRows;    }    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) {        // 删除数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int deletedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                deletedRows = db.delete("Book", selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                deletedRows = db.delete("Book", "id = ?", new String[] { bookId });                break;            case CATEGORY_DIR:                deletedRows = db.delete("Category", selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                deletedRows = db.delete("Category", "id = ?", new String[] { categoryId });                break;            default:                break;        }        return deletedRows;    }    @Override    public String getType(Uri uri) {        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                return "vnd.android.cursor.dir/vnd.com.example.databasetest. provider.book";            case BOOK_ITEM:                return "vnd.android.cursor.item/vnd.com.example.databasetest. provider.book";            case CATEGORY_DIR:                return "vnd.android.cursor.dir/vnd.com.example.databasetest. provider.category";            case CATEGORY_ITEM:                return "vnd.android.cursor.item/vnd.com.example.databasetest. provider.category";        }        return null;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>onCreate()：</strong></p><p>创建了一个 MyDatabaseHelper 的实例，然后返回 true 表示内容提供器初始化成功，这时数 据库就已经完成了创建或升级操作。 </p><p><strong>query()</strong> <strong>：</strong></p><p>先获取 SQLiteDatabase 的实例，然后根据传入 的 Uri 参数判断出用户想要访问哪张表，再调用 SQLiteDatabase 的 query()进行查询，并将 Cursor 对象返回。注意当访问单条数据时，这里调用了 Uri 对象的 getPathSegments()方法，它会将内容 URI 权限之后的部分以“/”符号进行分割，并把分割后 的结果放入到一个字符串列表中，那这个列表的第 0 个位置存放的就是路径，第 1 个位置存放的 就是 id 了。得到了 id 之后，再通过 selection 和 selectionArgs 参数进行约束。 </p><p><strong>insert()：</strong> </p><p>先获取到了 SQLiteDatabase 的实例，然后根据传入 的 Uri 参数判断出用户想要往哪张表里添加数据，再调用 SQLiteDatabase 的 insert()方法进行添加。</p><p><strong>注意 insert()方法要求返回一个能够表示这条新增数据的 URI，所以还需要调用 Uri.parse()方法来将一个内容 URI 解析成 Uri 对象，当然这个内容 URI 是以新增数据的id结尾的。</strong></p><p><strong>update()：</strong></p><p>先获取 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要更新哪张表里的数据，再调用 SQLiteDatabase 的 update()方法进行更新。</p><p><strong>delete()：</strong> </p><p>是先获取到 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要 删除哪张表里的数据，再调用 SQLiteDatabase 的 delete()方法进行删除。</p><p>Uri 对象的 getPathSegments()方法，它会将内容 URI 权限之后的部分以“/”符号进行分割，并把分割后 的结果放入到一个字符串列表中，那这个列表的第 0 个位置存放的就是路径，第 1 个位置存放的 就是 id 了。  </p><p><strong>注意： 内容提供器一定要在 AndroidManifest.xml 文件中注册才可以使用。</strong>  </p><h2 id="Chap8-通知"><a href="#Chap8-通知" class="headerlink" title="Chap8-通知"></a>Chap8-通知</h2><h3 id="8-1使用通知"><a href="#8-1使用通知" class="headerlink" title="8.1使用通知"></a>8.1使用通知</h3><p>Android8.0最新版本的通知要求</p><ul><li>现在必须将各个通知放入特定渠道中。</li><li>现在，用户可以按渠道关闭通知，而非关闭来自某个应用的所有通知。</li><li>包含有效通知的应用将在主屏幕/启动器屏幕上相应应用图标的上方显示通知“标志”。</li><li>现在，用户可以从抽屉式通知栏中暂停某个通知。您可以为通知设置自动超时时间。</li><li>您还可以设置通知的背景颜色。</li><li>部分与通知行为相关的 API 已从 Notification 移至 NotificationChannel。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String channelId = "channel_1";//channel的name，作为标识String name = "channel";NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);//创建channelNotificationChannel channel = new NotificationChannel(channelId, name, NotificationManager.IMPORTANCE_DEFAULT);manager.createNotificationChannel(channel);//创建PendingIntentIntent intent = new Intent(this,NotificationActivity.class);PendingIntent pi = PendingIntent.getActivity(this,0,intent,FLAG_IMMUTABLE);@SuppressLint("WrongConstant") Notification notification = new Notification.Builder(MainActivity.this)    //标题    .setContentTitle("This is content title")    //.setStyle(new NotificationCompat.BigTextStyle().bigText())    //正文文本    .setContentText()    //    .setWhen(System.currentTimeMillis())    //小图标    .setSmallIcon(R.mipmap.ic_launcher)    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))    .setChannelId(channelId)    .setContentIntent(pi)    .setAutoCancel(true)    //播放音频    .setSound(Uri.fromFile(new File()))    //产生震动（需要权限）    .setVibrate(new long[] {0,1000,1000,1000})//通知到来的时候立刻振动1秒，然后静止1秒，再振动1秒    //设置灯光    .setLights(Color.RED,1000,1000)    //默认设置    .setDefaults(DEFAULT_ALL)    //通知优先级    .setPriority(NotificationCompat.PRIORITY_MAX)    .build();//显示通知 第一个参数为指定id，第二个参数为通知的对象manager.notify(1, notification);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要使用 NotificationCompat.Builder 对象设置通知内容和渠道，且这个构造函数需要提供渠道 ID。</p><h4 id="8-1-1创建渠道并设置重要性"><a href="#8-1-1创建渠道并设置重要性" class="headerlink" title="8.1.1创建渠道并设置重要性"></a>8.1.1创建渠道并设置重要性</h4><p>必须先通过向 createNotificationChannel() 传递 NotificationChannel 的实例在系统中注册应用的通知渠道，然后才能在 Android 8.0 及更高版本上提供通知。</p><p>NotificationChannel 构造函数需要一个 importance，它会使用 NotificationManager 类中的一个常量。</p><h4 id="8-1-2设置通知的点按操作"><a href="#8-1-2设置通知的点按操作" class="headerlink" title="8.1.2设置通知的点按操作"></a>8.1.2设置通知的点按操作</h4><p>每个通知的点按操作通常是在应用中打开对应于该通知的 Activity。必须指定通过 PendingIntent 对象定义的内容 Intent，并将其传递给 setContentIntent()。</p><h4 id="8-1-3显示通知"><a href="#8-1-3显示通知" class="headerlink" title="8.1.3显示通知"></a>8.1.3显示通知</h4><p>如需显示通知，请调用 NotificationManagerCompat.notify()，并将通知的唯一 ID 和 NotificationCompat.Builder.build() 的结果传递给它。</p><h4 id="8-1-4添加操作按钮"><a href="#8-1-4添加操作按钮" class="headerlink" title="8.1.4添加操作按钮"></a>8.1.4添加操作按钮</h4><p>一个通知最多可以提供三个操作按钮，让用户能够快速响应，例如暂停提醒，甚至回复短信。但这些操作按钮不应该重复用户在点按通知时执行的操作。如需添加操作按钮，请将 addAction() 传递给 PendingIntent 方法。这就像在设置通知的默认点按操作，不同的是不会启动 Activity，而是可以完成各种其他任务。</p><h3 id="8-2权限弹窗没有时需要加入权限"><a href="#8-2权限弹窗没有时需要加入权限" class="headerlink" title="8.2权限弹窗没有时需要加入权限"></a>8.2权限弹窗没有时需要加入权限</h3><uses-permission android:name="android.permission.READ_CONTACTS"><h2 id="Chap-9网络技术"><a href="#Chap-9网络技术" class="headerlink" title="Chap-9网络技术"></a>Chap-9网络技术</h2><h3 id="9-1WebView控件"><a href="#9-1WebView控件" class="headerlink" title="9.1WebView控件"></a>9.1WebView控件</h3><p><strong>xml（需要权限）</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>WebView</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/web_view<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">WebView webView = (WebView) findViewById(R.id.web_view);webView.getSettings().setJavaScriptEnabled(true);//当一个网页跳转到另一个网页时，使目标网页仍然在当前 WebView 中显示，webView.setWebViewClient(new WebViewClient());webView.loadUrl("http://www.baidu.com");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-2访问网络"><a href="#9-2访问网络" class="headerlink" title="9.2访问网络"></a>9.2访问网络</h3><h4 id="9-2-1HttpURLConnection"><a href="#9-2-1HttpURLConnection" class="headerlink" title="9.2.1HttpURLConnection"></a>9.2.1HttpURLConnection</h4><p>首先获取HttpURLConnection 的实例，接着设置一下 HTTP 请求所使用的方法。常用的方法主要有两个：GET 和 POST。接下来就可以进行一些定制，比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等。 再调用 getInputStream()方法就可以获取到服务器返回的输入流，即可以对输入流进行读取，最后调用 disconnect()方法将这个 HTTP 连接关闭掉。（<strong>权限</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">url = new URL("http://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setRequestMethod("GET");connection.setConnectTimeout(8000);connection.setReadTimeout(8000);InputStream in = connection.getInputStream();connection.disconnect();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在获取到服务器返回的输入流后，利用 BufferedReader 对 服务器返回的流进行读取。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader reader = new BufferedReader(new InputStreamReader(in));StringBuilder response = new StringBuilder();String line;while ((line = reader.readLine()) != null) {    response.append(line);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-2-2OkHttp-（主页：https-github-com-square-okhttp-）"><a href="#9-2-2OkHttp-（主页：https-github-com-square-okhttp-）" class="headerlink" title="9.2.2OkHttp （主页：https://github.com/square/okhttp ）"></a>9.2.2OkHttp （主页：<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a> ）</h4><p><strong>添加依赖</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">implementation 'com.squareup.okhttp3:okhttp:3.10.0'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先需要创建一个OkHttpClient 的实例，想要发起一条 HTTP 请求，就需要创建一个 Request 对象，可以在最 终的build()方法之前连缀很多其他方法来丰富这个Request 对象。之后调用 OkHttpClient 的 newCall()方法来创建一个 Call 对象，并调用它的 execute()方法来发送请求并获取服务器返回的数据，其中 Response 对象就是服务器返回的数据了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">OkHttpClient client = new OkHttpClient();Request request = new Request.Builder()    .url("https://127.0.0.1/get_data.xml")    .build();Response response = client.newCall(request).execute();String responseData = response.body().string();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发起一条 POST 需要先构建出一个 Request Body 对象来存放待提交的参数，然后在 Request.Builder 中调用一下 post()方法，并将 RequestBody 对象传入   调用 execute()方法来发送请求并获取服务器返回的数据即可。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">RequestBody requestBody = new FormBody.Builder() .add("username", "admin") .add("password", "123456") .build();Request request = new Request.Builder() .url("http://www.baidu.com") .post(requestBody) .build(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-3解析XML"><a href="#9-3解析XML" class="headerlink" title="9.3解析XML"></a>9.3解析XML</h3><h4 id="9-3-1Pull解析"><a href="#9-3-1Pull解析" class="headerlink" title="9.3.1Pull解析"></a>9.3.1Pull解析</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void parseXMLWithPull(String xmlData) {        try {            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();            XmlPullParser xmlPullParser = factory.newPullParser();            xmlPullParser.setInput(new StringReader(xmlData));            int eventType = xmlPullParser.getEventType();            String id = "";            String name = "";            String version = "";            while (eventType != XmlPullParser.END_DOCUMENT) {                String nodeName = xmlPullParser.getName();                switch (eventType) {                    case XmlPullParser.START_TAG: {                        if ("id".equals(nodeName)) {                            id = xmlPullParser.nextText();                        } else if ("name".equals(nodeName)) {                            name = xmlPullParser.nextText();                        } else if ("version".equals(nodeName)) {                            version = xmlPullParser.nextText();                        }                        break;                    }                    case XmlPullParser.END_TAG: {                        if ("app".equals(nodeName)) {                            Log.d(TAG, "id is " + id);                            Log.d(TAG, "name is " + name);                            Log.d(TAG, "version is " + version);                        }                        break;                    }                    default:                        break;                }                eventType = xmlPullParser.next();            }        } catch (Exception e) {            e.printStackTrace();        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要获取到一个 XmlPullParserFactory 的实例，并借助这个实例得到 XmlPullParser 对象，然后调用 XmlPullParser 的 setInput()方法将服务器返回的 XML 数据设置进去就可以开始解析了。</p><p>解析的过程通过 getEventType()可以得到当前的解析事件，然后在一个 while 循环中不断地进行解析，如果当前的解析事件不等于 XmlPullParser.END_DOCUMENT，说明解析工作还没完成，调用 next()方法后可以获取下一个解析事件。 在 while 循环中，我们通过 getName()方法得到当前节点的名字，如果发现节点名等于 id、 name 或 version，就调用 nextText()方法来获取节点内具体的内容，每当解析完一个 app 节点后 就将获取到的内容打印出来。  </p><h4 id="9-3-2SAX解析"><a href="#9-3-2SAX解析" class="headerlink" title="9.3.2SAX解析"></a>9.3.2SAX解析</h4><p> 新建一个类继承自 DefaultHandler，并重写父类的 5 个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyHandler extends DefaultHandler {    @Override    public void startDocument() throws SAXException {    }    @Override    public void startElement(String uri, String localName, String qName, Attributesattributes) throws SAXException {    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {    }    @Override    public void endElement(String uri, String localName, String qName) throwsSAXException {    }    @Override    public void endDocument() throws SAXException {    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>startDocument()方法会在开始 XML 解析的时候调用。</p><p>startElement()方法会在开始解析某个节点的时候调用。</p><p>characters()方法会在获取节点中内容的时候调用。</p><p>endElement()方法会在完成解析某个节点的时候调用。</p><p>endDocument()方法会 在完成整个 XML 解析的时候调用。</p><p>其中，startElement()、characters()和 endElement()这 3 个方法是有参数的，从 XML 中解析出的数据就会以参数的形式传入到这些方法中。在获取节点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作 内容解析出来，需要针对这种情况在代码中做好控制。  </p><h3 id="9-4解析JSON"><a href="#9-4解析JSON" class="headerlink" title="9.4解析JSON"></a>9.4解析JSON</h3><h4 id="9-4-1JSONObject"><a href="#9-4-1JSONObject" class="headerlink" title="9.4.1JSONObject"></a>9.4.1JSONObject</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void parseJSONWithJSONObject(String jsonData) {    try {        JSONArray jsonArray = new JSONArray(jsonData);        for (int i = 0; i &lt; jsonArray.length(); i++) {            JSONObject jsonObject = jsonArray.getJSONObject(i);            String id = jsonObject.getString("id");        }    } catch (Exception e) {        e.printStackTrace();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 将服务器返回的数据传入到了一个 JSONArray 对象中。然后循环遍历这个 JSONArray，从中取出的每一个元素都 是一个 JSONObject 对象，每个 JSONObject 对象中又会包含 id、name 和 version 这些数据。  </p><h4 id="9-4-2GSON"><a href="#9-4-2GSON" class="headerlink" title="9.4.2GSON"></a>9.4.2GSON</h4><h3 id="9-5Java回调机制"><a href="#9-5Java回调机制" class="headerlink" title="9.5Java回调机制"></a>9.5Java回调机制</h3><p>sendOkHttpRequest()方法中有一个 okhttp3.Callback 参数，这个是 OkHttp 库中自带的一个回调接口，类似于我们刚才自己编写的 HttpCallbackListener。然后在 client. newCall()之后没有像之前那样一直调用 execute()方法，而是调用了一个 enqueue()方法，并 把 okhttp3.Callback 参数传入。相信聪明的你已经猜到了，OkHttp 在 enqueue()方法的内部 已经帮我们开好子线程了，然后会在子线程中去执行 HTTP 请求，并将最终的请求结果回调到 okhttp3.Callback 当中。  </p><h3 id="9-6出现ERR-UNKNOWN-URL-SCHEME"><a href="#9-6出现ERR-UNKNOWN-URL-SCHEME" class="headerlink" title="9.6出现ERR_UNKNOWN_URL_SCHEME"></a>9.6出现ERR_UNKNOWN_URL_SCHEME</h3><p><img src="095.png"></p><p>这是因为其自定义了scheme，类似的还有alipays://，weixin:// 等等。而webView只能识别http://或https://开头的url，因此才会报此错。想处理也很简单，对于这种自定义scheme的url单独处理即可。如果需要做成一个类似浏览器的形式，只需判断开头是否是http://或https://。</p><h3 id="9-7Apache安装"><a href="#9-7Apache安装" class="headerlink" title="9.7Apache安装"></a>9.7Apache安装</h3><p>先用管理员身份启动cmd并且cd到Apache的bin目录下。cd到D盘时需要加 “/d”，不然不起作用。</p><p>httpd.exe -k install 命令，如果成功则可以 start httpd.exe，失败则看提示信息哪里出错。</p><p>“ ServerRoot must be a valid directory”。这个错误是在httpd.conf中找不到Apache24文件，修改Options的路径即可。</p><h2 id="Chap10-线程及服务"><a href="#Chap10-线程及服务" class="headerlink" title="Chap10-线程及服务"></a>Chap10-线程及服务</h2><h3 id="10-1多线程"><a href="#10-1多线程" class="headerlink" title="10.1多线程"></a>10.1多线程</h3><h4 id="10-1-1基本用法"><a href="#10-1-1基本用法" class="headerlink" title="10.1.1基本用法"></a>10.1.1基本用法</h4><p><strong>继承Thread类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyThread extends Thread { @Override public void run() { // 处理具体的逻辑 }}//启动new MyThread().start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现Runnable接口</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyThread implements Runnable { @Override public void run() { // 处理具体的逻辑 }} //启动MyThread myThread = new MyThread();new Thread(myThread).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>匿名类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">new Thread(new Runnable() { @Override public void run() { // 处理具体的逻辑 }}).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-1-2在子线程中操作UI"><a href="#10-1-2在子线程中操作UI" class="headerlink" title="10.1.2在子线程中操作UI"></a>10.1.2在子线程中操作UI</h4><p>新增一个 Handler 对象，并重写父类的 handleMessage()方法，在这里对具体的 Message 进行 处理。创建一个 Message（android.os.Message）对象，并将它的 what 字段的值指定为 UPDATE_TEXT，然后调用 Handler 的 sendMessage()方法将这条 Message 发送出去。  </p><h3 id="10-2异步消息处理机制"><a href="#10-2异步消息处理机制" class="headerlink" title="10.2异步消息处理机制"></a>10.2异步消息处理机制</h3><ol><li> <strong>Message</strong>  </li></ol><p>Message 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。有Message 的 what 字段，还可以使用 arg1 和 arg2 字 段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。  </p><ol><li> <strong>Handler</strong>  </li></ol><p>Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage()方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage()方法中。  </p><ol><li> <strong>MessageQueue</strong>  </li></ol><p>MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。  </p><ol><li> <strong>Looper</strong>  </li></ol><p>Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后，就会进入到 一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象。  </p><h4 id="10-2-1-使用-AsyncTask"><a href="#10-2-1-使用-AsyncTask" class="headerlink" title="10.2.1 使用 AsyncTask"></a>10.2.1 使用 AsyncTask</h4><p>AsyncTask 是一个抽象类，必须要创建一个子类去继承它。在继承时可以为 AsyncTask 类指定 3 个泛型参数</p><ul><li> <strong>Params</strong>  ： 在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。  </li><li> <strong>Progress</strong>  ： 后台任务执行时，如果需要在界面上显示当前的进度。</li><li> <strong>Result</strong>  ： 当任务执行完毕后，如果需要对结果进行返回 。</li></ul><p> 经常需要去重写的方法有以下 4 个。  </p><ol><li> <strong>onPreExecute()</strong>  </li></ol><p> 这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作 。</p><ol start="2"><li><strong>doInBackground(Params…)</strong>  </li></ol><p>这个方法中的所有代码都会在子线程中运行，应该在这里去处理所有的耗时任务。任务完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的。</p><ol start="3"><li><strong>onProgressUpdate(Progress…)</strong>  </li></ol><p>当调用了 publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新。  </p><ol start="4"><li><strong>onPostExecute(Result)</strong>  </li></ol><p>当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作。  </p><h3 id="10-3服务的基本用法"><a href="#10-3服务的基本用法" class="headerlink" title="10.3服务的基本用法"></a>10.3服务的基本用法</h3><h4 id="10-3-1启动和停止"><a href="#10-3-1启动和停止" class="headerlink" title="10.3.1启动和停止"></a>10.3.1启动和停止</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent startIntent = new Intent(this, MyService.class);startService(startIntent); // 启动服务Intent stopIntent = new Intent(this, MyService.class);stopService(stopIntent); // 停止服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MyService 的任何一个位置调用 stopSelf()方法就能让这个服务停止。  </p><h4 id="10-3-2活动和服务通信"><a href="#10-3-2活动和服务通信" class="headerlink" title="10.3.2活动和服务通信"></a>10.3.2活动和服务通信</h4><p> <strong>onBind()方法</strong>  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent bindIntent = new Intent(this, MyService.class);bindService(bindIntent, connection, BIND_AUTO_CREATE); // 绑定服务unbindService(connection); // 解绑服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-3-3前台服务"><a href="#10-3-3前台服务" class="headerlink" title="10.3.3前台服务"></a>10.3.3前台服务</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent intent = new Intent(this, MainActivity.class);PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);Notification notification = new NotificationCompat.Builder(this)    .setContentTitle("This is content title")    .setContentText("This is content text")    .build();startForeground(1, notification);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构建出 Notification 对象后 并没有使用 NotificationManager 来将通知显示出来，而是调用了 startForeground()方法。</p><p>这个方法接收两个参数，第一个参数是通知的 id，类似于 notify()方法的第一个参数，第二个参数则是构建出的 Notification 对象。调用 startForeground()方法后就会让 MyService 变成 一个前台服务，并在系统状态栏显示出来。  </p><h4 id="10-3-4IntentService"><a href="#10-3-4IntentService" class="headerlink" title="10.3.4IntentService"></a>10.3.4IntentService</h4><p> 应该在服务的每个具体的方法里开启一个子线程，然后在这里去处理那些耗时的逻辑。为了可以简单地创建一个异步的、会自动停止的服务，Android 专门提供了一个 IntentService 类。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyIntentService extends IntentService { public MyIntentService() { super("MyIntentService"); // 调用父类的有参构造函数 } @Override protected void onHandleIntent(Intent intent) { // 打印当前线程的 id Log.d("MyIntentService", "Thread id is " + Thread.currentThread(). getId()); }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数。然后要在子类中去实现 onHandleIntent()这个抽象方法，在这个方法中可以去处理一些具体的逻辑， 而且不用担心 ANR 的问题，因为这个方法已经是在子线程中运行的了。  </p><h2 id="Chap11-使用第三方定位软件（百度）"><a href="#Chap11-使用第三方定位软件（百度）" class="headerlink" title="Chap11-使用第三方定位软件（百度）"></a>Chap11-使用第三方定位软件（百度）</h2><h3 id="11-1申请API-Key"><a href="#11-1申请API-Key" class="headerlink" title="11.1申请API Key"></a>11.1申请API Key</h3><p>首先需要创建应用，百度申请网址是：<a href="https://lbsyun.baidu.com/apiconsole/key#/home%E3%80%82%E5%9C%A8%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%EF%BC%8C%E5%9C%A8%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%80%89%E9%A1%B9%E6%A0%8FBuild%E4%B8%8BGenerate">https://lbsyun.baidu.com/apiconsole/key#/home。在创建应用的时候需要自己项目的签名文件，在已有项目中选项栏Build下Generate</a> single文件，选取文件位置并设置密码等信息。</p><p><img src="11.1.png"></p><h3 id="11-2配置Android-Studio环境"><a href="#11-2配置Android-Studio环境" class="headerlink" title="11.2配置Android Studio环境"></a>11.2配置Android Studio环境</h3><p>提交后得到项目的访问应用（AK），在注册文件中添加<meta>信息如下图所示：</p><p><img src="112.png"></p><p>我们需要下载百度地图集成后的SDK并解压到我们的项目文件下。创建与src同级的libs文件夹放置jar包，创建与java同级的jniLibs放置.so文件，并在依赖文件中加入文件路径。</p><p>（具体提示信息网站：<a href="https://lbsyun.baidu.com/index.php?title=android-locsdk/guide/create-project/android-studio%EF%BC%89">https://lbsyun.baidu.com/index.php?title=android-locsdk/guide/create-project/android-studio）</a></p><p><img src="112-2.png" alt="img"></p><h3 id="11-3获取自己的经纬度"><a href="#11-3获取自己的经纬度" class="headerlink" title="11.3获取自己的经纬度"></a>11.3获取自己的经纬度</h3><p>因为获取经纬度需要用到手机位置信息，需要申请权限，所以现在注册文件下将权限申请一下。之后还需要再注册一个 LBS SDK 中的服务。</p><p>图中的权限包括了本项目所有需要申请的权限信息。</p><p><img src="112-3.png"></p><p><img src="112-4.png"></p><h4 id="LocationClient实例"><a href="#LocationClient实例" class="headerlink" title="LocationClient实例"></a>LocationClient实例</h4><p> 在 onCreate()方法中，首先创建了一个 LocationClient 的实例， 构建函数接收 Context 参数，这里调用 getApplicationContext()方法来获取一个全局的 Context 参数并传入。然后调用 LocationClient 的 registerLocationListener()方法来注册一个定位监听器，当获取到位置信息的时候，就会回调这个定位监听器。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public LocationClient mLocationClient;onCreate(){    //新增定位SDK隐私合规接口    LocationClient.setAgreePrivacy(true);     //setAgreePrivacy接口需要在LocationClient实例化之前调用     //如果setAgreePrivacy接口参数设置为了false，则定位功能不会实现     //true，表示用户同意隐私合规政策     //false，表示用户不同意隐私合规政策        //实例化LocationClient时，需要捕获异常信息    mLocationClient = new LocationClient(getApplicationContext());        //在使用mLocationClient时，请注意需要加判空处理    mLocationClient.registerLocationListener(new MyLocationListener());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h4><p>首先创建一个空的 List 集合，然后依次判断权限有没有被授权， 没被授权就添加到 List 集合中，最后将 List 转换成数组，再调用 ActivityCompat. requestPermissions()方法一次性申请。onRequestPermissionsResult()方法中通过一个循环将申请的每个权限都进行了判断，如果有任何一个权限被拒绝， 那么就直接调用 finish()方法关闭当前程序，只有当所有权限都被用户同意了，才会调用 requestLocation()方法开始地理位置定位。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//权限列表List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();if (ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {    permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION);}//其他权限全部这样操作 Manifest.permission.READ_PHONE_STATE、WRITE_EXTERNAL_STORAGE//转换为数组并调用requestPermissions() if (!permissionList.isEmpty()) {    String[] permissions = permissionList.toArray(new String[    permissionList.size()]);    ActivityCompat.requestPermissions(MainActivity.this, permissions, 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>requestLocation()方法中的代码比较简单，只是调用了一下 LocationClient 的 start() 方法就能开始定位了。</p><h4 id="位置监听器"><a href="#位置监听器" class="headerlink" title="位置监听器"></a>位置监听器</h4><p>定位的结果会回调到我们前面注册的监听器当中——MyLocationListener。MyLocationListener 的 onReceiveLocation()方法中，通过 BDLocation 的 getLatitude()方法获取纬度，通过 getLongitude()方法获取经度，通过 getLocType()方法获取当前的定位方式，将结果组装成一个字符串，显示到 TextView 上面。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyLocationListener implements BDLocationListener {    runOnUiThread(new Runnable() {         @Override        public void run() {                    StringBuilder currentPosition = new StringBuilder();                    currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n");                    currentPosition.append("经线：").append(bdLocation.getLongitude()).append("\n");                    currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n");                    currentPosition.append("省：").append(bdLocation.getProvince()).append("\n");                    currentPosition.append("市：").append(bdLocation.getCity()).append("\n");                    currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n");                    currentPosition.append("街道:").append(bdLocation.getStreet()).append("\n");                    currentPosition.append("定位方式");                    positionText.setText(currentPosition);                }            });        }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实时定位自己的位置"><a href="#实时定位自己的位置" class="headerlink" title="实时定位自己的位置"></a>实时定位自己的位置</h4><p> 创建LocationClientOption 对象，然后调用 setScanSpan()方法来设置更新的间隔。这里传入了 5000，表示每 5 秒钟会更新一下当前的位置。 在活动被销毁的时候一定要调用 LocationClient 的 stop()方法来停止定位， 不然程序会持续在后台不停地进行定位，从而严重消耗手机的电量。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LocationClientOption option = new LocationClientOption();option.setScanSpan(5000);mLocationClient.setLocOption(option);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="更改定位模式"><a href="#更改定位模式" class="headerlink" title="更改定位模式"></a>更改定位模式</h4><p> LBS SDK 的定位模式一共有 3 种模式可选：Hight_Accuracy、Battery_Saving 和 Device_Sensors。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="获取详细位置信息"><a href="#获取详细位置信息" class="headerlink" title="获取详细位置信息"></a>获取详细位置信息</h4><p> 调用LocationClientOption 的 setIsNeedAddress() 方法，并传入 true 。接着在 onReceiveLocation()方法中可以get各种信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">option.setIsNeedAddress(true);currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n");currentPosition.append("省：").append(bdLocation.getProvince()).append("\n");currentPosition.append("市：").append(bdLocation.getCity()).append("\n");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-4使用百度地图"><a href="#11-4使用百度地图" class="headerlink" title="11.4使用百度地图"></a>11.4使用百度地图</h3><p>在使用百度地图之前我们需要继续对Android Studio进行配置，详细请见网址：<a href="https://lbsyun.baidu.com/index.php?title=androidsdk/guide/create-map/showmap">https://lbsyun.baidu.com/index.php?title=androidsdk/guide/create-map/showmap</a></p><p>在xml中新建com.baidu.mapapi.map.MapView</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.baidu.mapapi.map.MapView</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/bdmapView<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>clickable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化地图，在onResume和onPause中更新状态</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SDKInitializer.setAgreePrivacy(getApplicationContext(),true);SDKInitializer.initialize(getApplicationContext());SDKInitializer.setCoordType(CoordType.BD09LL);mapView = findViewById(R.id.bdmapView);mapView.onResume();mapView.onPause();mapView.onDestroy();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="移动到我的位置"><a href="#移动到我的位置" class="headerlink" title="移动到我的位置"></a>移动到我的位置</h4><p> 百度LBS SDK 的 API 中提供了一个 BaiduMap 类，它是地图的总控制器，调用 MapView 的 getMap()方法就能获取到 BaiduMap 的实例。有了 BaiduMap 后，我们就能对地图进行各种各样的操作了，比如设置地图的缩放级别以及 将地图移动到某一个经纬度上。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">baiduMap = mapView.getMap();//中 MapStatusUpdateFactory 的 zoomTo()方法接收一个 float 型的参数，就是用于设置缩//放级别的，zoomTo()方法返回一个 MapStatusUpdate 对象，我们把这个对象传入 BaiduMap 的 animateMapStatus()方法当中即可完成缩放功能。MapStatusUpdate update = MapStatusUpdateFactory.zoomTo(12.5f);baiduMap.animateMapStatus(update); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>移动地图借助 LatLng 类，它的构造方法接收两个参数，第一个参 数是纬度值，第二个参数是经度值。之后调用 MapStatusUpdateFactory 的 newLatLng()方法将 LatLng 对象传入，newLatLng()方法返回的也是一个 MapStatusUpdate 对象，我们再把这个对 象传入 BaiduMap 的 animateMapStatus()方法当中，就可以将地图移动到指定的经纬度上了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LatLng ll = new LatLng(location.getLatitude(),location.getLongitude());MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);baiduMap.animateMapStatus(update);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="显式我的位置"><a href="#显式我的位置" class="headerlink" title="显式我的位置"></a>显式我的位置</h4><p>百度 LBS SDK 当中提供了一个 MyLocationData.Builder 类，这个类是用来封装设备当前所在位置的，我们只需将经纬度信息传入到这个类的相应方法当中就可以了。</p><p>MyLocationData.Builder 类还提供了一个 build()方法，当我们把要封装的信息都设置完成之后，只需要调用它的 build()方法，就会生成一个 MyLocationData 的实例，然后再将这个 实例传入到 BaiduMap 的 setMyLocationData()方法当中，就可以让设备当前的位置显示在地图上了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//需要将此方法开启才会显式baiduMap.setMyLocationEnabled(true);MyLocationData.Builder locationBuilder = new MyLocationData.Builder();locationBuilder.latitude(location.getLatitude());locationBuilder.longitude(location.getLongitude());MyLocationData locationData = locationBuilder.build();baiduMap.setMyLocationData(locationData);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chap12-Material-Design"><a href="#Chap12-Material-Design" class="headerlink" title="Chap12-Material Design"></a>Chap12-Material Design</h2><h3 id="12-1ToolBar"><a href="#12-1ToolBar" class="headerlink" title="12.1ToolBar"></a>12.1ToolBar</h3><p>使用 Toolbar 来替代 ActionBar，需要指定一个不带 ActionBar 的主题， 通常有Theme.AppCompat.NoActionBar 和Theme.AppCompat.Light.NoActionBar这两种主题可选。修改 activity_main.xml 中的代码创建ToolBar。</p><p> Toolbar 主题，使用 android:theme 属性。</p><p> app:popupTheme 属性单独将弹出的菜单项指定成了淡色主题。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.appcompat.widget.Toolbar</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/toolbar<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/actionBarSize<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/colorPrimary<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@style/ThemeOverlay.AppCompat.Dark.ActionBar<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>layout_scrollFlags</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scroll|enterAlways|snap<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>popupTheme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@style/ThemeOverlay.AppCompat.Light<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现ToolBar</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Toolbar toolbar = findViewById(R.id.toolbar);setSupportActionBar(toolbar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ToolBar技巧，给activity 增加一个 android:label 属性，用于指定在 Toolbar 中显示的文字内容， 如果没有指定的话，会默认使用应用名称 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">android:label="Fruits"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ToolBar样式修改。新建toolbar.xml文件，可通过item标签定义action按钮。showAsAction指定按钮的显示位置  。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/backup<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/ic_backup<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Backup<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>showAsAction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>always<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行toolbar:在 onCreateOptionsMenu()方法中加载toolbar.xml 这个菜单文件，然后 在 onOptionsItemSelected()方法中处理各个按钮的点击事件。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.toolbar,menu);        return true;    }@Overridepublic boolean onOptionsItemSelected(@NonNull MenuItem item) {    switch (item.getItemId()){        case android.R.id.home://HomeAsUp按钮id永远是这个            mDrawerLayout.openDrawer(GravityCompat.START);            break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-2滑动菜单"><a href="#12-2滑动菜单" class="headerlink" title="12.2滑动菜单"></a>12.2滑动菜单</h3><h4 id="12-2-1DrawerLayout设置滑动菜单"><a href="#12-2-1DrawerLayout设置滑动菜单" class="headerlink" title="12.2.1DrawerLayout设置滑动菜单"></a>12.2.1DrawerLayout设置滑动菜单</h4><p> DrawerLayout是一个布局，在布局中允许放入两个直 接子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。  </p><p>在主界面xml中编写， 第一个子控件是 FrameLayout，用于作为主屏幕中显 示的内容。第二个子控件使用了一个 TextView，用 于作为滑动菜单中显示的内容，内容控件没有要求。  但是第二个控件需要制定layout_gravity 属性，需要告诉 DrawerLayout 滑动菜单是在屏幕的左边还是右边，left 表示滑动菜单在左边，right 表示滑动菜单在右边。start，表示会根据系统语言进行判断。   </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.drawerlayout.widget.DrawerLayout</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FrameLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FrameLayout</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token attr-name">\</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.drawerlayout.widget.DrawerLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在ToolBar左边加入菜单栏action"><a href="#在ToolBar左边加入菜单栏action" class="headerlink" title="#### 在ToolBar左边加入菜单栏action"></a>#### 在ToolBar左边加入菜单栏action</h4><p>首先调用 findViewById()方法得到了 DrawerLayout 的实例，然后调用 getSupportActionBar()方法得到了 ActionBar 的实例。接着调用 ActionBar 的 setDisplayHomeAsUpEnabled()方法让导航按钮显示出来，又调用了 setHomeAsUpIndicator()方法来设置一个导航按钮图标。实际上， Toolbar 最左侧的这个按钮就叫作 HomeAsUp 按钮，它默认的图标是一个返回的箭头，含义是返回上一个活动。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mDrawerLayout = findViewById(R.id.drawer_layout);ActionBar actionBar = getSupportActionBar();actionBar.setDisplayHomeAsUpEnabled(true);//设置导航按钮图标actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在 onOptionsItemSelected()方法中对 HomeAsUp 按钮的点击事件进行处理， HomeAsUp 按钮的 id 永远都是 android.R.id.home。然后调用 DrawerLayout 的 openDrawer() 方法将滑动菜单展示出来，注意 openDrawer()方法要求传入一个 Gravity 参数，为了保证这里的行为和 XML 中定义的一致，我们传入了 GravityCompat.START。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">case android.R.id.home://HomeAsUp按钮id永远是这个    mDrawerLayout.openDrawer(GravityCompat.START);    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="12-2-2NavigationView-优化滑动菜单"><a href="#12-2-2NavigationView-优化滑动菜单" class="headerlink" title="12.2.2NavigationView 优化滑动菜单"></a>12.2.2NavigationView 优化滑动菜单</h4><p>首先要引用Design Support 和CircleImageView库。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">implementation 'de.hdodenhof:circleimageview:3.1.0'implementation 'com.android.support:design:24.2.1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要准备 menu 和 headerLayout 。在menu文件夹下创建 Menu resource file 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>group</span> <span class="token attr-name"><span class="token namespace">android:</span>checkableBehavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>single<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>   <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/nav_call<span class="token punctuation">"</span></span>   <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/nav_call<span class="token punctuation">"</span></span>   <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Call<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>group</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><menu>中嵌套了一个<group>标签，然后将 group 的 checkableBehavior 属性指定为 single。group 表示一个组，checkableBehavior 指定为 single 表示组中的所有菜单项只能单选。 菜单项使用item定义。其中属性定义id、title、icon。<p>在layout文件夹下创建Layout resource file 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>180dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/colorPrimary<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>de.hdodenhof.circleimageview.CircleImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/icon_image<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>70dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>70dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_centerInParent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/nav_icon<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>布局文件的最外层是一个 RelativeLayout，宽度设为 match_parent， 高度设为 180dp，指定背景色为 colorPrimary。 在 RelativeLayout 中我们放置了 3 个控件，CircleImageView 是一个用于将图片圆形化的控件， 它指定了一张图片作为头像，然后设置为居中显示。另外两个 TextView 分别用于显示用户名和邮箱地址。</p><p>准备好header和menu后可以再DrawerLayout中部署NavigationView了。将header和menu设置为刚刚写好的文件。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.navigation.NavigationView</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/nav_view<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>start<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>headerLayout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@layout/nav_header<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>menu</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@menu/nav_menu<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着在MainActivity中配置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">NavigationView navView = findViewById(R.id.nav_view);navView.setCheckedItem(R.id.nav_call);navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {    @Override    public boolean onNavigationItemSelected(@NonNull MenuItem item) {        mDrawerLayout.closeDrawers();        return true;    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先获取NavigationView 的实例，然后调用它的setCheckedItem()方法将 Call 菜单项设置为默认选中。调用setNavigationItemSelectedListener()方法来设置一个菜单项选中事件的监听器，当用户点击了任意菜单项时， 就会回调到 onNavigationItemSelected()方法中。在这个方法中写相应的逻辑处理，这里调用了 DrawerLayout 的 closeDrawers()方法将滑动菜单关闭。  </p><h3 id="12-3悬浮按钮和可交互"><a href="#12-3悬浮按钮和可交互" class="headerlink" title="12.3悬浮按钮和可交互"></a>12.3悬浮按钮和可交互</h3><h4 id="12-3-1FloatingActionButton"><a href="#12-3-1FloatingActionButton" class="headerlink" title="12.3.1FloatingActionButton"></a>12.3.1FloatingActionButton</h4><p>在页面中插入悬浮按钮,代码都是一些基础设置，配置了大小、图片、悬浮高度、施放位置。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.floatingactionbutton.FloatingActionButton</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/fab<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bottom|end<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>16dp<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/ic_done<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>elevation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>8dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>悬浮按钮和普通按钮差异很小，在使用时需要创建实例并且有点击事件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FloatingActionButton fab = findViewById(R.id.fab);fab.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Toast.makeText(MainActivity.this,"FAB clicked ",Toast.LENGTH_SHORT).show();    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-3-2Snackbar"><a href="#12-3-2Snackbar" class="headerlink" title="12.3.2Snackbar"></a>12.3.2Snackbar</h4><p>Snackbar 不是 Toast 的替代品，它们两者之间有着不同的应用场景。Toast 的 作用是告诉用户现在发生了什么事情，但同时用户只能被动接收这个事情，因为没有什么办法能 让用户进行选择。而 Snackbar 则在这方面进行了扩展，它允许在提示当中加入一个可交互按钮， 当用户点击按钮的时候可以执行一些额外的逻辑操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Snackbar.make(v,"Data deleted",Snackbar.LENGTH_SHORT).setAction(                    "Undo", new View.OnClickListener() {    @Override    public void onClick(View v) {        Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show();    }}).show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用Snackbar 的 make()方法来创建一个 Snackbar 对象，make()方法的第一个参数需要传入一个 View，只要是当前界面布局的任意一个 View 都可以，Snackbar 会使用 这个 View 来自动查找最外层的布局，用于展示 Snackbar。第二个参数就是 Snackbar 中显示的内容，第三个参数是 Snackbar 显示的时长。又调用 setAction()方法来设置一个动作，从而让 Snackbar 不仅仅是一个提示，而是可以和用户进行交互的。在动作按钮的点击事件里面弹出一个 Toast 提示。最后调用 show()方法让 Snackbar 显示出来。</p><h4 id="12-3-3-CoordinatorLayout"><a href="#12-3-3-CoordinatorLayout" class="headerlink" title="12.3.3 CoordinatorLayout"></a>12.3.3 CoordinatorLayout</h4><p>CoordinatorLayout可以说是一个加强版的FrameLayout,其可以监听其所有子控件的各种事件，然后自动帮助我们做出最为合理的响应。 至于如何使用只需要将原来的FrameLayout 替换一下就可以了 。</p><h3 id="12-4卡片式布局"><a href="#12-4卡片式布局" class="headerlink" title="12.4卡片式布局"></a>12.4卡片式布局</h3><h4 id="12-4-1CardView"><a href="#12-4-1CardView" class="headerlink" title="12.4.1CardView"></a>12.4.1CardView</h4><p>添加依赖库：cardview、recyclelist、glide。Glide 是一个超级强大的图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF 图片、甚至是本地视频。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> //glide依赖implementation 'com.github.bumptech.glide:glide:4.13.2'annotationProcessor 'com.github.bumptech.glide:compiler:4.13.2'//recycler view 依赖implementation "androidx.recyclerview:recyclerview:1.2.1"// For control over item selection of both touch and mouse driven selectionimplementation "androidx.recyclerview:recyclerview-selection:1.1.0"//card view 依赖implementation "androidx.cardview:cardview:1.0.0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CardView是用于实现卡片式布局效果的重要控。其实也是一个 FrameLayout，只是额外提供了圆角和阴影等效果，看上去会有立体的感觉。通过 app:cardCornerRadius 属性指定卡片圆角的弧度，数值越大，圆角的弧度也越大。通过 app:elevation 属性指定卡片的高度， 高度值越大，投影范围也越大，但是投影效果越淡，高度值越小，投影范围也越小，但是投影效果越浓。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.cardview.widget.CardView</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>cardCornerRadius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.cardview.widget.CardView</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了能够充分利用屏幕的空间，运用一下第 3 章中学到的知识，使用 RecyclerView 来填充 MaterialTest项目的主界面部分。实现一个高配版的水果列表效果。  </p><p>在 CoordinatorLayout中添加了一个 RecyclerView，给它指定一个 id，然后将宽度和高度都设置为 match_parent，这样 RecyclerView 也就占满了整个布局的空间。  </p><p>新建一个Fruit类。Fruit 类中只有两个字段，name 表示水果的名字，imageId 表示水果对应图片的资源 id。  </p><p>需要为RecyclerView的子项指定一个自定义的布局，在 layout目录下新建fruit_item. xml。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.cardview.widget.CardView</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>cardCornerRadius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>        <span class="token attr-name">&lt;!--scaleType缩放模式--</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>            <span class="token attr-name"><span class="token namespace">android:</span>scaleType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>centerCrop<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.cardview.widget.CardView</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用CardView来作为子项的最外层布局，从而使得 RecyclerView 中的每个元素都是在卡片当中的。CardView 由于是一个 FrameLayout，因此它没有什么方便的定位方式，这里在 CardView 中再嵌套一个 LinearLayout，然后在 LinearLayout 中放置具体的内容。 内容是定义了一个 ImageView 用于显示水果的图片和 一个 TextView 用于显示水果的名称。在 ImageView 中使用了一个 scaleType 属性，这个属性可以指定图片的缩放模式。centerCrop 模式，它可以让图片保持原有比例填充满 ImageView，并将超出屏幕的部分裁剪掉。  </p><p>接下来为RecycleView准备适配器。具体实现去看第三章。这里将其中的两个方法展示一下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic FruitAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {    if (mContext == null) {         mContext = parent.getContext();     }     View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item,         parent, false);     return new ViewHolder(view);}@Overridepublic void onBindViewHolder(@NonNull FruitAdapter.ViewHolder holder, int position) {    Fruit fruit = mFruitList.get(position);    holder.fruitName.setText(fruit.getName());    Glide.with(mContext).load(fruit.getImageId()).into(holder.fruitImage);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 Glide.with()方法并传入一个 Context、Activity 或 Fragment 参数， 然后调用 load()方法去加载图片，可以是一个 URL 地址，也可以是一个本地路径，或者是一个 资源 id，最后调用 into()方法将图片设置到具体某一个 ImageView 中就可以了。  </p><h5 id="AppbarLayout"><a href="#AppbarLayout" class="headerlink" title="AppbarLayout"></a>AppbarLayout</h5><p>AppBarLayout 实际上是一个垂直方向的 LinearLayout，它在内部做了很多滚动事件的封装。运行上面的代码会出现RecycleList会将ToolBar覆盖住，这是因为FrameLayout会默认将子布局放置在左上角，解决办法是使用AppBarLayout。具体操作： 第一步将 Toolbar 嵌套到 AppBarLayout 中，第二步给 RecyclerView 指定一个布局行为。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.recyclerview.widget.RecyclerView</span> <span class="token attr-name"><span class="token namespace">app:</span>layout_behavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/appbar_scrolling_view_behavior<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了显式AppBarLayout的特性，我们在ToolBar中加入一个属性。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.appcompat.widget.Toolbar</span>  <span class="token attr-name"><span class="token namespace">app:</span>layout_scrollFlags</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scroll|enterAlways|snap<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>scroll 表示当 RecyclerView 向上滚动的时候，Toolbar 会 跟着一起向上滚动并实现隐藏；enterAlways 表示当 RecyclerView 向下滚动的时候，Toolbar 会 跟着一起向下滚动并重新显示。snap 表示当 Toolbar 还没有完全隐藏或显示的时候，会根据当前 滚动的距离，自动选择是隐藏还是显示。  </p><h3 id="12-5下拉刷新-SwipeRefreshLayout"><a href="#12-5下拉刷新-SwipeRefreshLayout" class="headerlink" title="12.5下拉刷新 SwipeRefreshLayout"></a>12.5下拉刷新 SwipeRefreshLayout</h3><p>在这个项目中支持下拉刷新的只有RecycleView，所以修改代码如下。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span><span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/swipe_refresh<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">app:</span>layout_behavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/appbar_scrolling_view_behavior<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.recyclerview.widget.RecyclerView</span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 RecyclerView 现在变成了 SwipeRefreshLayout 的子控件，因此之前使用 app:layout_behavior 声明的布局行为现在也要移到 SwipeRefreshLayout 中才行。  </p><h4 id="12-5-1MainActivity中使用下拉刷新"><a href="#12-5-1MainActivity中使用下拉刷新" class="headerlink" title="12.5.1MainActivity中使用下拉刷新"></a>12.5.1MainActivity中使用下拉刷新</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private SwipeRefreshLayout swipeRefreshLayout;swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);swipeRefreshLayout.setColorSchemeResources(R.color.design_default_color_primary);swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {    @Override    public void onRefresh() {        refreshFruits();    }});private void refreshFruits() {        new Thread(new Runnable() {            @Override            public void run() {                try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                //切回主线程                runOnUiThread(new Runnable() {                    @Override                    public void run() {                        initFruits();                        adapter.notifyDataSetChanged();                        swipeRefreshLayout.setRefreshing(false);                    }                });            }        }).start();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 findViewById()方法拿到 SwipeRefreshLayout 的实例，然后调用 setColorSchemeResources()方法来设置下拉刷新进度条的颜色。接着调用 setOnRefreshListener()方法来设置一个下拉刷新的监听器，当触发了下拉刷新操作的时候就会回调这个监听器的 onRefresh() 方法，然在这里去处理具体的刷新逻辑。 </p><p>通常情况下，onRefresh()方法中应该是去网络上请求最新的数据，然后再将这些数据展示出来。这里调用一个 refreshFruits()方法进行本地刷新操作。</p><p>refreshFruits()方法中先是开启了一个线程，然后将线程沉睡两秒钟。</p><p>沉睡结束之后，这里使用了 runOnUiThread()方法将线程切换回主线程，然后调用 initFruits()方法重新生成数据，</p><p>接着再调用 FruitAdapter 的 notifyDataSetChanged() 方法通知数据发生了变化。</p><p>最后调用 SwipeRefreshLayout 的 setRefreshing()方法并传入 false，用于表示刷新事件结束，并隐藏刷新进度条。  </p><h3 id="12-6可折叠式标题栏"><a href="#12-6可折叠式标题栏" class="headerlink" title="12.6可折叠式标题栏"></a>12.6可折叠式标题栏</h3><h4 id="12-6-1-CollapsingToolbarLayout"><a href="#12-6-1-CollapsingToolbarLayout" class="headerlink" title="12.6.1 CollapsingToolbarLayout"></a>12.6.1 CollapsingToolbarLayout</h4><p>CollapsingToolbarLayout 是一个作用于Toolbar 基础之上的布局。CollapsingToolbarLayout 可以让 Toolbar 的效果变得更加丰富。不过，CollapsingToolbarLayout不能独立存在，它在设计的时候就被限定只能作为  AppBarLayout 的直接子布局来使用。而 AppBarLayout 又必须是 CoordinatorLayout 的子布局。</p><p> 首先创建一个 FruitActivity，并将布局名指定成 activity_fruit.xml， 然后开始编写水果详情展示界面的布局。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">tools:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.FruitActivity<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.appbar.AppBarLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/appBar<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>250dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.appbar.CollapsingToolbarLayout</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/collapsing_toolbar<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@style/ThemeOverlay.AppCompat.Dark.ActionBar<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">app:</span>contentScrim</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/colorPrimary<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">app:</span>layout_scrollFlags</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scroll|exitUntilCollapsed<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>                <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/fruit_image_view<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>scaleType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>centerCrop<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">app:</span>layout_collapseMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parallax<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.appcompat.widget.Toolbar</span>                <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/toolbar<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/actionBarSize<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">app:</span>layout_collapseMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pin<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>com.google.android.material.appbar.CollapsingToolbarLayout</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>com.google.android.material.appbar.AppBarLayout</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.coordinatorlayout.widget.CoordinatorLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CollapsingToolbarLayout中android:theme 属性指定了一个 ThemeOverlay.AppCompat.Dark.ActionBar 的主题。</p><p>app:contentScrim 属性用于指定 CollapsingToolbarLayout 在趋于折叠状态以及折叠之后的背景色，其实 CollapsingToolbarLayout 在折叠之后就是一个普通的 Toolbar，那么背景色肯定应该是 colorPrimary 了，具体的效果我们待会儿就能看到。</p><p>app:layout_scrollFlags 属性我们也是见过的，只不过之前是给 Toolbar 指定的，现在也移到外面来了。其中，scroll 表示 CollapsingToolbarLayout 会随着水 果内容详情的滚动一起滚动，exitUntilCollapsed 表示当 CollapsingToolbarLayout 随着滚动完 成折叠之后就保留在界面上，不再移出屏幕。   </p><p> 定义一个 ImageView 和一个 Toolbar，这个高级版的标题栏将是由普通的标题栏加上图片组合而成的。</p><p>Toolbar中app:layout_collapseMode 用于指定当前控件在 CollapsingToolbarLayout 折叠过程中的折叠模式，其中 Toolbar 指定成 pin，表示在折叠的过程中位置始终保持不变，ImageView 指定成 parallax，表示会在折叠的过程中产生一定的错位偏移。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.core.widget.NestedScrollView</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_behavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/appbar_scrolling_view_behavior<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.cardview.widget.CardView</span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>35dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginBottom</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">app:</span>cardCornerRadius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>                    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/fruit_content_text<span class="token punctuation">"</span></span>                    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                    <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.cardview.widget.CardView</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.core.widget.NestedScrollView</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>水果内容详情的最外层布局使用NestedScrollView，注意它和AppBarLayout是平级的。 </p><p>ScrollView允许使用滚动的方式来查看屏幕以外的数据，而 NestedScrollView 在此基础之上还增加了嵌套响应滚动事件的功能。由于 CoordinatorLayout 本身已经可以响应滚动事件了，因此在它的内部就需要使用 NestedScrollView 或 RecyclerView 这样的布局。</p><p>app:layout_behavior 属性指定了一个布局行为，这和之前在 RecyclerView 中的用法是一模一样的。 不管是 ScrollView 还是 NestedScrollView，它们的内部都只允许存在一个直接子布局。因此， 如果我们想要在里面放入很多东西的话，通常都会先嵌套一个 LinearLayout，然后再在 LinearLayout 中放入具体的内容就可以了。</p><p>编写功能逻辑</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FruitActivity extends AppCompatActivity {    public static final String FRUIT_NAME = "fruit_name";    public static final String FRUIT_IMAGE_ID = "fruit_image_id";    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_fruit);        Intent intent = getIntent();        String fruitName = intent.getStringExtra(FRUIT_NAME);        int fruitImageId =  intent.getIntExtra(FRUIT_IMAGE_ID,0);        Toolbar toolbar = findViewById(R.id.toolbar);        CollapsingToolbarLayout collapsingToolbarLayout = findViewById(R.id.collapsing_toolbar);        ImageView fruitImageView = findViewById(R.id.fruit_image_view);        TextView fruitContentText = findViewById(R.id.fruit_content_text);        setSupportActionBar(toolbar);        ActionBar actionBar = getSupportActionBar();        if(actionBar != null){            actionBar.setDisplayHomeAsUpEnabled(true);        }        collapsingToolbarLayout.setTitle(fruitName);        Glide.with(this).load(fruitImageId).into(fruitImageView);        String fruitContent = generateFruitContent(fruitName);        fruitContentText.setText(fruitContent);    }    private String generateFruitContent(String fruitName) {        StringBuilder fruitContent = new StringBuilder();        for (int i = 0;i &lt; 500;i++){            fruitContent.append(fruitName);        }        return fruitContent.toString();    }    @Override    public boolean onOptionsItemSelected(@NonNull MenuItem item) {        switch (item.getItemId()){            case android.R.id.home:                finish();                return true;        }        return super.onOptionsItemSelected(item);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>onCreate()方法中，我们通过 Intent 获取到 传入的水果名和水果图片的资源 id，然后通过 findViewById()方法拿到刚才在布局文件中定义 的各个控件的实例。</p><p>接着就是使用了 Toolbar 的标准用法，将它作为 ActionBar 显示，并启用 HomeAsUp 按钮。</p><p>接这调用 CollapsingToolbarLayout 的 setTitle()方法将水果名设置成当前界面的标题，然后使用 Glide 加载传入的水果图片，并设置到标题栏的 ImageView 上面。</p><p>接着需要填充水果的内容详情，使用了一个 generateFruitContent()方法将水果名循环拼接 500 次，从而生成了一个比较长的字符串，将它设置到了 TextView 上面。</p><p> 最后，我们在 onOptionsItemSelected()方法中处理了 HomeAsUp 按钮的点击事件，当点击了这个按钮时，就调用 finish()方法关闭当前的活动，从而返回上一个活动。  </p><p>修改RecycleList中的点击事件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override    public FruitAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        if (mContext == null) {            mContext = parent.getContext();        }        View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item,                parent, false);        final ViewHolder holder = new ViewHolder(view);        holder.cardView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                int position = holder.getAdapterPosition();                Fruit fruit = mFruitList.get(position);                Intent intent = new Intent(mContext,FruitActivity.class);                intent.putExtra(FruitActivity.FRUIT_NAME,fruit.getName());                intent.putExtra(FruitActivity.FRUIT_IMAGE_ID,fruit.getImageId());                mContext.startActivity(intent);            }        });        return holder;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-6-2修改状态栏空间"><a href="#12-6-2修改状态栏空间" class="headerlink" title="12.6.2修改状态栏空间"></a>12.6.2修改状态栏空间</h4><p>将控件的 android:fitsSystemWindows 属性指定成 true，就表示该控件会出现在系统状态栏 里。需要ImageView 布局结构中的所有父布局都设置上这个属性。还必须在程序的主题中将状态栏颜色指定成透明色才行。在主题中将 android:statusBarColor 属性的值指定成@android:color/transparent。  </p><h2 id="Chap13-高级技巧"><a href="#Chap13-高级技巧" class="headerlink" title="Chap13-高级技巧"></a>Chap13-高级技巧</h2><h3 id="13-1全局使用Context"><a href="#13-1全局使用Context" class="headerlink" title="13.1全局使用Context"></a>13.1全局使用Context</h3><p>Android 提供了一个 Application 类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。我们可以定制一个自己的 Application 类，以便于管理程序内一些全局的状态信息，比如说全局 Context。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyApplication extends Application {    private static Context context;    @Override    public void onCreate() {        context = getApplicationContext();    }    public static Context getContext() {        return context;    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就可以通过getContext获得全局context了。</p><p>接下来需要告知系统，当程序启动的时候应该初始化 MyApplication 类，而不是默认的 Application 类。在 AndroidManifest.xml 文件的标签下进行指定 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span><span class="token punctuation">&gt;</span></span>  android:name="com.example.networktest.MyApplication"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-2使用Intent传递对象"><a href="#13-2使用Intent传递对象" class="headerlink" title="13.2使用Intent传递对象"></a>13.2使用Intent传递对象</h3><h4 id="13-2-1-Serializable-方式"><a href="#13-2-1-Serializable-方式" class="headerlink" title="13.2.1 Serializable 方式"></a>13.2.1 Serializable 方式</h4><p>Serializable 序列化，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。实现方式是让一个类去实现 Serializable 这个接口。  </p><p>在类中将属性的get、set构造完成后就可以通过Intent去使用了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//传入数据Person person = new Person();person.setName("Tom");person.setAge(20);Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra("person_data", person);startActivity(intent); //取数据Person person = (Person) getIntent().getSerializableExtra("person_data"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用 getSerializableExtra()方法来获取通过参数传递过来的序列化对象，接着再将它向下转型成 Person对象，这样就成功实现了使用 Intent 来传递对象的功能。</p><h4 id="13-2-2-Parcelable-方式"><a href="#13-2-2-Parcelable-方式" class="headerlink" title="13.2.2 Parcelable 方式"></a>13.2.2 Parcelable 方式</h4><p>Parcelable 方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是 Intent 所支持的数据类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Parcelable {    private String name;    private int age;    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(name); // 写出 name        dest.writeInt(age); // 写出 age    }    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.            Creator&lt;Person&gt;() {        @Override        public Person createFromParcel(Parcel source) {            Person person = new Person();            person.name = source.readString(); // 读取 name            person.age = source.readInt(); // 读取 age            return person;        }        @Override        public Person[] newArray(int size) {            return new Person[size];        }    };} //调用数据Person person = (Person) getIntent().getParcelableExtra("person_data");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先Person 类实现 Parcelable 接口，这样必须重写 describeContents()和 writeToParcel()。</p><p>describeContents()方法直接返回 0 。</p><p>writeToParcel()方法中需要调用 Parcel 的 writeXxx()方法，将 Person 类中的字段一一写出。注意，字符串型数据就调用 writeString()方法，整型数据就调用 writeInt()方法。</p><p>其次必须在 Person 类中提供一个名为 CREATOR 的常量，这里创建了 Parcelable.Creator 接口的一个实现，并将泛型指定为 Person。接着需要重写 createFromParcel()和 newArray()这两个方法。</p><p>createFromParcel()方法中我们要去读取刚才写出的 name 和 age 字段，并创建一个 Person 对象进行返回，其中 name 和 age 都是调用 Parcel 的 readXxx()方法读取到的，注意读取的顺序一要和刚才写出的顺序完全相同。</p><p>newArray()方法中的实现就简单多了，只需要 new 出一个 Person 数组，并使用方法中传入的 size 作为数组大小就可以了。 </p><p>接下来，在 FirstActivity 中我们使用相同的代码来传递 Person 对象，在 SecondActivity 中获取对象的时候需要稍加改动，这里不再是调用 getSerializableExtra()方法，而是调用 getParcelableExtra() 方法来获取传递过来的对象。</p><h3 id="13-3定制Log工具"><a href="#13-3定制Log工具" class="headerlink" title="13.3定制Log工具"></a>13.3定制Log工具</h3><p>新建一个 LogUtil 类 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LogUtil {    public static final int VERBOSE = 1;    public static final int DEBUG = 2;    public static final int INFO = 3;    public static final int WARN = 4;    public static final int ERROR = 5;    public static final int NOTHING = 6;    public static int level = VERBOSE;    public static void v(String tag, String msg) {        if (level &lt;= VERBOSE) {        Log.v(tag, msg);        }    }    public static void d(String tag, String msg) {        if (level &lt;= DEBUG) {        Log.d(tag, msg);        }    }    public static void i(String tag, String msg) {        if (level &lt;= INFO) {        Log.i(tag, msg);        }    }    public static void w(String tag, String msg) {        if (level &lt;= WARN) {        Log.w(tag, msg);        }    }    public static void e(String tag, String msg) {        if (level &lt;= ERROR) {        Log.e(tag, msg);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 获得日志类后打印一行 DEBUG 级别的日志就可以这样写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LogUtil.d("TAG", "debug log");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-4创建定时任务"><a href="#13-4创建定时任务" class="headerlink" title="13.4创建定时任务"></a>13.4创建定时任务</h3><h4 id="13-4-1Alarm机制"><a href="#13-4-1Alarm机制" class="headerlink" title="13.4.1Alarm机制"></a>13.4.1Alarm机制</h4><p>借助AlarmManager 类来实现。通过调用 Context 的 getSystemService()方法来获取实例的，需要传入的参数是 Context.ALARM_ SERVICE。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);//设置定时任务long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>set方法中第一个参数是一个整型参数，用于指定 AlarmManager 的工作 型，有4种值ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC和RTC_WAKEUP。ELAPSED_REALTIME 表示让定时任务的触发时间从系统开机开始算起，但不会唤醒 CPU。 ELAPSED_REALTIME_WAKEUP 同样表示触发时间从系统开机开始算起，但会唤醒 CPU。</p><p>RTC 表示让定时任务的触发时间从 1970 年 1 月 1 日 0 点开始算起，但不会唤醒 CPU。 RTC_WAKEUP 同样表示触发时间从 1970 年 1 月 1 日 0 点开始算起，但会唤醒 CPU。</p><p>使用 SystemClock.elapsedRealtime()方法可以获取到系统开机至今所经历时间的毫秒数 </p><p>使用 System.currentTimeMillis()方法可以获取到 1970年1月1日0点至今所经历时间的毫秒数。  </p><p>第二个参数，就是定时任务触发的时间，以毫秒为单位。 </p><p>如果第一个参数使用的是 ELAPSED_REALTIME 或 ELAPSED_REALTIME_WAKEUP，则这里传入开机至今的时间再加上延迟执行的时间。</p><p>如果第一个参数使用的是 RTC 或 RTC_WAKEUP，则这里传入 1970 年 1 月 1 日 0 点至今的时间再加上延迟执行的时间。</p><p> 第三个参数是一个 PendingIntent，这里一般会调用 getService()方法或者 getBroadcast()方法来获取一个能够执行服务或广播的 PendingIntent。这样当定时任务被触发的时候，服务的 onStartCommand()方法或广播接收器的onReceive()方法就可以得到执行。  </p><p>如果要实现一个长时间在后台定时运行的服务需要将触发定时任务的代码写到 onStartCommand()方法中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic int onStartCommand(Intent intent, int flags, int startId) {    new Thread(new Runnable() {    @Override    public void run() {        // 在这里执行具体的逻辑操作        }    }).start();    AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);    int anHour = 60 * 60 * 1000; // 这是一小时的毫秒数    long triggerAtTime = SystemClock.elapsedRealtime() + anHour;    Intent i = new Intent(this, LongRunningService.class);    PendingIntent pi = PendingIntent.getService(this, 0, i, 0);    manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);    return super.onStartCommand(intent, flags, startId);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Alarm 机制用法:先是获取到了 AlarmManager 的实例，然后定义任务的触发时间为一小时后，再使用 PendingIntent 指定处理定时任务 的服务为 LongRunningService，最后调用 set()方法完成设定。  </p></group></menu></uses-permission>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发-打点+界面优化</title>
      <link href="/2022/10/22/android-kai-fa-da-dian-jie-mian-you-hua/"/>
      <url>/2022/10/22/android-kai-fa-da-dian-jie-mian-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="1-打点任务"><a href="#1-打点任务" class="headerlink" title="1.打点任务"></a>1.打点任务</h2><p>打点就是在用户触发点击操作时，我们将一些特定信息保存下来，这样可以收集用户偏好设置。</p><p>这套实现的原理可以看做是建造者模式</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>建造者模式（Bulider Pattern）是将一个复杂对象的构建过程与它的实现表示分离，使得同样的构建过程可以创建不同的表示，属于创建型模式。使用创建者模式对于用户而言只需要制定需要建造的类就可以获得对象，建造过程及细节不需要了解。建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不一定固定。如果一个对象有非常复杂的内部结构（很多属性），可以将复杂对象的创建和使用进行分离。</p><p>所以具体实现是通过编写一个类继承SmartBaseInfo，SmartBaseInfo中我们定义一些需要记录的信息名称的Key，比如source、eventType等。我直接使用编好的SmartAddRemoveAppInfo类，在其中设置我们的setValue方法去保存数据。当需要传递时只需要创建SmartAddRemoveAppInfo对象调用setValue方法进行保存，接着直接调用SmartAddRemoveAppInfo.build()打点就结束了。</p><h3 id="1）大文件夹打点"><a href="#1）大文件夹打点" class="headerlink" title="1）大文件夹打点"></a>1）大文件夹打点</h3><p>打开应用时打点打开来源</p><p> 1.小文件夹内打开应用 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Folder”</p><p> 2.大文件夹内打开应用 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”BigFolder”</p><p> 3.桌面打开 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Workspace”</p><p> 4.hotseat打开 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Hotseat”</p><p>因为要判断点击App应用时的启动背景，每个App的图标都是一个BubbleTextView，在这个类中有属性可以进行直接判断启动背景，所以我们自定义一个方法returnClickSource()，在方法内通过类内定义的int类型的mDisplay去判断然后返回相应的value即可。在外部调用时需要进行强转，因为是在BubbleTextView中的静态方法，而外部只能用到view。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">((BubbleTextView) v).returnClickSource();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里hotseat需要判断单独的参数，如下。是通过LauncherSettings里的一个变量去判断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object tag = getParent() instanceof FolderIcon ? ((View) getParent()).getTag() : getTag();ItemInfo info = tag instanceof ItemInfo ? (ItemInfo) tag : null;if (info != null &amp;&amp; (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在取App包名的时候在工具类文件下新建了一个GetAppPackageName类，类内定义一个静态方法用来返回一个包名字符串类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GetAppPackageName {    public static String getAppProcessName(Context context) {        //当前应用pid        int pid = android.os.Process.myPid();        //任务管理类        ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);        //遍历所有应用        List&lt;ActivityManager.RunningAppProcessInfo&gt; infos = manager.getRunningAppProcesses();        for (ActivityManager.RunningAppProcessInfo info : infos) {            if (info.pid == pid)//得到当前应用                return info.processName;//返回包名        }        return "UNKNOWN";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 5.recent打开 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Recent”</p><p>recent其实就是上划后的界面。在这个界面里每一个app都是一个TaskView，直接在TaskView中找到OnClick点击事件在末尾处直接打点即可。</p><h3 id="2）打开文件夹"><a href="#2）打开文件夹" class="headerlink" title="2）打开文件夹"></a>2）打开文件夹</h3><p> 1.小文件夹打开文件夹 “eventType”:”openFolder”, “source”:”FolderIcon”</p><p> 2.大文件夹打开文件夹 “eventType”:”openFolder”, “source”:”BigFolder”</p><p>这是最简单的一个逻辑，直接在ItemOnClickHandler中找对应的文件夹点击事件触发的方法中直接打点即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//打开小文件夹打点，大文件夹类似SmartAddRemoveAppInfo.Builder smallFolder = new SmartAddRemoveAppInfo.Builder();smallFolder.setEventType(VALUE_OPEN_APP);smallFolder.setSource(VALUE_SOURCE_FOLDER_ICON);EdenSmartView.sendToSmartView(v.getContext(), smallFolder.build().buildEventParam    (EdenSmartView.createNew(SmartAddRemoveAppInfo.EVENT_ID_LAUNCHER)));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）切换文件夹"><a href="#3）切换文件夹" class="headerlink" title="3）切换文件夹"></a>3）切换文件夹</h3><p>切换文件夹是通过长按弹出一个pop框后选择“切换”的功能。</p><p>怎么找方法实现：首先选择“切换”需要长按，所以在ItemLongClickListener中找到长按逻辑的实现，发现会执行一个startDrag的方法，方法是在Workspace中定义的，且方法最后执行了beginDragShared，在beginDragShared中使用了PopupContainerWithArrow.showForIcon()方法，show中执行了populateAndShow()方法，populateAndShow()中调用了fillChildView()，在这个方法中可以找到inflateFolderPopup()，这里面就找到了切换和重命名的点击逻辑。切换文件夹的点击逻辑是在onClick()中实现的，所以打点直接卸载Click里就行，只需要判断是“大变小”还是“小变大”即可。</p><p> 1.小文件夹切换成大文件夹 “eventType”:”replaceFolder”, “source”:”FolderIcon”</p><p> 2.大文件夹切换成小文件夹 “eventType”:”replaceFolder”, “source”:”BigFolder”</p><h3 id="4）文件夹重命名"><a href="#4）文件夹重命名" class="headerlink" title="4）文件夹重命名"></a>4）文件夹重命名</h3><p>重命名的逻辑有点复杂，在onClick中会新建一个Folder，我们想要的是在编辑完成回退后取到Folder的名字，所以自定义打点方法并在里面进行判断oldTitle和newTitle是否相同，相同不打点，不相同进行打点，这个方法在回退动画执行之前执行。</p><p> 1.小文件夹重命名 “eventType”:”renameFolder”, “source”:”FolderIcon”, “extra:”新文件夹名称”</p><p> 2.大文件夹重命名 “eventType”:”renameFolder”, “source”:”BigFolder”, “extra:”新文件夹名称”</p><h2 id="2-Preference卡片风格设计"><a href="#2-Preference卡片风格设计" class="headerlink" title="2.Preference卡片风格设计"></a>2.Preference卡片风格设计</h2><h3 id="1）卡片风格"><a href="#1）卡片风格" class="headerlink" title="1）卡片风格"></a>1）卡片风格</h3><p>卡片风格的制作其实就是改变preference的background设计，我们需要重新设计一个drawable资源，因为preference的样式已经通过一个自定义的xml改变，我们只需要在自定义的layout中最外层通过background属性进行引用。</p><p>创建home_settings_preference_background.xml。这里定义了圆角和背景颜色两个属性。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/home_settings_preference_color<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@dimen/home_settings_preference_background_radius<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着需要在customise_preference_double.xml和customise_preference_single.xml中进行引用。</p><h3 id="2）实现点击变色效果"><a href="#2）实现点击变色效果" class="headerlink" title="2）实现点击变色效果"></a>2）实现点击变色效果</h3><p>最开始是发现系统会引用一个item_background.xml，里面定义了一个区域在按下、获得焦点、选中不同状态时所使用的drawable。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_window_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/transparent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>state_enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_disabled<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>state_enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>                              <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_disabled<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>                                <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_transition<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>                               <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_transition<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>                                                             <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_focused<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/transparent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="android-state-pressed"><a href="#android-state-pressed" class="headerlink" title="android:state_pressed"></a>android:state_pressed</h4><p>是当控件被按下的时候控件的表示，可以实现按下按钮时，按钮变成领一个模样，松开之后又恢复原样。</p><h4 id="android-state-focused"><a href="#android-state-focused" class="headerlink" title="android:state_focused"></a>android:state_focused</h4><p>是当控件获得焦点的时候控件的表示。</p><h4 id="android-state-selected"><a href="#android-state-selected" class="headerlink" title="android:state_selected"></a>android:state_selected</h4><p>选中时控件的表示。</p><p>selected和focused的区别：focused是指获取焦点，早期某些设备存在方向键盘可以用来移动焦点，而pressed仅仅是指按下状态。然后selected容易和focused混淆。一个界面只允许有一个控件处在focus状态，却可以有多个处于Selected状态，可以调用View.setSelected设置选中。</p><p>我在这里只设置了两种：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>      <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/home_settings_pressed<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>                                  <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/home_settings_normal<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样就实现了在点击后，会使用不同的drawable会发生颜色变化，但问题就是没有了点击颜色动画，非常生硬，所以使用下面的方法。</p><h3 id="3）点击动画水波纹效果"><a href="#3）点击动画水波纹效果" class="headerlink" title="3）点击动画水波纹效果"></a>3）点击动画水波纹效果</h3><p>新建一个drawable资源，使用ripple标签制作点击动画，我们需要在其中定义两个item，和一个color。第一个color是点击后的颜色，item第一个是我们需要在这个drawable里产生动画，第二个表示动画的区域。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ripple</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/home_settings_preference_pressed_color<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/home_settings_preference_background<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@android:id/mask<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@android:color/white<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@dimen/home_settings_preference_background_radius<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ripple</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）深色模式和白日模式颜色改变"><a href="#4）深色模式和白日模式颜色改变" class="headerlink" title="4）深色模式和白日模式颜色改变"></a>4）深色模式和白日模式颜色改变</h3><p>两种方式</p><h4 id="1-分别在对应的文件夹下创建同名的color。"><a href="#1-分别在对应的文件夹下创建同名的color。" class="headerlink" title="1.分别在对应的文件夹下创建同名的color。"></a>1.分别在对应的文件夹下创建同名的color。</h4><p><img src="01.png"></p><p><img src="02.png"></p><p>在这两个文件夹下的color中创建同名的color，home_settings_preference_color。</p><h4 id="2-新建一个attr值，类型为color。"><a href="#2-新建一个attr值，类型为color。" class="headerlink" title="2.新建一个attr值，类型为color。"></a>2.新建一个attr值，类型为color。</h4><p>新建attr后，在values文件下的styles中添加light和dark的颜色，具体位置如下：</p><style name="LauncherTheme" parent="@style/BaseLauncherTheme"><style name="LauncherTheme.Dark" parent="@style/LauncherTheme">这样系统在切换主题是会使用对应的color。### 5）设计向右箭头我把箭头设计成了一个widget，而这个widget中只不过是提供了一个图片，使用image属性rotation将图片旋转后使用。### 6）删除pref和修改版本位置在添加pref时直接返回false。将Wiko Version放在了整个页面的下面，就是FrameLayout里，用一个LinearLayout将两行文字包住，之后调整LinearLayout的位置和TextView的位置就可以了。## 3.修改OnClickListener的匿名函数INSTANCE在不知道点击onClick()方法来源的时候，需要添加一个source参数，并且修改lamada函数的写法。修改前：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static final OnClickListener INSTANCE &#x3D; ItemClickHandler::onClick;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>修改后：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static final OnClickListener INSTANCE(String source) &#123;    return new MyOnClickListener(source);&#125;public static class MyOnClickListener implements OnClickListener &#123;    private String source;        public MyOnClickListener(String source) &#123;        this.source &#x3D; source;    &#125;        @Override    public void onClick(View v) &#123;        ItemClickHandler.onClick(v, source);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></style>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发-添加大文件弹窗</title>
      <link href="/2022/10/22/android-kai-fa-tian-jia-da-wen-jian-dan-chuang/"/>
      <url>/2022/10/22/android-kai-fa-tian-jia-da-wen-jian-dan-chuang/</url>
      
        <content type="html"><![CDATA[<p><img src="01.jpeg"></p><h2 id="1-将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。"><a href="#1-将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。" class="headerlink" title="1.将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。"></a>1.将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。</h2><p>最后方案使用自定义Dialog实现弹窗，自定义了一个xml。外层为linearlayout，包含一个imageview,</p><p>3个textview，文字和图片都是居中显式，高宽根据文字内容决定。</p><p>处理最后一个textview的点击事件，使用类内接口，在调用时传入接口参数判断点击事件，调用AgreeClick()方法。</p><p>用到Window对象设置弹窗大小、位置、动画。通过getWindow()获得Window对象，后set各种属性。新建一个drawable.xml，在里面设置Window的弧度。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">window.setGravity(Gravity.BOTTOM);//弹窗位置window.setBackgroundDrawableResource(R.drawable.large_file_folder_dialog_shape);//弹窗背景window.setWindowAnimations(R.style.large_folder_dialog);//弹窗动画window.setDimAmount(0f);//全透明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了设置Dialog窗口大小和布局，使用Resources中的getDisplayMetrics()方法获得DisplayMetrics类对象，通过其中的.widthPixels()和.heightPixels()得到手机的宽和高。</p><p>通过WindowManager.LayoutParams创建一个params对象，通过.attr设置window的宽高和相对位置，最后一定要调用window的.setAttributes(params)将参数传递进去才能有效果。</p><p>窗口底边高度要配合导航栏高度。直接把mInitY传给window的高度就行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Launcher launcher = Launcher.fromContext(context);if (launcher != null &amp;&amp; launcher.getDeviceProfile() != null){    mInitY = launcher.getDeviceProfile().getInsets().bottom;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后定义一个静态方法show用来给外部类提供方法，方法内部新建一个自定义的dialog并监听点击事件，调用.dissmiss()来消除dialog。</p><h2 id="2-弹窗绘制好后实现逻辑，触发的四种逻辑。"><a href="#2-弹窗绘制好后实现逻辑，触发的四种逻辑。" class="headerlink" title="2.弹窗绘制好后实现逻辑，触发的四种逻辑。"></a>2.弹窗绘制好后实现逻辑，触发的四种逻辑。</h2><h3 id="1：首次长按文件夹（大-小）。"><a href="#1：首次长按文件夹（大-小）。" class="headerlink" title="1：首次长按文件夹（大/小）。"></a>1：首次长按文件夹（大/小）。</h3><p>ItemLongClickListener类下的onWorkspaceItemLongClick()添加逻辑。因为所有Item的长按逻辑都在这个方法里实现，所以需要进行判断。通过view.getTag()判断是文件夹还是app快捷方式。判断完成后在进行show的调用。</p><h3 id="2：首次点击文件夹（大-小）。"><a href="#2：首次点击文件夹（大-小）。" class="headerlink" title="2：首次点击文件夹（大/小）。"></a>2：首次点击文件夹（大/小）。</h3><p>ItemClickHandler类下的onClickFolderIcon()和onClickBigFolderIcon()中添加逻辑。根据SharedPreference保存的数据判断NewLargeFolderDialog.show()的调用。</p><h3 id="3：首次合并应用形成文件夹。"><a href="#3：首次合并应用形成文件夹。" class="headerlink" title="3：首次合并应用形成文件夹。"></a>3：首次合并应用形成文件夹。</h3><p>合并生成文件夹的逻辑是在Workspace.java下的createUserFolderIfNecessary()方法里实现，只需要在方法return之前调用show()方法就行。</p><h3 id="4：首次拖动应用进入文件夹）"><a href="#4：首次拖动应用进入文件夹）" class="headerlink" title="4：首次拖动应用进入文件夹）"></a>4：首次拖动应用进入文件夹）</h3><p>合并生成文件夹的逻辑是在Workspace.java下的addToExistingFolderIfNecessary()方法里实现，和第三条同理。</p><h2 id="3-设置sharedPreference，保存是否是第一次操作的参数，bool类型。"><a href="#3-设置sharedPreference，保存是否是第一次操作的参数，bool类型。" class="headerlink" title="3.设置sharedPreference，保存是否是第一次操作的参数，bool类型。"></a>3.设置sharedPreference，保存是否是第一次操作的参数，bool类型。</h2><p>因为要实现第一次点击之后就不需要弹出Dialog，需要一个数据进行判断，SharedPreference保存的数据会存在一个文件下，launcher中在Utilities中定义了一个getPref(Context context)方法，返回的就是一个SharedPreference对象，只需要在调用时传入context就好。</p><p>存入数据的逻辑是在show()方法中的监听点击事件里定义，在点击“知道了”以后put一个bool类型的值然后apply，接着走dissmiss()，这样只要走过四种逻辑中的任意一个，就会写入值。写入需要使用SharedPreferences.Editor对象编写。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SharedPreferences.Editor mUserAgreeSharedPref = Utilities.getPrefs(context).edit();mUserAgreeSharedPref.putBoolean("first_new_large_folder_dialog_notification", false);mUserAgreeSharedPref.apply();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>取出数据是在判断四种逻辑时调用即可，直接通过SharedPreferences对象调用get方法取出数据进行判断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean first_notification = Utilities.getPrefs(v.getContext()).getBoolean("first_new_large_folder_dialog_notification", true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除sharedpreference中特定的key</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mUserAgreeSharedPref.remove("first_new_large_folder_dialog_notification").commit();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-LottieAnimationView的使用"><a href="#4-LottieAnimationView的使用" class="headerlink" title="4.LottieAnimationView的使用"></a>4.LottieAnimationView的使用</h2><p>首先需要加入配置文件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//Lottie动画implementation "com.airbnb.android:lottie:3.6.0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在需要放置动画的xml中放置Lottie</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;com.airbnb.lottie.LottieAnimationView        android:id="@+id/new_large_file_dialog_lottie"        android:layout_width="match_parent"        android:layout_height="wrap_content"        app:lottie_autoPlay="true"        app:lottie_loop="true"        app:lottie_fileName="data.json" //JSON文件需要放在 src/main/asset中        app:lottie_rawRes="@raw/animation" //JSON文件需要放置在 src/main/res/raw中与上面二选一即可/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着在Java文件中配置Lottie,其中新建LottieAnimationView对象通过R.id找到对应的law，可以设置是否自动播放，是否循环播放等。最后直接play即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private LottieAnimationView mLottieAnimationView;//Lottie AnimationViewmLottieAnimationView = (LottieAnimationView) findViewById(R.id.new_large_file_dialog_lottie);mLottieAnimationView.setImageAssetsFolder("data.json");//配置JSONmLottieAnimationView.loop(true);//循环播放////设置X轴方向上的缩放比例，0f为不可见，1f原始大小 Ps.原setScale方法在2.0.0版本后已弃用//mLottieAnimationView.setScaleX(0.5f);////设置Y轴方向上的缩放比例//mLottieAnimationView.setScaleY(0.5f);mLottieAnimationView.playAnimation();//播放动画<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了防止内存泄漏，应该在动画不需要播放的时候释放Lottie动画。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mLottieAnimationView.setImageAssetsFolder(null);//传一个null，防止动画在后台继续播放<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发-修改Preference</title>
      <link href="/2022/10/19/android-kai-fa-xiu-gai-preference/"/>
      <url>/2022/10/19/android-kai-fa-xiu-gai-preference/</url>
      
        <content type="html"><![CDATA[<p>记录一下从事Android开发两个月以来学到的东西，虽然以后可能不会从事相关工作，还是纪念一下吧。</p><h1 id="主屏幕设置页面样式"><a href="#主屏幕设置页面样式" class="headerlink" title="主屏幕设置页面样式"></a>主屏幕设置页面样式</h1><h2 id="1-Preference样式修改"><a href="#1-Preference样式修改" class="headerlink" title="1.Preference样式修改"></a>1.Preference样式修改</h2><p>首先需要理解Preference是如何构成的。分析一下preference.xml可知每个item主要有三部分，如下：</p><p><img src="Android1-1.png"></p><p>第一部分为图标区域，第二部分是title和summary区域，第三部分是其他控件区域。</p><p>了解了其大体结构，就可以根据需求进行修改了。</p><p>图标区域没有所以设置为invisibility。中间使用了两个layout来区分，一个是有summary一个没有。</p><p>只有Title的layout里设置字体颜色、居中、margin等。有Summary的需要调整summary的位置和文字大小。</p><h2 id="2-按钮样式修改"><a href="#2-按钮样式修改" class="headerlink" title="2.按钮样式修改"></a>2.按钮样式修改</h2><p>修改了“Google左屏”类型为SwitchPreference的选择开关样式。</p><p>通过引用另一个widgetout来实现样式的更改。</p><p>创建customise_switchpreference.xml，定义一个<switch>控件，在其中配置thumb和track</switch></p><p>Switch有两个重要的属性：thumb和track，thumb是Switch中间圆，track是Switch底部长条。</p><h3 id="1-1thumb"><a href="#1-1thumb" class="headerlink" title="1.1thumb"></a>1.1thumb</h3><p>因为是通过<shape>方式实现的所以thumb和track的定义在drawble文件夹下。</shape></p><p>新建thumb文件，通过item引用来设置开和关的不同效果。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_thumb_open<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_thumb_close<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>customise_sp_thumb_open.xml中可以配置半径、背景色、边界背景色等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--设置圆的半径--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--设置圆空心部分的背景色 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#FFFFFF<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--    &amp;lt;!&amp;ndash;设置圆边的背景色&amp;ndash;&amp;gt;--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stroke</span>        <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#001AFF<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拿到settings里的thumb"><a href="#拿到settings里的thumb" class="headerlink" title="拿到settings里的thumb"></a>拿到settings里的thumb</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layer-list</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>top</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>left</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>right</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>bottom</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>oval<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/settingslib_switch_thumb_color<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layer-list</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>layer-list 是用来创建 LayerDrawable 的，LayerDrawable 是 DrawableResource 的一种，layer-list创建出来也就是一个drawable 图形。layer-list 的大致原理类似 RelativeLayout，是一层层的叠加 ，后添加的会覆盖先添加的。在 layer-list 中可以通过控制后添加图层距离最底部图层的左上右下的四个边距等属性，得到不同的显示效果。</p><p>layer-list中的item是按照顺序从下往上叠加的，即先定义的item在下面，后面的依次往上面叠放</p><h3 id="1-2track"><a href="#1-2track" class="headerlink" title="1.2track"></a>1.2track</h3><p>和thumb一样，在drawable文件夹下新建track.xml总文件，通过item重新配置开和关的样式。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_track_open<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_track_close<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--设置圆角矩形的高--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>56dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--设置圆角矩形的圆角半径--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>40dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#001AFF<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--    &amp;lt;!&amp;ndash;设置圆边的背景色&amp;ndash;&amp;gt;--&gt;</span><span class="token comment">&lt;!--    &lt;stroke--&gt;</span><span class="token comment">&lt;!--        android:width="1dp"--&gt;</span><span class="token comment">&lt;!--        android:color="#001AFF"/&gt;--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拿到settings里的track"><a href="#拿到settings里的track" class="headerlink" title="拿到settings里的track"></a>拿到settings里的track</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>52dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/settingslib_switch_track_color<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>35dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>（光晕效果通过在<switch>控件中加入：“</switch></strong></em><em><strong>android</strong></em><em><strong>:background</strong></em>***=”@null”***<em><strong>”来取消光晕效果）</strong></em></p><h2 id="3-在设置界面加入入口"><a href="#3-在设置界面加入入口" class="headerlink" title="3.在设置界面加入入口"></a>3.在设置界面加入入口</h2><p>我们需要了解<meta-data>标签</meta-data></p><p>直译为“元数据”，该标签可为<activity>、<application>、<receiver>、<service>等组件提供附加数据项。<br>组件元素可以包含任意数量的<meta-data>子元素。系统将meta-data配置的数据存储于一个Bundle对象中，可以通过PackageItemInfo.metaData字段获取。</meta-data></service></receiver></application></activity></p><ul><li>android:name</li></ul><p>分配给该标签的键，即唯一名称。为确保名称唯一应使用Java风格命名约定</p><ul><li>android:resource</li></ul><p>对资源的引用，如“@string/app_name”。该资源ID可以通过该metaData.getInt()方法获取 。</p><ul><li>android:value</li></ul><p>分配给该标签的值，如String、Boolean等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.action.EXTRA_SETTINGS<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.order<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-2<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.category<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.category.ia.homepage<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.summary<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/summary_empty<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.icon<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/ic_setting<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>com.android.settings.action.EXTRA_SETTINGS 设置遍历所有应用解析标记</p><p>com.android.settings.category.ia.homepage 在设置主界面显示</p><p>com.android.settings.icon 显示图标</p><p>com.android.settings.summary 显示子标题文字</p><p>com.android.settings.order 设置主界面排序，网络和互联网默认-120，只要大于即可排到第一</p><p>上述语句完成入口的加入配置icon等信息。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2022/10/17/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2022/10/17/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h2><p>Node.js官方网站：<a href="https://nodejs.org/">https://nodejs.org</a> 选择对应的系统点击安装。<br>sudo su #切换到管理员<br>node -v #查看node版本<br>npm -v #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本</p><hr><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h2><p>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本</p><h2 id="3-建立博客"><a href="#3-建立博客" class="headerlink" title="3.建立博客"></a>3.建立博客</h2><p>mkdir blog    #创建一个目录，博客所有文件都在这里<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建一篇新的文章，新文章在source/_posts/下，可以使用vim命令便携，支持MarkDown</p><hr><h2 id="4-部署到Github上"><a href="#4-部署到Github上" class="headerlink" title="4.部署到Github上"></a>4.部署到Github上</h2><p>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件<br>然后在个人github上创建一个远程仓库，<em>注意：远程仓库名称：“githubname.io”，前缀必须和你github的名字一样，不然会访问不到（404）。</em><br>接着配置根目录下的_config.yml文件，找到deploy：</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将repo替换为你自己的仓库链接。<strong>这里也可以使用ssh链接。</strong><br>#在blog路径下<br>hexo clean &amp;&amp; hero g #清理+生成（generate）<br>hexo d #部署到远程仓库。<em>注意：如果出现Fatal，可能是因为代理导致，先关掉。或者是配置一下git的ssh密钥。</em><br>这时就可以通过：<a href="https://yourgithubname.github.io/">https://YourGithubName.github.io</a> 访问你的博客。</p><hr><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo博客主题在themes文件夹下，可以在GitHub上挑选自己喜欢的主题并下载，这里推荐5种主题。</p><ol><li>Sakura 非常炫，缺点加载慢 <a href="https://github.com/honjun/hexo-theme-sakura">https://github.com/honjun/hexo-theme-sakura</a></li><li>Matery 预加载，强推 <a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></li><li>3-hexo 三段式，适合博文多的 <a href="https://github.com/yelog/hexo-theme-3-hexo">https://github.com/yelog/hexo-theme-3-hexo</a></li><li>butterfly 也是个好看的 <a href="https://github.com/jerryc127/hexo-theme-butterfly/tree/dev">https://github.com/jerryc127/hexo-theme-butterfly/tree/dev</a></li><li>Next 功能集成多，简洁 <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></li></ol><p>选好主题之后cd到themes文件夹下，通过 git clone 下载主题代码。<br>修改根目录下的_config.yml 文件 ： theme: sakura。<br>接着运行 hexo clean &amp;&amp; hero g 和 hexo d。耐心等待一段时间再刷新网站。</p><p>这样Hexo快速布置个人博客就结束了，后续想更改主题的细节可以在主题中的_config.yml中进行修改。<br>学习路漫长，诸君一起努力。</p><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><h3 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h3><p>这里博主使用的是Typora便携MarkDown，在添加图片之前需要更改一下设置。<br>打开typora，选择：<code>偏好设置 - 图像 - 插入图片时</code>，做如下更改：</p><ol><li>复制到指定路径 </li><li>./${filename}</li></ol><p>当插入图片时，会生成一个和文件名相同的文件夹，并将图片存入这个文件夹内。</p><h3 id="Hexo设置"><a href="#Hexo设置" class="headerlink" title="Hexo设置"></a>Hexo设置</h3><ol><li><p>安装 hexo-renderer-marked</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-renderer-marked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在blog根目录下的_config.yml修改配置：post_asset_folder: true。</p></li><li><p>安装插件hex-image-link</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-image-link --saveNOTE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><p>假设文件名: ./test.md</p><p>图片路径: ./test/image.jpg</p><p>当插入图片 image.jpg 到 test.md 中时，<br>typora 的引用路径为</p><pre class="line-numbers language-none"><code class="language-none">![](test/image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Hexo 发布后的引用路径为</p><pre class="line-numbers language-none"><code class="language-none">![](image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，typora的md文件引入hexo时，应转换路径。即删掉图片路径中的 “test/“部分；（此时md文件已不能正常显示图片，而 hexo server 可正常显示)</p><p>插件hexo-image-link帮助实现了这种路径转换。<br>安装后，typora 文件中正常显示的图片，在hexo发布后依旧能正常显示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
