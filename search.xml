<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM思维导图</title>
      <link href="/2022/11/08/jvm-si-wei-dao-tu/"/>
      <url>/2022/11/08/jvm-si-wei-dao-tu/</url>
      
        <content type="html"><![CDATA[<p>JVM理解起来不是很难，就是一个放在任何系统上都能运行的虚拟机，主要任务是编译和运行java项目，主要的JVM调优还是需要花时间去琢磨的，这里只把面经里长问的一些问题拿了出来，细节有待研究。</p><p><img src="JVM.png" alt="JVM"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端面试</title>
      <link href="/2022/11/06/hou-duan-mian-shi/"/>
      <url>/2022/11/06/hou-duan-mian-shi/</url>
      
        <content type="html"><![CDATA[<p>把最近看的后端面试题进行整理。天道好轮回，感觉这些已经学了n遍了还要看:(</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI七层协议，五层协议和每层中常见的协议"><a href="#OSI七层协议，五层协议和每层中常见的协议" class="headerlink" title="OSI七层协议，五层协议和每层中常见的协议"></a>OSI七层协议，五层协议和每层中常见的协议</h3><p>七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br>五层：物理层、数据链路层、网络层、传输层、应用层</p><ul><li>应用层：HTTP（超文本传输协议）、FTP（文件传输协议）、DNS（域名解析协议）</li><li>传输层：TCP（传输控制协议）、UDP（用户数据协议）。</li><li>网络层：IP（互联网协议/数据包协议）、ICMP（网际报文控制协议）、RIP（路由信息协议）。单位：数据包</li><li>链路层：ARP（地址解析协议）。单位：帧</li><li>物理层：IEEE。单位：比特</li></ul><p><strong>ARP协议：</strong><br>ip地址转化为mac地址的一种协议，一般有路由器中会缓存一张ARP表，这个表会映射IP和MAC地址。从而达到搜索地址的方式，如果表中没有对应的映射，就会发送一个ARP 广播，询问ip对应的mac地址是什么。</p><p><strong>TCP协议：</strong><br>传输控制协议，是一个面向连接的传输协议，他是一个能提供高可靠性的通信协议，所谓高可靠性指的是数据无丢失、数据无误、数据无失序、数据无重到达。</p><p><strong>UDP协议：</strong><br>用户数据报协议，是一种不可靠无连接、实时性高的协议，在数据发送前，不需要提前建立连接，所以可以更高效地传输数据。但可靠性无法保证。</p><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><p><strong>三次握手</strong></p><p>客户端–发送带有 SYN = 1，seq=x 的数据包–一次握手–服务端</p><p>服务端–发送带有 SYN = 1，ACK = 1，seq = y，ack = x  + 1 的数据包–二次握手–客户端</p><p>客户端–发送带有带有 ACK = 1，seq = x + 1， ack = y + 1 的数据包–三次握手–服务端</p><ol><li><code>SYN</code>，同步序列编号；</li><li><code>seq=y</code>，服务端的序列号为y；</li><li><code>ACK=1</code>，表示确认客户端序列号有效，此时确认号（ack）有值；</li><li><code>ack=seq+1</code>：ack的值为客户端传来的序列号（seq）加1，即ack=x+1；</li></ol><p><img src="1.png"></p><p>三次握手的目的是建立可靠的通信信道，三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常，第二次握手：Client 确认了自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常，第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认 了：自己发送、接收正常，对方发送、接收正。 所以三次握手就能确认双发收发功能都正常，缺一不可。</p><p><strong>第二次回传为什么要带SYN？</strong></p><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。</p><p><strong>为什么要四次挥手</strong></p><p>TCP是全双工的工作模式，因此<strong>每个方向都必须单独进行关闭</strong>。当一方完成自己的数据发送任务后，就可以发送一个FIN报文来终止这个方向的连接。刚开始客户端和服务器端都处于ESTABLISHED状态，假如客户端发起关闭请求；</p><ol><li>第一次挥手：客户端向服务器发送FIN报文（FIN=1,seq=u），发完后进入FIN_WAIT_1状态，即主动关闭TCP连接，不再发送数据，但可以接收服务器发来的报文，等待服务器回复；</li><li>第二次挥手：服务器接到FIN报文后，返回一个ACK报文（ACK=1,ack=u+1,seq=v），表明自己接收到此报文，服务器进入CLOSE_WAIT关闭等待状态，此时客户端就知道服务端接到自己的断开连接请求，进入到FIN_WAIT_2状态，TCP处于半关闭状态，但服务器端可能还有数据要传输。</li><li>第三次挥手：服务器关闭客户端连接，发送FIN报文（FIN=1，seq=w,ack=u+1）给客户端，此时服务器处于LAST_ACK状态，等待客户端回应。</li><li>第四次挥手：客户端收到FIN报文后，发送一个ACK（ACK=1,ack=w+1,seq=u+1）给服务器作为应答，此时客户端处于TIME_WAIT状态，这个状态是为了等待足够的时间以确保TCP接收到连接中断请求的确认。</li></ol><p><strong>等待2MSL的原因</strong></p><p>MSL表示报文的最大生命周期。等待的原因是防⽌客户端最后⼀次发给服务器的确认在⽹络中丢失以⾄于客户端关闭，⽽服务端并未关闭，导致资源的浪费。还可以让本次连接的所有的⽹络包在链路上消失，以防造成不必要的⼲扰。</p><p><strong>TCP如何保证可靠连接</strong></p><ol><li>tcp建立连接会经过三次握手，确保连接建立。    </li><li>tcp断开连接也会经历四次挥手，保证连接释放，保障旧连接不会影响新连接。    </li><li>tcp中每个报文都有序列，保证消息最后是有序，且提供对丢失消息的重试机制。    </li><li>tcp报文会有些校验机制，比如校验和， TCP 将保持它首部和数据的检验和，目的是检测数据在传输过程中的任何变化。</li><li> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送其缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</li><li>拥塞控制，网络拥挤时减少发送量。主要算法：慢开始 、 拥塞避免 、快重传和快恢复。</li><li>ARQ协议（自动重传请求），基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li>超时重传， 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h3 id="从输入URL到页面加载发生了什么"><a href="#从输入URL到页面加载发生了什么" class="headerlink" title="从输入URL到页面加载发生了什么"></a>从输入URL到页面加载发生了什么</h3><p>总体来说分为以下几个过程:</p><ol><li>DNS解析。寻找哪台机器上有你需要资源的过程。使用DNS缓存一级一级向上查找。</li><li>TCP连接。</li><li>发送HTTP请求。浏览器向服务器发送请求，cookies会随着请求一起发送。</li><li>服务器处理请求并返回HTTP报文。</li><li>浏览器解析渲染页面。</li><li>连接结束。</li></ol><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><img src="2.png" alt="2"></p><h3 id="Cookie和Session的作用和区别"><a href="#Cookie和Session的作用和区别" class="headerlink" title="Cookie和Session的作用和区别"></a>Cookie和Session的作用和区别</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 </p><p>Cookie 一般用来保存用户信息比如：①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。</p><p>Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 </p><p>区别：Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。 相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 </p><p>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。<strong>MySQL</strong> 是一种关系型数据库，主要用于持久化存储系统中的一些数据比如用户信息。端口号是3306。</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySQL有两种存储引擎，一个是MyISAM另一个是InnoDB，因为InnoDB支持事务所以现在默认的存储引擎是它，其之间的差别如下：</p><ul><li>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li><li>MyISAM 不提供事务支持。InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</li><li>MyISAM 不支持外键，而 InnoDB 支持外键。</li><li>MyISAM 不支持崩溃后安全修复，而 InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。 </li></ul><p><strong>InnoDB如何保持ACID？</strong></p><p>InnoDB 引擎使用 <strong>redo log(<strong>重做日志</strong>)</strong> 保证事务的持久性，使用 <strong>undo log(<strong>回滚日志</strong>)</strong> 来保证事务的原子性。通过锁机制、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong>REPEATABLE-READ</strong> ）。保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p><h3 id="锁机制和InnoDB锁算法"><a href="#锁机制和InnoDB锁算法" class="headerlink" title="锁机制和InnoDB锁算法"></a>锁机制和InnoDB锁算法</h3><p><strong>表级所和行级锁对比</strong></p><ul><li>表级锁： MySQL中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li>行级锁： MySQL 中锁定粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p><strong>三种锁算法</strong></p><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap临键锁，锁定一个范围，包含记录本身</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。 数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。</p><p><strong>ACID</strong></p><ol><li>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性：执行事务前后，数据保持一致；</li><li>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p><strong>并发事务带来的问题</strong></p><ol><li>脏读：简单来说就是一个事务对某数据进行了修改但是未提交，而另一个事务对此数据进行了访问并使用。相当于读到了“脏数据“</li><li>丢失修改：事务A对数据访问时事务B也访问了此数据，而在A对数据进行修改时B也进行了修改，造成了事务A修改操作的丢失。</li><li>不可重复读：在一个事务中多次访问一个数据，而在其访问过程中另一个事务也进行了访问并且修改，造成了第一个事务两次访问数据不一样，即同一个事务两次访问数据不同。</li><li>幻读：类似3，就是事务A在读取了几行数据，这是事务B对数据进行了插入，这时A再读时发现了几条陌生数据，多了不存在的数据称幻读。</li></ol><p><strong>事务隔离级别</strong></p><ol><li><strong>读取未提交</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>读取已提交</strong>： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>可重复读</strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>可串行化</strong>： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 </li></ol><p>InnoDB默认使用的隔离级别时可重复读，其不会有任何性能损失。</p><h3 id="MySQl索引"><a href="#MySQl索引" class="headerlink" title="MySQl索引"></a>MySQl索引</h3><p>索引是一个单独的、存储在磁盘上的数据库结构，包含着对数据表里所有记录的引用指针。其实现在存储引擎中，InnoDB / MyISAM 只支持 BTree 索引。</p><p><strong>优点</strong></p><ol><li>提高数据的查询的效率（类似于书的目录）</li><li>可以保证数据库表中每一行数据的唯一性（唯一索引）</li><li>减少分组和排序的时间（使用分组和排序子句进行数据查询），被索引的列会自动进行分组和排序</li></ol><p><strong>缺点</strong></p><ol><li>占用磁盘空间</li><li>降低更新表的效率</li></ol><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ol><li>普通索引和唯一索引</li></ol><ul><li>普通索引：MySQL 中的基本索引类型，允许在定义索引的列中插入重复值和空值</li><li>唯一索引：要求索引列的值必须唯一，但允许有空值<ul><li>如果是组合索引，则列值的组合必须唯一</li><li>主键索引是一种特殊的唯一索引，不允许有空值</li></ul></li></ul><ol start="2"><li>单列索引和组合索引</li></ol><ul><li>单列索引：一个索引只包含单个列，一个表可以有多个单列索引</li><li>组合索引：在表的多个字段组合上创建的索引<ul><li>只有在查询条件中使用了这些字段的左边字段 时，索引才会被使用（最左前缀原则）</li></ul></li></ul><ol start="3"><li>全文索引</li></ol><ul><li>全文索引的类型为 fulltext</li><li>在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值</li><li>全文索引可以在 char、varchar 和 text 类型的列上创建</li></ul><h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><p><strong>BTree</strong>：属于多叉树，又名多路平衡查找树。</p><ul><li>BTree 的节点存储多个元素（ 键值 - 数据 / 子节点的地址）</li><li>BTree 节点的键值按非降序排列</li><li>BTree 所有叶子节点都位于同一层（具有相同的深度）</li></ul><p><strong>BTree</strong> 的不足：</p><ul><li>不支持范围查询的快速查找（每次查询都得从根节点重新进行遍历）</li><li>节点都存储数据会导致磁盘数据存储比较分散，查询效率有所降低</li></ul><p><strong>B+Tree</strong>：在 BTree 的基本上，对 BTree 进行了优化：只有叶子节点才会存储 键值 - 数据，非叶子节点只存储键值和子节点的地址；叶子节点之间使用双向指针进行连接，形成一个双向有序链表。</p><p><strong>B+Tree</strong> 的优点：</p><ul><li>保证了等值查询和范围查询的快速查找</li><li>单一节点存储更多的元素，减少了查询的 IO 次数</li></ul><h4 id="索引实现方式"><a href="#索引实现方式" class="headerlink" title="索引实现方式"></a>索引实现方式</h4><p><strong>MyISAM</strong>：</p><ol><li>MyISAM的数据文件（.myd）和索引文件（.myi） 是分开存储的。</li><li>MyISAM（B+Tree）叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。</li><li>MyISAM的主键索引（Primary key）和辅助索引（Secondary key）在结构上没有任何区别，只是主键索引要求键值唯一，而辅助索引键值可以重复。</li></ol><p><strong>InnoDB</strong>：</p><ol><li>数据和索引都存储在一个文件中（.ibd）</li><li>一般情况下，聚簇索引等同于主键索引；除聚簇索引外的所有索引均称为辅助索引</li><li>InnoDB（B+Tree）叶子节点中存储的键值为索引列的值。如果是聚簇索引，数据为整行记录（除了主键值）。如果是辅助索引，数据为该行的主键值。</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h3><ul><li><p>创建型模式：用于创建对象的设计模式。可以简化用户创建对象的过程。可以降低耦合度，用户不用关心对象具体的创建过程。</p><ul><li>单例模式：某个类只能有一个实例，提供一个全局的访问点。</li><li>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</li><li>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</li><li>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</li><li>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</li><li>原型模式：通过复制现有的实例来创建新的实例。</li></ul></li><li><p>结构型模式：组织对象之间的结构。使其易于扩展。</p><ul><li>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</li><li>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</li><li>装饰模式：动态的给对象添加新的功能。</li><li>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</li><li>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</li><li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</li><li>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</li></ul></li><li><p>行为型模式：主要用于决定对象如何做出行为。</p><ul><li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li><li>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li><li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li><li>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</li><li>观察者模式：对象间的一对多的依赖关系。</li><li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</li><li>中介者模式：用一个中介对象来封装一系列的对象交互。</li><li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li><li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li><li>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li><li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li></ul></li></ul><h3 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h3><ol><li>开闭原则：对扩展开放，对修改关闭。就是如果要修改原有的功能或者是扩展功能，尽量去扩展原有的代码，而不是修改原来已有的代码。</li><li>里氏替换原则：任何子类对象都应该可以替换其派生的超类对象 。即，子类可以扩展父类的功能，但不要修改父类原有的功能。 也就是说，当一个子类继承父类后，尽量不要去重写它原有的方法。</li><li>依赖转至原则：要面向接口编程，不要面向实现编程。两个模块交互时，都访问各自接口，而不是具体的实现类。</li><li>单一职责原则：一个对象要专注于一种事情，不要让它担任太多责任。</li><li>接口隔离原则：一个接口尽量只包含用户关心的内容。就是一个接口不要太庞大。</li><li>迪米特原则：如果两个软件实体之间不是特别必要，尽量不要让他们直接通信。而是找个第三方进行转发，比如使用MQ（消息队列）。</li><li>合成复用原则：如果在“组合/聚合”和“继承”之间做抉择时，优先选择“组合/聚合”。</li></ol><h3 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>模式名称：单个实例。整个应用程序只需要一个实例即可。</li><li>问题：有很多情况下，只需要一个实例即可。现实生活中，地球、中国等，如果创建这些实例，那么只需要一个即可。 在代码世界中，全局上下文、线程池、连接池这些对象，在整个程序中也是只需要一个实例即可。</li><li>解决方案：禁止用户new该对象。只能通过提供的静态方法来获取该对象。而静态方法返回的都是同一实例。</li><li>效果：避免用户new多个没用的对象。提高了系统性能</li></ul><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ul><li>模式名称：原型（prototype）就是人们常说的，把XXX作为原型，然后弄一个跟它差不多的。</li><li>问题：经常会遇到需要克隆一个对象，然后对其稍作修改的业务场景。此时就可以使用原型模型，将对象A作为原型，然后克隆出一个对象B。</li><li>解决方案：重写对象的clone方法。也可以根据需求自己写。根据实际需要决定要深拷贝还是浅拷贝。</li><li>效果：简化了创建对象的过程</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul><li>模式名称：和生活中的工厂一样，通过工厂来生产产品（对象），而不是自己手动new。</li><li>问题：在程序中，我通过工厂类，提出我的需求（传递参数），然后工厂类帮我new相应的对象，返回给我。</li><li>解决方案：定义一个抽象对象（如动物），然后定义一个工厂类，工厂类封装了生产具体动物（当然这些具体动物要继承动物类）的方法。然后你通过参数传递给工厂类。</li><li>效果：用户不必关心对象怎么生产的，甚至不用关心这个具体对象是什么。工厂的生产规则可以写入配置文件，这样修改时就不需要动代码了。</li></ul><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><ul><li>模式名称：用户就是建造者，自己动手造自己想要的东西。</li><li>问题：有些产品需要由多个部件组成，比如电脑需要键盘、鼠标、显示器、音响、主机等等。这些东西有些需要，有些也可以不需要，有些可以随便用（取默认值）。将其抽象到代码世界，若这些配置的组合方式全部弄成构造函数，那需要好多构造函数。用户光看这些构造函数就看晕了。</li><li>解决方案：可以将每个部件的构造过程都封装成方法，提供给用户，用户选完自己的部件后，调用build()方法构建出他想要的对象。</li></ul><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><ul><li>模型名称：和生活中的代理一个意思。本来该我做的事情，我找个代理人替我做。</li><li>问题：前端调用一个后台方法，因为风险（要验证其是否登录），我不想让它直接调用核心方法，而是让它调用代理对象，如果没有风险，再由这个代理对象替它调用核心方法。</li><li>解决方案：新建代理类，在代理类的方法中调用实际方法，可以在实际方法前后增加逻辑。当访问该方法时，不new该方法对应的对象，而是new其代理对象。通常有动态代理和静态代理</li><li>效果：可以在方法前后增加一些业务逻辑，如日志、安全校验等。</li></ul><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><ul><li>模式名称：和现实装饰一样，在外层再套一层皮。</li><li>问题：可以在一个核心方法外再套一层计时功能，然后可以再套一层日志功能。 总之就是在方法的前后增加一些逻辑。</li><li>解决方案：最简单的方式是继承该类，然后重写其方法，在前后增加逻辑，但是这样不符合里氏替换原则。可以通过定义装饰器类，该装饰器类和具体要装饰的类都来自同一父类，由该装饰器类负责装饰，用户调用时调用该装饰器类。</li><li>效果：可以装饰原有类，可以提供更强劲的功能。</li></ul><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><ul><li>模式名称：在现实世界中，充电器全名为电源适配器。它的作用是将220V的交流电转化为5V的直流电。适配器就是一个转换器，将两种不兼容的东西，通过转换器使其互相兼容。</li><li>问题：在现实世界有很多适配器。在代码世界中，同样有很多相互之间不兼容的接口或类，它们之间无法直接相互调用，所以就需要适配器来进行转换。</li><li>解决方案：适配器（充电器）通过组合（也可以使用继承，但不推荐）的形式保存适配者（手机）的引用。同时适配器实现目标对象（电源）的方法（充电）。当用户要给访问目标方法时，就new一个适配器，然后将适配者传给适配器，通过适配器访问目标方法。 比如，用户要给手机充电时，先new一个充电器，然后把手机连上充电器（把手机对象传给充电器），然后充电器访问电源的充电方法。</li><li>效果：解决了两个对象之间不兼容导致无法调用的问题。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p>这里通过JVM解释，JVM中有运行时数据区域，其中包括堆和方法区，两者是线程共享区域，而剩下的栈程序计数器以及本地方法栈是线程私有区域。一个进程中有多个线程，线程是进程划分的最小运行单位。最大的区别在于运行时进程是独立的，线程不一定。线程开销较小，但不利于资源的管理和保护，进程相反。</p><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p>一共有5种状态：</p><ol><li><strong>创建</strong>：进程被创建。</li><li><strong>就绪</strong>：进程处于准备状态且获得了除处理器以外的其他资源。</li><li><strong>运行</strong>：进程正在处理器中运行。</li><li><strong>阻塞</strong>：又称等待状态，指进程正在等待某一事件而暂停运行，比如等待资源的释放或者IO操作。</li><li><strong>结束</strong>：进程结束运行，一般是中断或者退出系统。</li></ol><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>一共有七种（说出3 4种就可了</p><ol><li><strong>管道</strong>：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道</strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li><strong>消息队列</strong>：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。</li><li><strong>信号量</strong>：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存</strong>：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字</strong>：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元。</li></ol><h4 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h4><ol><li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。</li><li>**信号量(Semphares)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>事件(Event)</strong>:Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操。</li></ol><h4 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h4><ol><li><strong>先到先服务(FCFS)调度算法</strong>:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong>:从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。</li><li><strong>时间片轮转调度算法</strong>:时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法</strong>：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前被公认的一种较好的进程调度算法，UNIX操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong>：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p><p><strong>产生死锁的四个条件</strong></p><ol><li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。</li></ol><p><strong>预防死锁</strong></p><ol><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ol><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h4><ol><li>页式管理：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li><li>段式管理：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。段式管理把主存分为一段段的，且段是有实际意义的，每个段定义了一组逻辑信息。段式管理通过段表对应逻辑地址和物理地址。</li><li>段页式管理：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。</li></ol><h4 id="快表和多级页表"><a href="#快表和多级页表" class="headerlink" title="快表和多级页表"></a>快表和多级页表</h4><p><strong>快表</strong><br>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><ol><li>根据虚拟地址中的页号查快表。</li><li>如果该页在快表中，直接从快表中读取相应的物理地址。</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p><strong>多级页表</strong><br>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间。</p><h4 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h4><p>通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p><p><strong>实现方式</strong></p><ol><li>请求分页存储管理：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li><li>请求分段存储管理：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li><li>请求段页式存储管理 </li></ol><p><strong>页面置换算法</strong></p><ol><li><strong>OPT最佳页面置换算法</strong>：算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</li><li><strong>FIFO先进先出页面置换算法</strong>:总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU最近最久未使用页面置换算法</strong>：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU最少使用页面置换算法</strong>:该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Samsung ADV</title>
      <link href="/2022/11/04/samsung-adv/"/>
      <url>/2022/11/04/samsung-adv/</url>
      
        <content type="html"><![CDATA[<p>11月3日参加了三星线下机考，3个小时10次提交机会，测试用例共50个，全部通过才算完成。这次没通过，准备学习一段时间再尝试一下。把做过的题先存个档，方便复习。</p><h2 id="Airplane-Game"><a href="#Airplane-Game" class="headerlink" title="Airplane Game"></a>Airplane Game</h2><p><a href="https://blog.csdn.net/weixin_42688573/article/details/124970517">题目链接</a></p><p>题意就是在N*5的区域内有硬币(1)和敌机(2)，求出飞机结束游戏时最多能获得的硬币数量，飞机移动只能选左、右、不动，一次只能走一格。飞机初始有0个硬币1个导弹，前进方向出现敌机可以使用导弹，如果使用导弹会将5行内的敌机全部消除，不使用则硬币数-1，当硬币数&lt;0时游戏结束。<br><strong>思路</strong></p><p>求硬币最多肯定使用DFS，每一轮递归都看是否能够结束游戏，并且每轮递归直接比较出硬币数量就可以。关键点在于导弹的使用如何处理。当时想的是这样处理：只要有导弹那我就使用，然后取消炸弹使用就用回溯，就定一了一个boom和backTracking方法，前者消灭敌机，后者回溯恢复敌机。飞机定义为一个结构体，有coins和bomb属性。具体伪代码如下:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int map[][];int h;int res;struct plane {  int coins;  int bomb;}void boom(int x);//将5行内敌机消灭void backTracking(int x);//回溯将消灭的敌机复原void dfs(int row, int pos) {  if(row == h){}//游戏结束  //左移  int tag = 0;  if(plane.bomb) boom(), tag = 1;  dfs(x - 1, pos - 1);  if (tag) backTracking();  //右移  //判断是否使用炸弹然后回溯同上  dfs(x - 1, pos + 1);  //向前  //判断是否使用炸弹然后回溯同上 dfs(x - 1, pos);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回过头发现自己写的代码真的是漏洞百出，没有判断移动边界的情况，而且使用炸弹的方式一点也不好。然后回家搜了一下题解才有了思路。代码我放在下面了，用c++写的直接可以运行。（太难了我哭）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;#define SIZE 12int map[SIZE][5];int N;//测试用例总数int res;//最后返回结果int coins;//硬币数int h;//总行数int pos;//飞机所处列int max(int x, int y) {  if (x &lt; y) return y;  return x;}void dfs(int row, int pos) {  //硬币&lt;0结束  if (coins &lt; 0) {    return;  }  //飞机可以结束游戏  if (row == h) {    if (coins &gt;= 0) {      res = max(res, coins);//取最大的硬币数    } else {      res = -1;    }  }  int left, right;//左移右移递归的精髓  //飞机靠左边界只能不动或右移  if (pos == 0) {    left = 0;    right = 1;  }  //飞机靠右边界只能不动或左移  else if (pos == 4) {    left = 3;    right = 4;  }  //三种情况都可以  else {    left = pos - 1;    right = pos + 1;  }  //开始移动  for (int i = left; i &lt; right; i++) {    //判断遇到的是硬币还是敌机    if (map[row][i] == 1) {      coins++;      dfs(row + 1, i);      coins--;//回溯    }    if (map[row][i] == 2) {      coins--;      dfs(row + 1, i);      coins++;    }    if (map[row][i] == 0) {      dfs(row + 1, i);    }  }}int main() {  cin&gt;&gt;N;//测试用例数量  for (int q = 1; q &lt;= N; q++) {    cin&gt;&gt;h;//游戏区域高度    for (int i = h - 1; i &gt;= 0; i++) {      for (int j = 0; j &lt; 5; j++) {        cin&gt;&gt;map[i][j];      }    }    //初始化参数    res = -1;    coins = 0;    pos = 2;    //备用数组赋值    int temp[SIZE][5];    for (int i = 0; i &lt; h; i++) {      for (int j = 0; j &lt; 5; j++) {        temp[i][j] = map[i][j];      }    }    //处理敌机，每5行使用导弹处理敌机    for (int k = 0; k &lt;= h - 5; k++) {      //恢复原数组      for (int i = 0; i &lt; h; i++) {      for (int j = 0; j &lt; 5; j++) {        map[i][j] = temp[i][j];      }    }            for (int i = k; i &lt; k + 5; i++) {        for (int j = 0; j &lt; 5; j++) {          if (map[i][j] == 2)            map[i][j] = 0;        }      }      dfs(0, pos);    }    cout&lt;&lt;"#"&lt;&lt;q&lt;&lt;res&lt;&lt;endl;  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/caiyuzhu001/article/details/54088015">思路源</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> BFS&amp;&amp;DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法</title>
      <link href="/2022/10/29/chang-jian-pai-xu-suan-fa/"/>
      <url>/2022/10/29/chang-jian-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>今天把常见的排序算法进行总结，包括时空复杂度和一些特殊情况下的优劣。</p><h2 id="low三人"><a href="#low三人" class="headerlink" title="low三人"></a>low三人</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是从数组元素第一个开始，两两比较，循环n-1次，每一次循环都会确定一个值的位置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void bubbleSort(intp[] list) {  int len = list.length;  for (int i = 0; i &lt; len - 1; i++) {    boolean flag = false;    for (int j = 0; j &lt; len - i; j++) {      if (list[j] &gt; list[j + 1]) {        int temp = list[j + 1];        list[j + 1] = list[j];        list[j] = temp;        flag = true;      }    }    if (flag == false) {     return;     }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>冒泡排序的时间复杂度是O(n2),最坏的情况是数组有序，所以可以进行优化，添加标识为判断是否存在交换，不存在交换则结束循环。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次选择一个数组中最小的数放入数组，所以外层循环n次。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void selectSort(int[] list) {  for (int i = 0; i &lt; list.length; i++){    int min = i;//min是最小那个数的索引    for (int j = i + 1; j &lt; list.length; j++) {      if (list[min] &gt; list[j]) {        min = j;      }    }    int temp = list[min];    list[min] = list[i];    list[i] = temp;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度是O(n2)，</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>假设插入排序就是抽牌理牌的过程，手中的牌是有序的，每次抽一张牌将它插到手中并保持有序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void insertSort(int[] list) {  for (int i = 1;i &lt; list.length; i++) {    int j = i - 1;    int temp = list[i];    while (j &gt; 0 &amp;&amp; list[j] &gt; temp) {      //把大牌向后调整      list[j + 1] = list[j];      j--;    }    list[j] = temp;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入排序的时间复杂度也是O(n2)，因为每次需要移动牌，从1 + 2 + … + n = n(n + 1)。</p><h2 id="牛三人"><a href="#牛三人" class="headerlink" title="牛三人"></a>牛三人</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的中心思想是取一个元素p（第一个元素），使元素p归位，列表被p分成两部分，左边都比p小，右边比p大；递归完成排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void fastSort(int[] list, int left, int right) {  if (left &lt; right) {    int mid = partition(list, left, right);    fastSort(list, left, mid - 1);    fastSort(list, mid + 1, right);  }}public void partition(int[] list, int left, int right) {  int temp = list[left];  while (left &lt; right) {    while (left &lt; right &amp;&amp; list[left] &lt;= temp) {      left++;    }    list[right] = list[left];    while (left &lt; right &amp;&amp; list[right] &gt;= temp) {      right--;    }    list[left] = list[right];  }  list[left] = temp;  return left;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快速排序的时间复杂度是O(nlogn)，快速排序存在最坏情况，也就是数组为倒序</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序的思路是，将数组分成两部分，分别将左边和右边变有序，然后使用将两个有序数组合并为一个有序数组的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void mergeSort(int[] list, int left, int right, int[] temp) {  if (left &lt; right) {    int mid = (left + right) / 2;    mergeSort(list, left, mid, temp);//左有序    mergeSort(list, mid + 1, right, temp);//右有序    merge(list, left, mid, right, temp);  }}public void merger(int[] list, int left, int mid, int right, int[] temp) {  int i = left;  int j = mid + 1;  int count = 0;  while (i &lt;= mid &amp;&amp; j &lt;= right) {    if (list[i] &gt; list[j]) {      temp[count++] = list[j++];    } else {      temp[count++] = list[i++];    }  }  while (i &lt;= mid) {    temp[count++] = list[i++];  }  while (j &lt;= right) {    temp[count++] = list[j++];  }  //将排好的顺序放入原数组中  count = 0;  int leftI = left;  while (leftI &lt;= right) {    list[left++] = temp[count++];  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>归并排序的时间复杂度：O(nlogn)，归并有logn层，每一层循环n次。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>理解堆排序需要知道二叉树的一些相关知识，这里不讨论。堆排序分为大根堆和小根堆。顾名思义，大根堆是父节点元素一定比子节点大，小根堆则相反。堆排序我们首先需要根据数组构建出堆，然后进行调堆、出数的操作。二叉树有两种存储方式，一种是数组（本写法默认数组存放），一种是链式存储。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void sift(int[] list, int low, int high) {  int i = low;//表示根节点  int j = i * 2 + 1;//表示左孩子  int temp = list[i];  while (j &lt;= high) {    if (j + 1 &lt;= high &amp;&amp; list[j + 1] &gt; list[j]) {//右孩子大      j = j + 1;    }    if (list[j] &gt; temp) {//孩子节点比父节点大，交换节点，更新标识位      list[i] = list[j];      i = j;      j = i * 2 + 1;    } else {      list[i] = temp;//可省略      break;    }  }  list[i] = temp;}public void heapSort(int[] list) {  //从最后一个父节点向上建堆  for (int i = (list.length - 2) / 2; i &gt; -1; i--) {//最后一个元素是len-1，子节点-&gt;父节点公式：“(i - 1) / 2”    sift(list, i, list.length - 1);  }  //出数-不额外申请空间  for (int i = list.length - 1; i &gt; -1; i--) {    int temp = list[0];    list[0] = list[i];    list[i] = temp;    sift(list, 0, i - 1);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆排序的时间复杂度：sift函数是O(logn)，建堆为O(n),出数为O(n)，所以是2 * O(n*logn) = O(nlogn)。但快速排序比堆排序快一点。</p><h2 id="其他类型排序"><a href="#其他类型排序" class="headerlink" title="其他类型排序"></a>其他类型排序</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是分组插入排序算法，通过选取一个gap，将每组相邻距离为gap的元素进行直接插入排序，每进行完一次排序，gap的变为原来的一半，直到gap为1为止。希尔排序每趟不使元素有序，而是使整体数据越接近有序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void insertShellSort(int[] list, int gap) {  for (int i = gap; i &lt; list.length; i++) {    int j = i - gap;    int cur = list[i];    while (j &gt;= 0 &amp;&amp; list[j] &gt; cur) {      list[j + gap] = list[j];      j -= gap;    }    list[j + gap] = temp;  }}public void shellSort(int[] list) {  int gap = list.length / 2;  while (gap &gt; = 1) {    insertShellSort(list, gap);    gap /= 2;  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希尔排序的时间复杂度与选取的gap序列有关，不同的gap时间复杂度不同，可以在wiki上看到现存gap的时间复杂度。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>首先将列表元素分在不同的桶中，在将桶中的元素排序。比较关键的是桶的大小和桶的个数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void binSort(int[] list, int bucketSize) {  //首先计算一下桶的个数  int maxNum = list[0], minNum = list[0];  for (int i = 0; i &lt; list.length; i++) {    maxNum = Math.max(list[i], maxNum);    minNum = Math.min(list[i], minNum);  }  List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//使用list模拟桶  //创建桶  int bucketNum = (maxNum - minNum) / bucketSize;  for (int i = 0;i &lt; bucketNum; i++) {    res.add(new ArrayList&lt;&gt;());  }  //将数依次放入桶中  for (int i = 0;i &lt; list.length; i++) {    res.get((list[i] - minNum) / bucketSize)).add(list[i]);  }  //对每个桶进行排序  for (int i = 0; i &lt; bucketNum; i++) {    Collections.sort(res.get(i));  }  //将桶中的数据放入数组  int index = 0;  for(int i = 0; i &lt; bucketNum; i++) {    for (int j = 0; j &lt; res.get(i).size(); j++) {      list[index++] = res.get(i).get(j);    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>桶排序的时间复杂度和数据分布有关系，对不同的数据分布采取不同的分桶策略。（k表示一个桶平均的长度）平均情况下时间复杂度为O(n + k)，最坏情况为：O(n2k)。空间复杂度是O(nk)。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序非常好理解，创建一个计数数组，将元素依次放入计数数组中，每放入一个数，计数数组值+1，最后遍历计数数组打印元素。因为数组本身是有序的，所以可以进行排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void countSort(int[] list) {  //找出最大的值目的是创建数组  int max = list[0];  for (int i : list) {    max = Math.max(i,max);  }  int[] res = new int[max];  for (int i : list) {    res[i]++;  }  for (int i = 0; i &lt; res.length; i++) {    for (int j = 0; j &lt; res[i]; j++) {      System.out.println(i);    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计数排序时间复杂度是O(n)，但是有限制，即n不能太大。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序的原理是先从个位排序，然后百位、千位…直到位数最大的长度为止。具体实现：创建10个桶表示每位数上的值0~9，依次取个位上的数放入桶中，然后将桶内元素排序并放回原数组，接着取十位、百位等等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void redixSort(int[] list) {  int maxNum = list[0];  for (int i : list) {    maxNum = Math.max(maxNum,i);  }  int count = 0;//循环计数  while (Math.pow(10, count) &lt;= maxNum) {    int bucketNum = 10;//0-9    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    while (bucketNum &gt; 0) {      res.add(new ArrayList&lt;&gt;());      bucketNum--;    }    //取每一位的值并放入桶中    int digit = 0;    for (int i : list) {      digit = (int)(i / Math.pow(10,count)% 10 );      res.get(digit).add(i);    }    //将桶中的数组放入数组    int index = 0;    for (int i = 0;i &lt; bucketNum; i++) {      for (int j = 0; j&lt; res.get(i).size(); j++) {        list[index++] = res.get(i).get(j);      }    }    count++;//取下一位  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基数的时间复杂度是：O(nk)，k是最大数的数字位数。空间复杂度为O(k + n)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>排序算法到这里基本结束，时空复杂度和每个排序的最优最列情况要了解清楚，剩下的就是能通过伪代码记忆下来。每天做几道算法题巩固，那在笔试中就应该没有问题了。</p><p>Peace &amp; Love。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS和BFS</title>
      <link href="/2022/10/26/dfs-shen-du-you-xian-sou-suo/"/>
      <url>/2022/10/26/dfs-shen-du-you-xian-sou-suo/</url>
      
        <content type="html"><![CDATA[<p>下周要参加三星南研所的面试，主要考察的是DFS和BFS，这几天做了一些POJ的题，感觉非常吃力，因为没办法进行调试，能通过仅有的几个用例，提交代码之后还是会报错。然后在网上搜了搜别人的标准答案有的照搬也会出现问题，今天把做过的题进行一个总结，先把框架理顺。下面先讲DFS和BFS概念，接着把例题和我写的代码贴出来。</p><h2 id="DFS和BFS的区别"><a href="#DFS和BFS的区别" class="headerlink" title="DFS和BFS的区别"></a>DFS和BFS的区别</h2><ul><li>DFS是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，在换方向（换方向的过程就涉及到了回溯）。</li><li>BFS是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS 英文全称为（Depth First Search），中文称深度优先搜索算法，其过程为沿着每一个可能的路径向下进行搜索，直到不能再深入为止，并且每一个节点只能访问一次。</p><h3 id="算法的搜索遍历图的步骤"><a href="#算法的搜索遍历图的步骤" class="headerlink" title="算法的搜索遍历图的步骤"></a>算法的搜索遍历图的步骤</h3><ol><li><p>首先找到出事节点A，</p></li><li><p>依次从A未被访问的邻接点出发，对图进行深度优先遍历</p></li><li><p>若有节点未被访问，则回溯到该节点，继续进行深度优先遍历</p></li><li><p>直到所有与定点A路径相通的节点都被访问过一次。</p></li></ol><h3 id="DFS模版"><a href="#DFS模版" class="headerlink" title="DFS模版"></a>DFS模版</h3><p>正是因为dfs搜索可一个方向，并需要回溯，所以用递归的方式来实现是最方便的。所以借鉴回溯的三部曲，这里给出dfs的代码框架：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void dfs(参数) {  if (终止条件) {    收获结果；    return；  }  for (选择：本节点所有邻接节点) {    处理节点;    dfs(图， 选择的节点);//递归    回溯，撤销处理结果  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="DFS三步曲"><a href="#DFS三步曲" class="headerlink" title="DFS三步曲"></a>DFS三步曲</h3><ol><li><p>确认递归函数和参数</p><p>一般情况，深搜需要二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，可以定义一个全局遍历，避免让函数参数过多。</p></li><li><p>确定终止条件</p><p>终止条件对每个问题都是不同的，相同的是我们要在这里存放结果</p></li><li><p>处理目前搜索节点出发的路径</p><p>这里就是框架中的for循环，去遍历目前搜索节点所能到的节点。然后加上回溯操作。</p></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这里举<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">Leetcode797.所有可能的路径</a>作为例题写一下代码。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;integer&gt;&gt; allPathsSourceTarget(int[][] graph) {  path.add(0);//每条路径都是从0开始的  dfs(graph, 0);  return res;}public void dfs(int[][] graph, int current) {  //终止条件  if (current == graph.length - 1) {    res.add(new ArrayList&lt;&gt;(path));//收获结果    return;  }  //处理搜索节点路径  for (int i = 0; i &lt; graph[current].length; i++) {    path.add(graph[x][i]);    dfs(graph, graph[x][i]);//去找和graph[x][i]节点相邻的节点    path.remove(path.size() - 1);//回溯，取消操作  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广搜（bfs）是一圈一圈的搜索过程，在二叉树中的表现就是层序遍历。</p><h3 id="广搜的使用场景"><a href="#广搜的使用场景" class="headerlink" title="广搜的使用场景"></a>广搜的使用场景</h3><p>问最短、最少之类的问题，一般要想到BFS，BFS搜索是逐层搜索，达到本层时所花费的value值是一样的，由于BFS借助队列实现，而队列有先进先出的特性，所以当找到结果时，是从上一层继承下来的，一定是当前问题的最少花费。求最短路问题时，优先用bfs，因为dfs需要遍历所有情况（此处思考一下为什么）才能找到最短路（spfa算法正是借助bfs来实现的）</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针。因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p>如果用栈的话，可能就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历。因为栈是先进后出，加入元素和弹出元素的顺序改变了。<br>这里给出使用队列去实现的广度优先搜索。实现的问题就是在四方格中，给定一个起点和终点，找到起点到终点的最短路径。</p><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int vis[x];//标记数组，用来标记该节点是否曾经入队，避免节点重复入队导致死循环queue&lt;int&gt;q;//或可以用数组辅助实现队列，int q[100],int pre=0,rear=0;队头和队尾while(!q.empty()){int now=q.front();//取队首元素q.pop();//弹出队首元素步骤1.找出当前节点走一步可以接触到的地方即邻接点步骤2.在vis数组中查询步骤1找到的节点  步骤3.将未插入vis数组的节点入队}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[][] dir ={{0, 1}, {1, 0},{-1, 0},{ 0, -1}};public int numIslands(char[][] grid) {        int count = 0;        boolean[][] visited = new boolean[grid.length][grid[0].length];        for (int i = 0; i &lt; grid.length; i++) {            for (int j = 0; j &lt; grid[0].length; j++) {                if (grid[i][j] == '1') {                    bfs(grid, i, j, visited);                    count++;                }            }        }        return count;    }public void bfs(char[][] grid, int x, int y, boolean[][] visited) {        Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;();        que.add(new int[]{x,y});        visited[x][y] = true;        while (!que.isEmpty()) {            int[] temp = que.remove();            int curX = temp[0];            int curY = temp[1];            for (int i = 0; i &lt; 4; i++) {                int nextX = curX + dir[i][0];                int nextY = curY + dir[i][1];                if (nextX &lt; 0 || nextX &gt;= grid.length || nextY &lt; 0 || nextY &gt;= grid[0].length) {                    if(!visited[nextX][nextY] &amp;&amp; grid[nextX][nextY] == '1') {                        que.add(new int[]{nextX, nextY});                        visited[nextX][nextY] = true;//放入队列立马将访问状态置为true                    }                }            }        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p><a href="https://vjudge.net/problem/POJ-1321/origin">POJ - 1321</a></p><p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><p><strong>Input</strong></p><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p><p><strong>Output</strong></p><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><p><strong>思路</strong></p><p>此题是N皇后的变形题，由n个皇后变成k个皇后放置在n*n的棋盘上，并且约束条件少了一个斜线判断，只需要进行行列判断即可。那在放置棋子的时候我们就可以选择放还是不放，然后进行DFS把每一种情况都求出来类加，最后直接返回结果即可。循环是按行循环，然后判断没列是否进行插入操作，结束标准就是棋子放置完毕或者row超出了界限。需要一个判别函数、一个方法计数、一个迷宫数组、一个标记数组</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;char maze[10][10];int vis[10][10];int countNum;bool isValid(int row, int col, int n) {  //因为是按行进行循环，一行只放一个或不放所以不需要判断，只需要判断列  for (int i = row - 1; i &gt;= 0; i--) {    if (vis[i][col] == 1)      return false;  }  return true;}void dfs(int n, int k, int row) {  //无棋子结束  if (k == 0) {    countNum++;    return;  }  //越界结束  if (row &gt;= n) return;  for (int col = 0; col &lt; n; col++) {    if (isValid(row, col, n) &amp;&amp; maze[row][col] == '#') {      //放棋子      vis[row][col] = 1;      dfs(n, k - 1, row + 1);      vis[row][col] = 0;//回溯!!!    }  }  //合适位置不放，继续向下搜索  dfs(n, k, row + 1);}//输入int main() {  int n, k;  while(cin&gt;&gt;n&gt;&gt;k, n != -1 &amp;&amp; k != -1) {    for (int i = 0;i &lt; n; i++) {      for (int j = 0;j &lt; n; j++) {        cin&gt;&gt;maze[i][j];      }    }    countNum = 0;    dfs(n, k, 0);    cout&lt;&lt;countNum&lt;&lt;endl;    memset(vis, 0, sizeof(vis));    memset(maze, 0, sizeof(maze));  }  return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三维牢笼"><a href="#三维牢笼" class="headerlink" title="三维牢笼"></a>三维牢笼</h3><p>POJ - 2251s</p><p>题意：一个三维牢笼，求从S开始寻到E的最短路径，该题输入数据时不用读取空格。</p><p><strong>思路</strong></p><p>迷宫问题变形，难点在于理解题目意思，对于三维牢笼的建图，我们可以采用三维数组，三维数组a[z][x][y]可以看成z个二维数组的集合（z即可以看成z层牢笼），对于二维迷宫问题，是处于平面上的，移动时只有四个方向，上下左右，而三维迷宫问题则可以移动6个方向，也就是在二维迷宫问题上面多了一个Z坐标轴。对于最短路径使用BFS算法，所以需要一个队列。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;char maze[41][41][41];int vis[41][41][41];int dir[6][3] = {{-1, 0, 0}, {1, 0, 0}, {0, -1, 0}, {0, 1, 0}, {0, 0, -1}, {0, 0, 1}};int countNum, flag;struct node {  int x, y, z;  int step;};struct queue {  int front;  int rear;  node q[100000];};int l, r, c;void bfs (int sx, int sy, int sz) {  //标记访问  vis[sz][sx][sy] = 1;  struct queue fq;  struct node now;  //入队  now.x = sx;  now.y = sy;  now.z = sz;  now.step = 0;  fq.front = 0, fq.rear = 1;  fq.q[0] = now;  while (fq.front != fq.rear) {    //出队    now = fq.q[fq.front++];    //判断    if (maze[now.z][now.x][now.y] == 'E') {        flag = 1;        countNum = now.step;        return;    }    for (int i = 0; i &lt; 6; i++) {        node temp = now;        int nx = now.x + dir[i][1];        int ny = now.y + dir[i][2];        int nz = now.z + dir[i][0];        //判断是否越界        if (nz &gt;=0 &amp;&amp; nz &lt; l &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c &amp;&amp;            (maze[nz][nx][ny] == 'E') || maze[nz][nx][ny] == '.') {                now.x = nx, now.y = ny, now.z = nz, now.step = now.step + 1;                fq.q[fq.rear++] = now;                now = temp;                vis[nz][nx][ny] = 1;        }    }  }}int main() {    while (cin&gt;&gt;l&gt;&gt;r&gt;&gt;c, l + r + c != 0) {        int sx, sy, sz;        for (int i = 0; i &lt; l; i++) {            for (int j = 0; j &lt; r; j++) {                for (int k = 0; k &lt; c; k++) {                    cin&gt;&gt;maze[i][j][k];                    if (maze[i][j][k] == 'S') {                        sz = i;                        sx = j;                        sy = k;                    }                }            }        }        flag = 0, countNum = 0;        memset(vis, 0, sizeof(vis));        memset(maze, 0, sizeof(maze));        bfs(sx, sy, sz);        if (flag) {            cout &lt;&lt; "Escaped in " &lt;&lt; countNum &lt;&lt;" minute(s)."&lt;&lt;endl ;        } else {            cout &lt;&lt; "Trapped!" &lt;&lt; endl;        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码提交之后会出现Runtime Error，自己试了几个例子都可以通过，所以搞不清哪里又问题，如果有大神知道可以联系我一下。</p><h3 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h3><p> <a href="https://vjudge.net/problem/POJ-3278/origin">POJ - 3278 </a></p><p>题目大意：输入两个数n,m，求n到m的最短距离（n只有三种走法，前后移动一个位置或移动到2*n的位置）</p><p><strong>思路</strong></p><p>无脑搜索即可，只需要注意1.不能移动到小于0的位置；2.必须小于等于abs（n-m），此处的n是初始n，因为abs（n-m）就是一格一格移动到终点，没有花里胡哨的步骤；3.不可移动至（max(n,m)+1*2的位置。变相求最短路径依然是用BFS。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int abs(int x, int y) {    if (x &lt; y) return y - x;    return x - y;};int max(int x, int y) {    if (x &gt; y) return x;    return y;};struct node {    int step, pos;};int countNum, maxn;void bfs(int n, int k) {    //如果到位置则结束    node *q = new node[400000 + 10]();//数组代替队列    int *vis = new int[400000 + 10]();    q[0].step = 0, q[0].pos = n;    int front = 0, rear = 1;    vis[n] = 1;    while (front != rear) {        //出队        node temp = q[front++];        //判断是否是终点        if (temp.pos == k) {            cout&lt;&lt;temp.step&lt;&lt;endl;            return;        }        //进行3步走        for (int i = 0; i &lt; 3; i++) {            node now = temp;            if (i == 0) now.pos += 1;            else if (i == 1) now.pos -= 1;            else now.pos *= 2;            //走完记得步数加一            now.step++;            //判断是否出出界            if (now.pos &gt;= 0 &amp;&amp; now.step &lt;= abs(n, k) &amp;&amp; now.pos &lt;= max(n, k) * 2 &amp;&amp; !vis[now.pos]) {                //符合条件                vis[now.pos] = 1;                //入队                q[rear++] = now;            }        }    }}int main (){    int n, k;    cin&gt;&gt;n&gt;&gt;k;    bfs(n, k);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>难点在于边界的判断。</p><h3 id="Curling-2-0"><a href="#Curling-2-0" class="headerlink" title="Curling 2.0"></a>Curling 2.0</h3><p><a href="http://poj.org/problem?id=3009">POJ-3009 </a></p><p>题目大意：使用一个石头从起点扔到终点，找最少扔几次能到达终点。<br>扔石头有限制：</p><ol><li>只能朝上下左右没有石头紧靠的方向丢</li><li>丢出去之后遇到石头停下，且遇到的石头会被消灭</li><li>扔石头出界算失败</li><li>次数要求在10次之内</li></ol><p>这里限制因素比较多，要仔细考虑一下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int maze[30][30];int vis[30][30];int dire[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};int w, h, sx, sy, ex, ey;int flag, res;int min(int x, int y) {    if (x &lt; y) return x;    return y;}void dfs(int sx, int sy, int countNum, int des) {    if (sx == ex &amp;&amp; sy == ey) {        flag = 1;        res = min(res, countNum);        return;    }    //如果超过10步则结束游戏    if (countNum &gt;= 10) return;    for(int i = 0;i &lt; 4; i++) {        int nx = sx + dire[i][0];        int ny = sy + dire[i][1];        if (nx &lt; 0 || ny &lt; 0 || nx &gt;= h || ny &gt;= w) continue;        if (maze[nx][ny] == 1) continue;        int tag = 0;//越界标识符        while (maze[nx][ny] == 0 || maze[nx][ny] == 2) {            nx = nx + dire[i][0];            ny = ny + dire[i][1];            //越界            if (nx &lt; 0 || ny &lt; 0 || nx &gt;= h || ny &gt;= w) {                tag = 1;                break;            }            if (nx == ex &amp;&amp; ny == ey) {//走着走着到终点了                flag = 1;                countNum++;//步数需要+1，不然会少一步                res = min(res, countNum);                return;            }        }        if (tag) continue;//越界换方向                int stone = 0;//判断石头        if (maze[nx][ny] == 1) {            //击碎石头            maze[nx][ny] = 0;            stone = 1;            //退回到石头的前一步并继续深度搜索            dfs(nx - dire[i][0], ny - dire[i][1], countNum + 1, i);        } else {            dfs(nx, ny, countNum + 1, i);        }        if (stone) maze[nx][ny] = 1;//回溯    }}int main() {    while(cin&gt;&gt;w&gt;&gt;h, w&amp;&amp;h) {        for (int i = 0; i &lt; 30; i++) {            for (int j = 0; j &lt; 30; j++)                maze[i][j] = 0;        }        for (int i = 0; i &lt; h; ++i){for(int j = 0; j &lt; w; ++j){cin &gt;&gt; maze[i][j];if (maze[i][j] == 2){sx = i, sy = j;}else if (maze[i][j] == 3){ex = i, ey = j;}}        }        res = 999999;        flag = 0;        dfs(sx, sy, 0, 0);        if (flag)            cout&lt;&lt;res&lt;&lt;endl;        else cout &lt;&lt; -1 &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Find-The-Multiple"><a href="#Find-The-Multiple" class="headerlink" title="Find The Multiple"></a>Find The Multiple</h3><p><a href="http://poj.org/problem?id=1426">POJ-1426</a></p><p>给定一个数字n，求n的倍数（只能由0和1组成）<br><strong>思路</strong></p><p>直接暴搜两种情况，从1开始求倍数，*10或*10+1，每个样例的最小值不会超过long long的范围，所以*18次后还没结果就可以返回。</p><p><strong>DFS</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;long long res;int flag;int n;void dfs(long long num, int countNum) {    if (flag) return;    if (num % n == 0) {        flag = 1;        res = num;        return;    }    if (countNum &gt;= 18) return;    dfs(num * 10, countNum + 1);    dfs(num * 10 + 1, countNum + 1);}int main() {    while(cin&gt;&gt;n, n) {        flag = 0, res = 0;        dfs(1, 0);        cout&lt;&lt;res&lt;&lt;endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="A-Knight’s-Journey"><a href="#A-Knight’s-Journey" class="headerlink" title="A Knight’s Journey"></a>A Knight’s Journey</h3><p><a href="http://poj.org/problem?id=2488">POJ-2488 </a></p><p>给定一个棋盘，一个棋子，棋子只能按8个方向（下图中白色圆点就是马棋子从该位置开始可以走到的位置）移动，求该棋子是否能完整走完这个棋盘，若能，输出移动的完整路径。路径按照字典序优先。</p><p><strong>思路</strong></p><p>依旧是DFS深搜，终点是字典序的问题，我到现在都没想明白为什么这么排列。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int dir_x[8] = {-1,1,-2,2,-2,2,-1,1};int dir_y[8] = {-2,-2,-1,-1,1,1,2,2};bool visited[26][26];struct Path{    /* data */    int x;    char y;};Path jump_path[100];bool tag = false;int p, q;//行列void clean() {    tag = false;    for (int i = 0; i &lt; 100; i++)    {        jump_path[i].x = 0;        jump_path[i].y = '\0';    }    for (int i = 0; i &lt; 26; i++)    {        for (int j = 0; j &lt; 26; j++)        {            visited[i][j] = false;        }            }}void dfs(int startX, int startY, int jumpNum) {    int nextX, nextY;    if (jumpNum == p * q) {        tag = true;        for (int i = 0; i &lt; jumpNum; i++) {            printf("%c%d", jump_path[i].y, jump_path[i].x);        }        cout&lt;&lt;endl&lt;&lt;endl;        return;    }    for (int i = 0; i &lt; 8; i++)    {        nextX = startX + dir_x[i];        nextY = startY + dir_y[i];        if (nextX &lt; 0 || nextX &gt;= p || nextY &lt; 0 || nextY &gt;= q   || visited[nextX][nextY]) continue;        visited[nextX][nextY] = true;        jump_path[jumpNum].x = nextX + 1;        jump_path[jumpNum].y = nextY + 'A';        jumpNum++;                dfs(nextX, nextY, jumpNum);        if (tag)        {            return;        }        //回溯        visited[nextX][nextY] = false;        jump_path[jumpNum].y = '\n';        jump_path[jumpNum].x = 0;        jumpNum--;    }}int main() {        int num = 0;        cin &gt;&gt; num;        for (int i = 0; i &lt; num; i++)        {            cin &gt;&gt; p &gt;&gt; q;            clean();            cout &lt;&lt;"Scenario #"&lt;&lt;i+1&lt;&lt;":"&lt;&lt;endl;            jump_path[0].x = 1;            jump_path[0].y = 'A';            visited[0][0] = true;            dfs(0, 0, 1);            if (!tag)            {                cout &lt;&lt;"impossible" &lt;&lt; endl &lt;&lt; endl;            }                    }        return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Prime-Path"><a href="#Prime-Path" class="headerlink" title="Prime Path"></a>Prime Path</h3><p><a href="http://poj.org/problem?id=3126">POJ-3126</a></p><p>题意：给两个数A，B，求A到B需要变化的最小次数，每次变化时都必须是素数</p><p><strong>思路</strong></p><p>先把10000内的素数打表，然后分个、十、百、千位去搜索，除千位以外都可0-9，千位不可取0，还是细节问题。注意数组别开的太小，给定的数＞=1000，不能包含前导0。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int T;int n, m;int prime[50000],vis[50000];struct node{ int num,cnt;};int POW(int x, int y){if (y == 0)return 1;for (int i = 2; i &lt;= y; ++i){x *= 10;}return x;}int ans = 0;node q[20000];void bfs(){ //node *q = new node[20000]();int pre = 0, rear = 1;q[0].num = n, q[0].cnt = 0;vis[n] = 1;while (pre != rear){node now = q[pre++];if (now.num == m){cout &lt;&lt; now.cnt &lt;&lt; endl;ans = 1;break;}int temp;temp = now.num / 10 * 10;//个位for (int i = 0; i &lt; 10; ++i){int temp2 = temp + i;//temp += i;if (vis[temp2] == 0 &amp;&amp; prime[temp2]){node p; p.num = temp2, p.cnt = now.cnt + 1;q[rear++] = p;vis[temp2] = 1;}}temp = now.num / 100 * 100+now.num%10;//十位for (int i = 0; i &lt; 10; ++i){int temp2 = temp + i * 10;if (vis[temp2]==0 &amp;&amp; prime[temp2]){node p; p.num = temp2, p.cnt = now.cnt + 1;q[rear++] = p; vis[temp2] = 1;}}temp = now.num / 1000 * 1000 + now.num % 100;//百位for (int i = 0; i &lt; 10; ++i){int temp2 = temp + i * 100;if (vis[temp2]==0 &amp;&amp; prime[temp2]){node p; p.num = temp2, p.cnt = now.cnt + 1;q[rear++] = p; vis[temp2] = 1;}}temp = now.num % 1000;//千位for (int i = 1; i &lt; 10; ++i){int temp2 = temp + i * 1000;if (vis[temp2]==0 &amp;&amp; prime[temp2]){node p; p.num = temp2, p.cnt = now.cnt + 1;q[rear++] = p; vis[temp2] = 1;}}}//delete(q);}int main(){cin &gt;&gt; T;int cnt = 0;for (int i = 2; i &lt;=20000; ++i){//打表int flag = 0;for (int j = 2; j &lt; i; ++j){if (i%j == 0){flag = 1;break;}}if (!flag)prime[i] = 1;}while (T--){cin &gt;&gt; n &gt;&gt; m;for (int i = 0; i &lt;= 15000; ++i){vis[i] = 0;q[i].num = 0, q[i].cnt = 0;}ans = 0;if (n == m){cout &lt;&lt; 0 &lt;&lt; endl; continue;}bfs();if (!ans)cout &lt;&lt; "Impossible" &lt;&lt; endl;} return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Pots"><a href="#Pots" class="headerlink" title="Pots"></a>Pots</h3><p><a href="http://poj.org/problem?id=3414">POJ-3414</a></p><p>题意：倒水问题，只有6种操作，均只对两个杯子A，B进行操作，只要两个杯子任意一杯的水量=目标水量，即判定找到，6种操作分别是1.倒满A杯，2.倒满B杯，3.倒空A，4.倒空B，5.A倒进B，6.B倒进A。注意：A倒B时，A当前水量&gt;B当前剩余容量（不是水量），则溢出部分需要留在A内，B倒A同理</p><p><strong>思路</strong><br>题目要求最少的操作数，那必然是BFS，每一次都搜索这六种操作即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int T;int n,m,C;int vis[1000][1000];struct node{ int a,b,cnt;int s[10000];};node q[10000];int main(){//while (cin &gt;&gt; n&gt;&gt; m&gt;&gt; C){cin &gt;&gt; n &gt;&gt; m &gt;&gt; C;int flag = 0;int pre = 0, rear = 1;q[0].a = 0, q[0].b = 0, q[0].cnt = 0;vis[0][0] = 1;while (pre != rear){node now = q[pre++];if (now.a == C || now.b == C){//flag = 1;cout &lt;&lt; now.cnt &lt;&lt; endl;//1是倒1，2倒2，3是1to2，4是2to1，5是倒空1，6是倒空2for (int i = 0; i &lt; now.cnt; ++i){if (now.s[i] == 1)cout &lt;&lt; "FILL(1)" &lt;&lt; endl;else if (now.s[i] == 2)cout &lt;&lt; "FILL(2)" &lt;&lt; endl;else if (now.s[i] == 3)cout &lt;&lt; "POUR(1,2)" &lt;&lt; endl;else if (now.s[i] == 4)cout &lt;&lt; "POUR(2,1)" &lt;&lt; endl;else if (now.s[i] == 5)cout &lt;&lt; "DROP(1)" &lt;&lt; endl;else if (now.s[i] == 6)cout &lt;&lt; "DROP(2)" &lt;&lt; endl;}return 0;break;}for (int i = 0; i &lt; 6; ++i){node temp=now;int a = now.a, b = now.b;if (i == 0){//倒满aif (a == n)continue;a = n;if (!vis[a][b]){temp.s[now.cnt] = 1;temp.a = a, temp.b = b, temp.cnt = now.cnt + 1;q[rear++] = temp;vis[a][b] = 1;}}else if (i == 1){//倒满b//if (!b){if (b == m)continue;b = m;if (!vis[a][b]){//temp.s = now.s;temp.s[now.cnt] = 2;temp.a = a, temp.b = b, temp.cnt = now.cnt + 1;q[rear++] = temp;vis[a][b] = 1;}//}}else if (i == 2){//a to bint sb = m - b;//b还能放多少if (sb==0 || a==0)continue;//b放不下或a没有东西倒if (a - sb &gt;= 0){a -= sb;b = m;}else{b += a;a = 0;}if (!vis[a][b]){temp.s[now.cnt] = 3;temp.a = a, temp.b = b, temp.cnt = now.cnt + 1;q[rear++] = temp;vis[a][b] = 1;}}else if (i == 3){//b to aint sa = n - a;//a还能放多少if (sa==0 || b==0)continue;//a放不下或b为空if (b - sa &gt;= 0){//b还有剩余b -= sa;a = n;}else{a += b;b = 0;}if (!vis[a][b]){temp.s[now.cnt] = 4;temp.a = a, temp.b = b, temp.cnt = now.cnt + 1;q[rear++] = temp;vis[a][b] = 1;}}else if (i == 4){//倒空aif (a==0)continue;a = 0;if (!vis[a][b]){temp.s[now.cnt] = 5;temp.a = a, temp.b = b, temp.cnt = now.cnt + 1;q[rear++] = temp;vis[a][b] = 1;}}else if (i == 5){//倒空bif (b==0)continue;b = 0;if (!vis[a][b]){temp.s[now.cnt] = 6;temp.a = a, temp.b = b, temp.cnt = now.cnt + 1;q[rear++] = temp;vis[a][b] = 1;}}}}cout &lt;&lt; "impossible" &lt;&lt; endl;//}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS&amp;&amp;DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/10/25/hui-su-suan-fa/"/>
      <url>/2022/10/25/hui-su-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="回溯算法定义"><a href="#回溯算法定义" class="headerlink" title="回溯算法定义"></a>回溯算法定义</h2><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。<br><strong>所以，回溯函数也就是递归函数，指的都是一个函数</strong>。</p><h2 id="回溯解决的问题"><a href="#回溯解决的问题" class="headerlink" title="回溯解决的问题"></a>回溯解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>这里再解释一下组合和排列。<strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。即组合无序，排列有序。</p><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h2 id="回溯法模版"><a href="#回溯法模版" class="headerlink" title="回溯法模版"></a>回溯法模版</h2><ol><li><p>回溯函数模板返回值以及参数</p><p>回溯算法中函数返回值一般为void。因为回溯算法需要的参数步容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p></li><li><p>回溯函数终止条件</p><p>既然是树形结构，那么遍历树形结构一定要有终止条件。所以回溯也有要终止条件。什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p></li><li><p>回溯搜索的遍历过程</p><p><img src="1.png"></p><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p></li></ol><p>那么可以写出总体的框架为:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">void backtracking(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h2><h3 id="组合1"><a href="#组合1" class="headerlink" title="组合1"></a>组合1</h3><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接</a><br>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:<br>输入: n = 4, k = 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>那么参照上面的树，这道题的解题思路如下图：</p><p><img src="2.png"></p><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。int型变量startIndex，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p></li><li><p>回溯函数终止条件</p><p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p></li><li><p>回溯搜索的遍历过程</p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p></li></ol><p>所以代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {  combineHelper(n, k, 1);  return res;}public void combineHelper(int n, int k, int startIndex) {  //终止条件  if (path.size() == k) {    res.add(new ArrayList&lt;&gt;(path));    return;  }  for (int i = startIndex; i &lt;= n; i++) {//控制树的横向遍历    path.add(i);//处理节点    combineHelper(n, k, i + 1);//递归，控制树的纵向遍历，注意下一层搜索要从i+1开始    path.remove(path.size() - 1);//回溯，撤销处理的节点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中最难理解的地方就是对树的横向遍历和递归树的纵向遍历，可以手写几个例子就可以清楚到底是如何循环的。</p><h4 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。<br>接下来看一下剪枝过程</p><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。<br>举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。则for循环变成</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">for (int i = startIndex; i &lt;= n - (k - path.size) + 1; i++)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="组合3"><a href="#组合3" class="headerlink" title="组合3"></a>组合3</h3><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接</a></p><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>这里还是要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。int型变量startIndex用来记录下一层for循环搜索的起始位置，（集合就是[1,…,n] ），int型变量sum计算path中的和。</p></li><li><p>回溯函数终止条件</p><p>path这个数组的大小如果达到k并且总和sum等于target，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p></li><li><p>回溯搜索的遍历过程</p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i，更新sum值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {  combineHelper(n, k, 1, 0);  return res;}public void combineHelper(int target, int k, int startIndex, int sum) {  //剪枝操作  if (sum &gt; target) {    return;  }  //终止条件  if (path.size() == k) {    if (sum == target) {      res.add(new ArrayList&lt;&gt;(path));      return;    }   }  for (int i = startIndex; i &lt;= 9; i++) {//控制树的横向遍历    sum += i;    path.add(i);//处理节点    combineHelper(n, k, i + 1);//递归，控制树的纵向遍历，注意下一层搜索要从i+1开始    sum -= i;    path.remove(path.size() - 1);//回溯，撤销处理的节点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这道题的剪枝是比较容易想出来的，当sum的值大于target的时候就不需要往下遍历直接返回即可。</p></li></ol><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接(opens new window)</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="3.png"></p><p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合，这里需要注意变量都是字符串，要知道容器的定义。这里需要一个int类型的index，这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。和上面的startIndex的意义不同。int型变量sum计算path中的和。</p></li><li><p>回溯函数终止条件</p><p>例如输入用例”23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。那么终止条件就是如果index 等于 输入的数字个数</p></li><li><p>回溯搜索的遍历过程</p><p>首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。然后for循环来处理这个字符集，<strong>这里for循环，可不像是前面从startIndex开始遍历的</strong>。</p><p><strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而前两道题都是求同一个集合中的组合！</strong></p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">StringBuilder path = new StringBuilder();List&lt;String&gt; res = new ArrayList&lt;&gt;();public List&lt;String&gt; letterCombinations(String digits) {  if (digits == null || digits.length() == 0) {    return res;  }  Strinf[] letterMap = new String(){    "", // 0    "", // 1    "abc", // 2    "def", // 3    "ghi", // 4    "jkl", // 5    "mno", // 6    "pqrs", // 7    "tuv", // 8    "wxyz", // 9  }  combine(digits, 0, letterMap);  return res;}public void combineHelper(String digits, int index, String[] letterMap) {  //终止条件  if (index == digits.length()) {    res.add(path.toString());    return;    }   }  String temp = letterMap[digits.charAt(index) - '0'];  for (int i = 0; i &lt; temp.length(); i++) {//控制树的横向遍历    path.append(temp.charAt(i));//处理节点    combineHelper(digits, index + 1, letterMap);//递归，控制树的纵向遍历，注意下一层搜索要从i+1开始    path.deleteCharAt(path.length() - 1);//回溯，撤销处理的节点  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><a href="https://leetcode.cn/problems/combination-sum/">力扣题目链接</a></p><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</p><p>示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>那么就可以通过回溯算法的三步曲来解决这个问题。</p><ol><li><p>回溯函数模板返回值以及参数</p><p>这里还是要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。int型变量startIndex用来记录下一层for循环搜索的起始位置，（集合就是[1,…,n] ），int型变量sum计算path中的和。</p><p><strong>本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？</strong></p><p>如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>，<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html">216.组合总和III</a>。</p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">17.电话号码的字母组合</a></p></li><li><p>回溯函数终止条件</p><p>从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。</p></li><li><p>回溯搜索的遍历过程</p><p>单层for循环依然是从startIndex开始，搜索candidates集合。</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {  combineHelper(candidates, target, 0);  return res;}public void combine(int[] candidates, int target, int startIndex {  if (target == 0) {    res.add(new ArrayList&lt;&gt;(path));    return;  }  for (int i = startIndex, i &lt; candidates.length; i++) {    if (candidates[i] &gt; target) break;//如果不进行判断，会无限的循环下去，因为传入的是i而不是i+1，导致栈空间泄漏    path.add(candidates[i]);    combine(candidates, target - candidates[i], i);//本题要求同一个数字可以无限制重复选去，所以传入的就是i    path.remove(path.size() - 1);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组合总和2"><a href="#组合总和2" class="headerlink" title="组合总和2"></a>组合总和2</h3><p><a href="https://leetcode.cn/problems/combination-sum-ii/">力扣题目链接</a></p><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p><strong>本题的难点在于：集合（数组candidates）有重复元素，但还不能有重复的组合</strong>。所以需要去重。<strong>去重，其实就是使用过的元素不能重复选取。</strong><br>组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。<strong>所以去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。<br>实现去重我们要在for循环里去实现。我们使用startIndex去记录下一层for循环的起始位置，那么当i &gt; startIndex的时候说明遍历到了树同层的下一个元素，这个时候再判断一下i - 1和i的元素值是否相同，相同则说明元素重复，不同则继续纵向遍历。<strong>还有一点是要对数组进行排序</strong>。那么代码实现如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {        Arrays.sort(candidates);        combine(candidates, target, 0);        return res;    }    public void combine(int[] list, int target, int startIndex) {        if (target == 0) {            res.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i = startIndex; i &lt; list.length; i++) {            if (list[i] &gt; target) break;            if (i != startIndex &amp;&amp; list[i] == list[i - 1]) {                continue;            }            path.add(list[i]);            combine(list, target - list[i], i + 1);            path.remove(path.size() - 1);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣题目链接</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p><img src="4.jpg"></p><p>切割问题还是可以画成树进行解决，下面直接给出代码，依旧是用三步曲解决问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//这里用来记录路径使用双端队列Deque&lt;String&gt; path = new LinkedList&lt;&gt;();List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;String&gt;&gt; partition(String s) {  combine(s, 0);  return res;}public void combine(String s, int startIndex) {  if (startIndex &gt;= s.length()) {//当起始线超过了数组长度，说明已经有结果了    res.add(path);    return;  }  for (int i = startIndex; i &lt; s.length(); i++) {    if (isPalindrome(s, startIndex, i)) {//是回文串，添加到path中去      String temp = s.subString(startIndex, i + 1);//把回文子串截断，subString是左闭右开，所以+1      path.addLast(temp);    } else {      continue;//不是回文子串，继续循环    }    combine(s, i + 1);    path.removeLast();  }}public boolean isPalindrome(String s, int start, int end) {  for (int i = start, j = end; i &lt; j; i++, j--) {    if (s.charAt(i) != s.charAt(j)) {      return fasle;    }  }  return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:192.168@1.1">192.168@1.1</a>“ 是 无效的 IP 地址。</p><p>示例 1：</p><ul><li>输入：s = “25525511135”</li><li>输出：[“255.255.11.135”,”255.255.111.35”]</li></ul><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>回溯三步曲</p><ul><li><p>递归参数</p><p>这里依然需要有startIndex作为下一层for循环的起始位置，除此之外还需要一个pointNum作为终止条件。</p></li><li><p>终止条件</p><p>这里不能使用分割线到列表末尾判断，需要根据点的数量，点的数量为3则代表已经分成了4段。</p></li><li><p>单层搜索逻辑</p><p>在for循环中首先进行截取，然后判断截取的子串是否合法，合法就在子串末尾加符号.表示已分割，不合法则结束本层循环。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; res = new ArrayList&lt;&gt;();public List&lt;String&gt; restoreIpAddresses(String s) {        combine(s, 0, 0);        return res;}public void combine(String s, int startIndex, int pointNum) {        if (pointNum == 3) {            //判断第四段是否合法            if (isValid(s, startIndex, s.length() - 1)) {                res.add(s);            }            return;        }        for (int i = startIndex; i &lt; s.length(); i++) {            if (isValid(s, startIndex, i)) {                s = s.substring(startIndex, i + 1) + "." + s.substring(i + 1);//子串合法插入符号.                pointNum++;                combine(s, i + 2, pointNum);//插入符号后，下一个子串的起始位置是i+2                pointNum--;//回溯，取消插入符号                s = s.substring(startIndex, i + 1) + s.substring(i + 2);//回溯，取消插入符号            } else {                break;            }        }}public boolean isValid(String s, int start, int end) {        if (start &gt; end) {            return false;        }        //段位以0为开头的数字不合法        if (s.charAt(start) == '0' &amp;&amp; start != end) {            return false;        }        //判断值是否大于255        String temp = s.substring(start, end + 1);        if (Integer.valueOf(temp) &gt; 255) {            return false;        }        //判断是否出现数字以外其他字符        for (int i = start; i &lt;= end; i++) {            if(s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') {                return false;            }        }        return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><h3 id="子集1"><a href="#子集1" class="headerlink" title="子集1"></a>子集1</h3><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接(opens new window)</a></p><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>如果把子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点</strong></p><p><img src="5.png"></p><p>继续我们的回溯三步曲</p><ul><li><p>递归参数</p><p>需要一个数组path为子集手机元素，二维数组res存放子集组合</p></li><li><p>终止条件</p><p>剩余集合为空的时候，就是叶子节点。</p></li><li><p>单层循环逻辑</p><p>直接收集子集元素就可以</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        backTracking(nums, 0);        return res;    }    public void backTracking(int[] nums, int startIndex) {        res.add(new ArrayList&lt;&gt;(path));//遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合        if (startIndex &gt;= nums.length) {            return;        }        for (int i = startIndex; i &lt; nums.length; i++) {            path.add(nums[i]);            backTracking(nums, i + 1);            path.remove(path.size() - 1);        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h3><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接(opens new window)</a></p><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>这道题的难度在于给定数组中可能出现重复元素，但要求解集不能重复。这题和组合2的要求是一样的，同一层级中不能出现重复元素，但是同一个树枝可以出现重复元素。在操作时需要对数组进行排列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        res.add(new ArrayList&lt;&gt;());//子集永远包含一个空集        if (nums.length == 0 || nums == null) {            return res;        }        Arrays.sort(nums);//需要对数组排序！！        backTracking(nums, 0);        return res;}public void backTracking(int[] nums, int startIndex) {        if (startIndex &gt;= nums.length) {//可以省略，因为当startIndex超出长度后for循环也结束了            return;        }        for (int i = startIndex; i &lt; nums.length; i++) {            if (i &gt; startIndex &amp;&amp; nums[i - 1] == nums[i]) {//和组合2解决方法一致，同一层上的去重                continue;            }            path.add(nums[i]);            res.add(new ArrayList&lt;&gt;(path));//结果要求是所有子集            backTracking(nums, i + 1);            path.remove(path.size() - 1);        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><p><a href="https://leetcode.cn/problems/increasing-subsequences/">力扣题目链接(opens new window)</a></p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><ul><li>输入: [4, 6, 7, 7]</li><li>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li></ul><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>这道题与上面的子集II问题比较像，又是取子集又是去重，子集II我们通过将数组进行排序再加一个判断来达到去重的目的，但是本题是不能进行排序的。本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了。</p><p>那么回溯三步曲应该是</p><ul><li><p>递归参数</p><p>需要一个数组path为子集收集元素，二维数组res存放子集组合，int 类型的startIndex表示下一层for循环的起始位置</p></li><li><p>终止条件</p><p>终止条件判断startIndex是否大于nums.length依旧可以省略。当path.size() &gt; 1时就表明了有结果，就可以添加到res。</p></li><li><p>单层循环逻辑</p><p>这里不同的是不能像上一问题那样判断重复，所以需要使用一个哈希表用来查看值在同一层是否被使用过。然后判断一下大小。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {        backtracking(nums,0);        return res;    }    private void backtracking (int[] nums, int start) {        if (path.size() &gt; 1) {            res.add(new ArrayList&lt;&gt;(path));        }        int[] used = new int[201];        for (int i = start; i &lt; nums.length; i++) {            if (!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - 1) ||                    (used[nums[i] + 100] == 1)) continue;            used[nums[i] + 100] = 1;            path.add(nums[i]);            backtracking(nums, i + 1);            path.remove(path.size() - 1);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全排列II"><a href="#全排列II" class="headerlink" title="全排列II"></a>全排列II</h3><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接(opens new window)</a></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><ul><li>输入：nums = [1,1,2]</li><li>输出： [[1,1,2], [1,2,1], [2,1,1]]</li></ul><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>这道题不同的地方就是要求不能有重复的排列，这个问题老生常谈，就是在同一层中要求不能有重复的元素出现就行，和上面就差一个判断。判断之前一定要将数组重新排序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Integer&gt; path = new ArrayList&lt;&gt;();List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {        if (nums.length == 0 || nums == null) {            return res;        }        Arrays.sort(nums);        boolean[] visited = new boolean[nums.length];        backTracking(nums, visited);        return res;}public void backTracking(int[] nums, boolean[] visited) {        if (path.size() == nums.length) {            res.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i = 0; i &lt; nums.length; i++) {            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过          //上述两种都可以便已通过，只不过第二种效率较高，是进行数层级别的判断            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; visited[i - 1] == false) {                continue;            }            //如果同⼀树⽀nums[i]没使⽤过开始处理            if (visited[i] == false) {                visited[i] = true;                path.add(nums[i]);                backTracking(nums, visited);                path.remove(path.size() - 1);                visited[i] = false;            }        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p><a href="https://leetcode.cn/problems/n-queens/">力扣题目链接(opens new window)</a></p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><ul><li>输入：n = 4</li><li>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</li><li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li></ul><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;class Solution {public:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {        result.clear();        std::vector&lt;std::string&gt; chessboard(n, std::string(n, '.'));        backTracking(n, 0, chessboard);        return result;    }    bool isValid(int row, int col, vector&lt;string&gt; &amp;chessboard, int n) {    //检查列    for (int i = 0; i &lt; row; i++) {        if (chessboard[i][col] == 'Q') {            return false;        }    }    //检查45度    for (int i = row - 1, j = col - 1;j &gt;= 0 &amp;&amp; i &gt;= 0; j--, i--) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    //检查135斜线    for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {        if (chessboard[i][j] == 'Q') {            return false;        }    }    return true;}    void backTracking(int n, int row, vector&lt;string&gt; &amp;chessboard) {        if (row == n) {            result.push_back(chessboard);            return;        }        for (int col = 0; col &lt; n; col++) {            if (isValid(row, col, chessboard, n)) {                chessboard[row][col] = 'Q';                backTracking(n, row + 1, chessboard);                chessboard[row][col] = '.';            }        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2022/10/24/shu-zu-xiang-guan-suan-fa/"/>
      <url>/2022/10/24/shu-zu-xiang-guan-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="数组相关知识"><a href="#数组相关知识" class="headerlink" title="数组相关知识"></a>数组相关知识</h3><p>数组是存放在连续内存空间上的相同类型数据的集合。正是因为数组的在内存空间的地址是连续的，所以在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a href="https://leetcode.cn/problems/binary-search/">leetcode704</a></p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br><strong>思路</strong></p><p>二分查找早已经刻在了DNA里，但是使用二分查找的条件就是数组有序。先从中间找，然后向两边判断，具体代码如下。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public class binary_search {    public int binarySearch(int[] list,int val){        int left = 0,right = list.length - 1;        while (left &lt;= right){            int mid = (right - left) / 2 + left;            if (list[mid] == val)                return mid;            else if (list[mid] &gt; val){                right = mid - 1;            }else {                left = mid + 1;            }        }        return -1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有两种写法，一种是left &lt;= right那么在边界移动的时候right left不等于mid，另一种是left &lt; right那么此时right left需要等于mid进行判断。也就是左闭右闭合、左闭右开的区别。</p><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">leetcode59</a></p><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p><strong>思路</strong></p><p>这题没有什么算法，就是对循环中边界的条件判断比较繁琐，就像二分钟是否带“=”一样。这里的原则是左闭右开，顾头不顾尾，最后需要判断是否需要给最后一个值留位子。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int[][] generateMatrix(int n) {        int i, j;        int start = 0;        int loop = 0;        int count = 1;        int[][] res = new int[n][n];        while (loop++ &lt; n / 2) {            //第一行遍历            for (j = start; j &lt; n - loop; j++) {                res[start][j] = count++;                System.out.println(res[0][0]);            }            //最后一列遍历            for (i = start; i &lt; n - loop; i++) {                res[i][j] = count++;            }            //最后一行遍历            for (; j &gt;= loop; j--) {                res[i][j] = count++;            }            //第一列遍历            for (;i &gt;= loop; i--) {                res[i][j] = count++;            }            //更新坐标            start++;        }        if (n % 2 == 1) {            res[start][start] = count;        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/remove-element/">leetcode27移除元素</a></p><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>思路</strong></p><p>也很经典的题目，用双指针，快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组，慢指针：指向更新新数组下标的位置。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {    public int removeElement(int[] nums, int val) {        int slow = 0;        for (int fast = 0; fast &lt; nums.length; fast++){            if (nums[fast] != val) {                nums[slow++] = nums[fast];            }        }        return slow;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">leetcode977</a></p><p>给你一个按非递减顺序 排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p><strong>思路</strong></p><p>这里的难度在于有负数，负数后的平方可能是大的也可能小，暴力解法就是全部取平方后再排序，但是时间复杂度就变成了O(nlogn)。有效的还是用双指针，依次计算比较平方后的首位元素大小然后放入新的数组中。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {    public int[] sortedSquares(int[] nums) {        int left = 0, right = nums.length - 1;        int[] res = new int[nums.length];        int index = nums.length - 1;        while (left &lt;= right) {            if (Math.pow(nums[left],2) &gt;= Math.pow(nums[right],2)) {                res[index--] = (int) Math.pow(nums[left++],2);            } else {                res [index--] = (int) Math.pow(nums[right--],2);            }        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">leetcode209长度最小子数组</a></p><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p><strong>思路</strong></p><p>暴力搜索就是两个for循环的嵌套，时间复杂度是O(n2)，本质也是滑动窗口，外层循环是滑动窗口的头，内层循环是滑动窗口的尾。使用一次for循环的话难点在于如何处理滑动窗口的长度，具体的解释请看<a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">这里</a>，下面是代码。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {    public int minSubArrayLen(int target, int[] nums) {        int res = Integer.MAX_VALUE;        int subL = 0, sum = 0;        int i = 0;        for (int j = 0; j &lt; nums.length; j++) {            sum += nums[j];            while (sum &gt;= target) {                subL = j - i + 1;                res = Math.min(res,subL);                sum -= nums[i];                i++;            }        }    return res = res &gt; subL ? subL : res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发-打点+界面优化</title>
      <link href="/2022/10/23/android-kai-fa-da-dian-jie-mian-you-hua/"/>
      <url>/2022/10/23/android-kai-fa-da-dian-jie-mian-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="1-打点任务"><a href="#1-打点任务" class="headerlink" title="1.打点任务"></a>1.打点任务</h2><p>打点就是在用户触发点击操作时，我们将一些特定信息保存下来，这样可以收集用户偏好设置。</p><p>这套实现的原理可以看做是建造者模式</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>建造者模式（Bulider Pattern）是将一个复杂对象的构建过程与它的实现表示分离，使得同样的构建过程可以创建不同的表示，属于创建型模式。使用创建者模式对于用户而言只需要制定需要建造的类就可以获得对象，建造过程及细节不需要了解。建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不一定固定。如果一个对象有非常复杂的内部结构（很多属性），可以将复杂对象的创建和使用进行分离。</p><p>所以具体实现是通过编写一个类继承SmartBaseInfo，SmartBaseInfo中我们定义一些需要记录的信息名称的Key，比如source、eventType等。我直接使用编好的SmartAddRemoveAppInfo类，在其中设置我们的setValue方法去保存数据。当需要传递时只需要创建SmartAddRemoveAppInfo对象调用setValue方法进行保存，接着直接调用SmartAddRemoveAppInfo.build()打点就结束了。</p><h3 id="1）大文件夹打点"><a href="#1）大文件夹打点" class="headerlink" title="1）大文件夹打点"></a>1）大文件夹打点</h3><p>打开应用时打点打开来源</p><p> 1.小文件夹内打开应用 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Folder”</p><p> 2.大文件夹内打开应用 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”BigFolder”</p><p> 3.桌面打开 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Workspace”</p><p> 4.hotseat打开 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Hotseat”</p><p>因为要判断点击App应用时的启动背景，每个App的图标都是一个BubbleTextView，在这个类中有属性可以进行直接判断启动背景，所以我们自定义一个方法returnClickSource()，在方法内通过类内定义的int类型的mDisplay去判断然后返回相应的value即可。在外部调用时需要进行强转，因为是在BubbleTextView中的静态方法，而外部只能用到view。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">((BubbleTextView) v).returnClickSource();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里hotseat需要判断单独的参数，如下。是通过LauncherSettings里的一个变量去判断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object tag = getParent() instanceof FolderIcon ? ((View) getParent()).getTag() : getTag();ItemInfo info = tag instanceof ItemInfo ? (ItemInfo) tag : null;if (info != null &amp;&amp; (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在取App包名的时候在工具类文件下新建了一个GetAppPackageName类，类内定义一个静态方法用来返回一个包名字符串类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class GetAppPackageName {    public static String getAppProcessName(Context context) {        //当前应用pid        int pid = android.os.Process.myPid();        //任务管理类        ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);        //遍历所有应用        List&lt;ActivityManager.RunningAppProcessInfo&gt; infos = manager.getRunningAppProcesses();        for (ActivityManager.RunningAppProcessInfo info : infos) {            if (info.pid == pid)//得到当前应用                return info.processName;//返回包名        }        return "UNKNOWN";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 5.recent打开 “eventType”:”openApp”, “packageName”:“xxxxx”, “source”:”Recent”</p><p>recent其实就是上划后的界面。在这个界面里每一个app都是一个TaskView，直接在TaskView中找到OnClick点击事件在末尾处直接打点即可。</p><h3 id="2）打开文件夹"><a href="#2）打开文件夹" class="headerlink" title="2）打开文件夹"></a>2）打开文件夹</h3><p> 1.小文件夹打开文件夹 “eventType”:”openFolder”, “source”:”FolderIcon”</p><p> 2.大文件夹打开文件夹 “eventType”:”openFolder”, “source”:”BigFolder”</p><p>这是最简单的一个逻辑，直接在ItemOnClickHandler中找对应的文件夹点击事件触发的方法中直接打点即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//打开小文件夹打点，大文件夹类似SmartAddRemoveAppInfo.Builder smallFolder = new SmartAddRemoveAppInfo.Builder();smallFolder.setEventType(VALUE_OPEN_APP);smallFolder.setSource(VALUE_SOURCE_FOLDER_ICON);EdenSmartView.sendToSmartView(v.getContext(), smallFolder.build().buildEventParam    (EdenSmartView.createNew(SmartAddRemoveAppInfo.EVENT_ID_LAUNCHER)));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）切换文件夹"><a href="#3）切换文件夹" class="headerlink" title="3）切换文件夹"></a>3）切换文件夹</h3><p>切换文件夹是通过长按弹出一个pop框后选择“切换”的功能。</p><p>怎么找方法实现：首先选择“切换”需要长按，所以在ItemLongClickListener中找到长按逻辑的实现，发现会执行一个startDrag的方法，方法是在Workspace中定义的，且方法最后执行了beginDragShared，在beginDragShared中使用了PopupContainerWithArrow.showForIcon()方法，show中执行了populateAndShow()方法，populateAndShow()中调用了fillChildView()，在这个方法中可以找到inflateFolderPopup()，这里面就找到了切换和重命名的点击逻辑。切换文件夹的点击逻辑是在onClick()中实现的，所以打点直接卸载Click里就行，只需要判断是“大变小”还是“小变大”即可。</p><p> 1.小文件夹切换成大文件夹 “eventType”:”replaceFolder”, “source”:”FolderIcon”</p><p> 2.大文件夹切换成小文件夹 “eventType”:”replaceFolder”, “source”:”BigFolder”</p><h3 id="4）文件夹重命名"><a href="#4）文件夹重命名" class="headerlink" title="4）文件夹重命名"></a>4）文件夹重命名</h3><p>重命名的逻辑有点复杂，在onClick中会新建一个Folder，我们想要的是在编辑完成回退后取到Folder的名字，所以自定义打点方法并在里面进行判断oldTitle和newTitle是否相同，相同不打点，不相同进行打点，这个方法在回退动画执行之前执行。</p><p> 1.小文件夹重命名 “eventType”:”renameFolder”, “source”:”FolderIcon”, “extra:”新文件夹名称”</p><p> 2.大文件夹重命名 “eventType”:”renameFolder”, “source”:”BigFolder”, “extra:”新文件夹名称”</p><h2 id="2-Preference卡片风格设计"><a href="#2-Preference卡片风格设计" class="headerlink" title="2.Preference卡片风格设计"></a>2.Preference卡片风格设计</h2><h3 id="1）卡片风格"><a href="#1）卡片风格" class="headerlink" title="1）卡片风格"></a>1）卡片风格</h3><p>卡片风格的制作其实就是改变preference的background设计，我们需要重新设计一个drawable资源，因为preference的样式已经通过一个自定义的xml改变，我们只需要在自定义的layout中最外层通过background属性进行引用。</p><p>创建home_settings_preference_background.xml。这里定义了圆角和背景颜色两个属性。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/home_settings_preference_color<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@dimen/home_settings_preference_background_radius<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着需要在customise_preference_double.xml和customise_preference_single.xml中进行引用。</p><h3 id="2）实现点击变色效果"><a href="#2）实现点击变色效果" class="headerlink" title="2）实现点击变色效果"></a>2）实现点击变色效果</h3><p>最开始是发现系统会引用一个item_background.xml，里面定义了一个区域在按下、获得焦点、选中不同状态时所使用的drawable。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_window_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/transparent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- Even though these two point to the same resource, have two states so the drawable will invalidate itself when coming out of pressed state. --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>state_enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_disabled<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>state_enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>                              <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_disabled<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>                                <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_transition<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>                               <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_transition<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>                                                             <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/list_selector_background_focused<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/transparent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="android-state-pressed"><a href="#android-state-pressed" class="headerlink" title="android:state_pressed"></a>android:state_pressed</h4><p>是当控件被按下的时候控件的表示，可以实现按下按钮时，按钮变成领一个模样，松开之后又恢复原样。</p><h4 id="android-state-focused"><a href="#android-state-focused" class="headerlink" title="android:state_focused"></a>android:state_focused</h4><p>是当控件获得焦点的时候控件的表示。</p><h4 id="android-state-selected"><a href="#android-state-selected" class="headerlink" title="android:state_selected"></a>android:state_selected</h4><p>选中时控件的表示。</p><p>selected和focused的区别：focused是指获取焦点，早期某些设备存在方向键盘可以用来移动焦点，而pressed仅仅是指按下状态。然后selected容易和focused混淆。一个界面只允许有一个控件处在focus状态，却可以有多个处于Selected状态，可以调用View.setSelected设置选中。</p><p>我在这里只设置了两种：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>      <span class="token attr-name"><span class="token namespace">android:</span>state_pressed</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/home_settings_pressed<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>state_focused</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>                                  <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/home_settings_normal<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样就实现了在点击后，会使用不同的drawable会发生颜色变化，但问题就是没有了点击颜色动画，非常生硬，所以使用下面的方法。</p><h3 id="3）点击动画水波纹效果"><a href="#3）点击动画水波纹效果" class="headerlink" title="3）点击动画水波纹效果"></a>3）点击动画水波纹效果</h3><p>新建一个drawable资源，使用ripple标签制作点击动画，我们需要在其中定义两个item，和一个color。第一个color是点击后的颜色，item第一个是我们需要在这个drawable里产生动画，第二个表示动画的区域。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ripple</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/home_settings_preference_pressed_color<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/home_settings_preference_background<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@android:id/mask<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@android:color/white<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@dimen/home_settings_preference_background_radius<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ripple</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）深色模式和白日模式颜色改变"><a href="#4）深色模式和白日模式颜色改变" class="headerlink" title="4）深色模式和白日模式颜色改变"></a>4）深色模式和白日模式颜色改变</h3><p>两种方式</p><h4 id="1-分别在对应的文件夹下创建同名的color。"><a href="#1-分别在对应的文件夹下创建同名的color。" class="headerlink" title="1.分别在对应的文件夹下创建同名的color。"></a>1.分别在对应的文件夹下创建同名的color。</h4><p><img src="01.png"></p><p><img src="02.png"></p><p>在这两个文件夹下的color中创建同名的color，home_settings_preference_color。</p><h4 id="2-新建一个attr值，类型为color。"><a href="#2-新建一个attr值，类型为color。" class="headerlink" title="2.新建一个attr值，类型为color。"></a>2.新建一个attr值，类型为color。</h4><p>新建attr后，在values文件下的styles中添加light和dark的颜色，具体位置如下：</p><style name="LauncherTheme" parent="@style/BaseLauncherTheme"><style name="LauncherTheme.Dark" parent="@style/LauncherTheme">这样系统在切换主题是会使用对应的color。### 5）设计向右箭头我把箭头设计成了一个widget，而这个widget中只不过是提供了一个图片，使用image属性rotation将图片旋转后使用。### 6）删除pref和修改版本位置在添加pref时直接返回false。将Wiko Version放在了整个页面的下面，就是FrameLayout里，用一个LinearLayout将两行文字包住，之后调整LinearLayout的位置和TextView的位置就可以了。## 3.修改OnClickListener的匿名函数INSTANCE在不知道点击onClick()方法来源的时候，需要添加一个source参数，并且修改lamada函数的写法。修改前：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static final OnClickListener INSTANCE &#x3D; ItemClickHandler::onClick;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>修改后：<pre class="line-numbers language-java" data-language="java"><code class="language-java">public static final OnClickListener INSTANCE(String source) &#123;    return new MyOnClickListener(source);&#125;public static class MyOnClickListener implements OnClickListener &#123;    private String source;        public MyOnClickListener(String source) &#123;        this.source &#x3D; source;    &#125;        @Override    public void onClick(View v) &#123;        ItemClickHandler.onClick(v, source);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></style>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发-添加大文件弹窗</title>
      <link href="/2022/10/22/android-kai-fa-tian-jia-da-wen-jian-dan-chuang/"/>
      <url>/2022/10/22/android-kai-fa-tian-jia-da-wen-jian-dan-chuang/</url>
      
        <content type="html"><![CDATA[<p><img src="01.jpeg"></p><h2 id="1-将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。"><a href="#1-将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。" class="headerlink" title="1.将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。"></a>1.将弹窗绘制好，两种方案：一是修改原View，二是使用dialog。</h2><p>最后方案使用自定义Dialog实现弹窗，自定义了一个xml。外层为linearlayout，包含一个imageview,</p><p>3个textview，文字和图片都是居中显式，高宽根据文字内容决定。</p><p>处理最后一个textview的点击事件，使用类内接口，在调用时传入接口参数判断点击事件，调用AgreeClick()方法。</p><p>用到Window对象设置弹窗大小、位置、动画。通过getWindow()获得Window对象，后set各种属性。新建一个drawable.xml，在里面设置Window的弧度。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">window.setGravity(Gravity.BOTTOM);//弹窗位置window.setBackgroundDrawableResource(R.drawable.large_file_folder_dialog_shape);//弹窗背景window.setWindowAnimations(R.style.large_folder_dialog);//弹窗动画window.setDimAmount(0f);//全透明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了设置Dialog窗口大小和布局，使用Resources中的getDisplayMetrics()方法获得DisplayMetrics类对象，通过其中的.widthPixels()和.heightPixels()得到手机的宽和高。</p><p>通过WindowManager.LayoutParams创建一个params对象，通过.attr设置window的宽高和相对位置，最后一定要调用window的.setAttributes(params)将参数传递进去才能有效果。</p><p>窗口底边高度要配合导航栏高度。直接把mInitY传给window的高度就行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Launcher launcher = Launcher.fromContext(context);if (launcher != null &amp;&amp; launcher.getDeviceProfile() != null){    mInitY = launcher.getDeviceProfile().getInsets().bottom;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后定义一个静态方法show用来给外部类提供方法，方法内部新建一个自定义的dialog并监听点击事件，调用.dissmiss()来消除dialog。</p><h2 id="2-弹窗绘制好后实现逻辑，触发的四种逻辑。"><a href="#2-弹窗绘制好后实现逻辑，触发的四种逻辑。" class="headerlink" title="2.弹窗绘制好后实现逻辑，触发的四种逻辑。"></a>2.弹窗绘制好后实现逻辑，触发的四种逻辑。</h2><h3 id="1：首次长按文件夹（大-小）。"><a href="#1：首次长按文件夹（大-小）。" class="headerlink" title="1：首次长按文件夹（大/小）。"></a>1：首次长按文件夹（大/小）。</h3><p>ItemLongClickListener类下的onWorkspaceItemLongClick()添加逻辑。因为所有Item的长按逻辑都在这个方法里实现，所以需要进行判断。通过view.getTag()判断是文件夹还是app快捷方式。判断完成后在进行show的调用。</p><h3 id="2：首次点击文件夹（大-小）。"><a href="#2：首次点击文件夹（大-小）。" class="headerlink" title="2：首次点击文件夹（大/小）。"></a>2：首次点击文件夹（大/小）。</h3><p>ItemClickHandler类下的onClickFolderIcon()和onClickBigFolderIcon()中添加逻辑。根据SharedPreference保存的数据判断NewLargeFolderDialog.show()的调用。</p><h3 id="3：首次合并应用形成文件夹。"><a href="#3：首次合并应用形成文件夹。" class="headerlink" title="3：首次合并应用形成文件夹。"></a>3：首次合并应用形成文件夹。</h3><p>合并生成文件夹的逻辑是在Workspace.java下的createUserFolderIfNecessary()方法里实现，只需要在方法return之前调用show()方法就行。</p><h3 id="4：首次拖动应用进入文件夹）"><a href="#4：首次拖动应用进入文件夹）" class="headerlink" title="4：首次拖动应用进入文件夹）"></a>4：首次拖动应用进入文件夹）</h3><p>合并生成文件夹的逻辑是在Workspace.java下的addToExistingFolderIfNecessary()方法里实现，和第三条同理。</p><h2 id="3-设置sharedPreference，保存是否是第一次操作的参数，bool类型。"><a href="#3-设置sharedPreference，保存是否是第一次操作的参数，bool类型。" class="headerlink" title="3.设置sharedPreference，保存是否是第一次操作的参数，bool类型。"></a>3.设置sharedPreference，保存是否是第一次操作的参数，bool类型。</h2><p>因为要实现第一次点击之后就不需要弹出Dialog，需要一个数据进行判断，SharedPreference保存的数据会存在一个文件下，launcher中在Utilities中定义了一个getPref(Context context)方法，返回的就是一个SharedPreference对象，只需要在调用时传入context就好。</p><p>存入数据的逻辑是在show()方法中的监听点击事件里定义，在点击“知道了”以后put一个bool类型的值然后apply，接着走dissmiss()，这样只要走过四种逻辑中的任意一个，就会写入值。写入需要使用SharedPreferences.Editor对象编写。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SharedPreferences.Editor mUserAgreeSharedPref = Utilities.getPrefs(context).edit();mUserAgreeSharedPref.putBoolean("first_new_large_folder_dialog_notification", false);mUserAgreeSharedPref.apply();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>取出数据是在判断四种逻辑时调用即可，直接通过SharedPreferences对象调用get方法取出数据进行判断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">boolean first_notification = Utilities.getPrefs(v.getContext()).getBoolean("first_new_large_folder_dialog_notification", true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除sharedpreference中特定的key</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mUserAgreeSharedPref.remove("first_new_large_folder_dialog_notification").commit();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-LottieAnimationView的使用"><a href="#4-LottieAnimationView的使用" class="headerlink" title="4.LottieAnimationView的使用"></a>4.LottieAnimationView的使用</h2><p>首先需要加入配置文件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//Lottie动画implementation "com.airbnb.android:lottie:3.6.0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在需要放置动画的xml中放置Lottie</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;com.airbnb.lottie.LottieAnimationView        android:id="@+id/new_large_file_dialog_lottie"        android:layout_width="match_parent"        android:layout_height="wrap_content"        app:lottie_autoPlay="true"        app:lottie_loop="true"        app:lottie_fileName="data.json" //JSON文件需要放在 src/main/asset中        app:lottie_rawRes="@raw/animation" //JSON文件需要放置在 src/main/res/raw中与上面二选一即可/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着在Java文件中配置Lottie,其中新建LottieAnimationView对象通过R.id找到对应的law，可以设置是否自动播放，是否循环播放等。最后直接play即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private LottieAnimationView mLottieAnimationView;//Lottie AnimationViewmLottieAnimationView = (LottieAnimationView) findViewById(R.id.new_large_file_dialog_lottie);mLottieAnimationView.setImageAssetsFolder("data.json");//配置JSONmLottieAnimationView.loop(true);//循环播放////设置X轴方向上的缩放比例，0f为不可见，1f原始大小 Ps.原setScale方法在2.0.0版本后已弃用//mLottieAnimationView.setScaleX(0.5f);////设置Y轴方向上的缩放比例//mLottieAnimationView.setScaleY(0.5f);mLottieAnimationView.playAnimation();//播放动画<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了防止内存泄漏，应该在动画不需要播放的时候释放Lottie动画。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mLottieAnimationView.setImageAssetsFolder(null);//传一个null，防止动画在后台继续播放<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发-修改Preference</title>
      <link href="/2022/10/19/android-kai-fa-xiu-gai-preference/"/>
      <url>/2022/10/19/android-kai-fa-xiu-gai-preference/</url>
      
        <content type="html"><![CDATA[<p>记录一下从事Android开发两个月以来学到的东西，虽然以后可能不会从事相关工作，还是纪念一下吧。</p><h1 id="主屏幕设置页面样式"><a href="#主屏幕设置页面样式" class="headerlink" title="主屏幕设置页面样式"></a>主屏幕设置页面样式</h1><h2 id="1-Preference样式修改"><a href="#1-Preference样式修改" class="headerlink" title="1.Preference样式修改"></a>1.Preference样式修改</h2><p>首先需要理解Preference是如何构成的。分析一下preference.xml可知每个item主要有三部分，如下：</p><p><img src="Android1-1.png"></p><p>第一部分为图标区域，第二部分是title和summary区域，第三部分是其他控件区域。</p><p>了解了其大体结构，就可以根据需求进行修改了。</p><p>图标区域没有所以设置为invisibility。中间使用了两个layout来区分，一个是有summary一个没有。</p><p>只有Title的layout里设置字体颜色、居中、margin等。有Summary的需要调整summary的位置和文字大小。</p><h2 id="2-按钮样式修改"><a href="#2-按钮样式修改" class="headerlink" title="2.按钮样式修改"></a>2.按钮样式修改</h2><p>修改了“Google左屏”类型为SwitchPreference的选择开关样式。</p><p>通过引用另一个widgetout来实现样式的更改。</p><p>创建customise_switchpreference.xml，定义一个<switch>控件，在其中配置thumb和track</switch></p><p>Switch有两个重要的属性：thumb和track，thumb是Switch中间圆，track是Switch底部长条。</p><h3 id="1-1thumb"><a href="#1-1thumb" class="headerlink" title="1.1thumb"></a>1.1thumb</h3><p>因为是通过<shape>方式实现的所以thumb和track的定义在drawble文件夹下。</shape></p><p>新建thumb文件，通过item引用来设置开和关的不同效果。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_thumb_open<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_thumb_close<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>customise_sp_thumb_open.xml中可以配置半径、背景色、边界背景色等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--设置圆的半径--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--设置圆空心部分的背景色 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#FFFFFF<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--    &amp;lt;!&amp;ndash;设置圆边的背景色&amp;ndash;&amp;gt;--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stroke</span>        <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#001AFF<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拿到settings里的thumb"><a href="#拿到settings里的thumb" class="headerlink" title="拿到settings里的thumb"></a>拿到settings里的thumb</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layer-list</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>        <span class="token attr-name"><span class="token namespace">android:</span>top</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>left</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>right</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>bottom</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>oval<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>20dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/settingslib_switch_thumb_color<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layer-list</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>layer-list 是用来创建 LayerDrawable 的，LayerDrawable 是 DrawableResource 的一种，layer-list创建出来也就是一个drawable 图形。layer-list 的大致原理类似 RelativeLayout，是一层层的叠加 ，后添加的会覆盖先添加的。在 layer-list 中可以通过控制后添加图层距离最底部图层的左上右下的四个边距等属性，得到不同的显示效果。</p><p>layer-list中的item是按照顺序从下往上叠加的，即先定义的item在下面，后面的依次往上面叠放</p><h3 id="1-2track"><a href="#1-2track" class="headerlink" title="1.2track"></a>1.2track</h3><p>和thumb一样，在drawable文件夹下新建track.xml总文件，通过item重新配置开和关的样式。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selector</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_track_open<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>state_checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/customise_sp_track_close<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selector</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--设置圆角矩形的高--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>size</span> <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>56dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!--设置圆角矩形的圆角半径--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>40dp<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#001AFF<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token comment">&lt;!--    &amp;lt;!&amp;ndash;设置圆边的背景色&amp;ndash;&amp;gt;--&gt;</span><span class="token comment">&lt;!--    &lt;stroke--&gt;</span><span class="token comment">&lt;!--        android:width="1dp"--&gt;</span><span class="token comment">&lt;!--        android:color="#001AFF"/&gt;--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拿到settings里的track"><a href="#拿到settings里的track" class="headerlink" title="拿到settings里的track"></a>拿到settings里的track</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>shape</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>shape</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rectangle<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>52dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>28dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>solid</span> <span class="token attr-name"><span class="token namespace">android:</span>color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@color/settingslib_switch_track_color<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>corners</span> <span class="token attr-name"><span class="token namespace">android:</span>radius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>35dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>shape</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>（光晕效果通过在<switch>控件中加入：“</switch></strong></em><em><strong>android</strong></em><em><strong>:background</strong></em>***=”@null”***<em><strong>”来取消光晕效果）</strong></em></p><h2 id="3-在设置界面加入入口"><a href="#3-在设置界面加入入口" class="headerlink" title="3.在设置界面加入入口"></a>3.在设置界面加入入口</h2><p>我们需要了解<meta-data>标签</meta-data></p><p>直译为“元数据”，该标签可为<activity>、<application>、<receiver>、<service>等组件提供附加数据项。<br>组件元素可以包含任意数量的<meta-data>子元素。系统将meta-data配置的数据存储于一个Bundle对象中，可以通过PackageItemInfo.metaData字段获取。</meta-data></service></receiver></application></activity></p><ul><li>android:name</li></ul><p>分配给该标签的键，即唯一名称。为确保名称唯一应使用Java风格命名约定</p><ul><li>android:resource</li></ul><p>对资源的引用，如“@string/app_name”。该资源ID可以通过该metaData.getInt()方法获取 。</p><ul><li>android:value</li></ul><p>分配给该标签的值，如String、Boolean等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.action.EXTRA_SETTINGS<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.order<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-2<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.category<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.category.ia.homepage<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.summary<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/summary_empty<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.android.settings.icon<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>resource</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/ic_setting<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>com.android.settings.action.EXTRA_SETTINGS 设置遍历所有应用解析标记</p><p>com.android.settings.category.ia.homepage 在设置主界面显示</p><p>com.android.settings.icon 显示图标</p><p>com.android.settings.summary 显示子标题文字</p><p>com.android.settings.order 设置主界面排序，网络和互联网默认-120，只要大于即可排到第一</p><p>上述语句完成入口的加入配置icon等信息。</p>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-第一行代码</title>
      <link href="/2022/10/18/android-di-yi-xing-dai-ma/"/>
      <url>/2022/10/18/android-di-yi-xing-dai-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="Chap1-Android-项目架构"><a href="#Chap1-Android-项目架构" class="headerlink" title="Chap1-Android 项目架构"></a>Chap1-Android 项目架构</h2><h3 id="gradle-idea"><a href="#gradle-idea" class="headerlink" title=".gradle/.idea"></a>.gradle/.idea</h3><p>这两个目录下放置的都是 Android Studio 自动生成的一些文件。</p><h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>项目中的代码、资源等内容几乎都是放置在这个目录下的。  </p><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p>这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle 下载好，而是会自动根据本地的缓存情况决定是否需要联网下载 gradle。Android Studio 默认没有启用gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏→File→Settings→Build, Execution, Deployment→Gradle，进行配置更改。  </p><h3 id="gitgnore"><a href="#gitgnore" class="headerlink" title=".gitgnore"></a>.gitgnore</h3><p> 这个文件是用来将指定的目录或文件排除在版本控制之外的。</p><h3 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h3><p>这个文件是全局的 gradle 配置文件，在这里配置的属性将会影响到项目中所有的 gradle 编译脚本。  </p><h3 id="gradle、gradle-bat"><a href="#gradle、gradle-bat" class="headerlink" title=".gradle、gradle.bat"></a>.gradle、gradle.bat</h3><p>这两个文件是用来在命令行界面中执行 gradle 命令的，其中 gradlew 是在 Linux 或 Mac 系统 中使用的，gradlew.bat 是在 Windows 系统中使用的。  </p><h3 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title=".settings.gradle"></a>.settings.gradle</h3><p>这个文件用于指定项目中所有引入的模块。由于 HelloWorld 项目中就只有一个 app 模块，因此该文件中也就只引入了 app 这一个模块。通常情况下模块的引入都是自动完成的。  </p><h3 id="app-build-gradle文件"><a href="#app-build-gradle文件" class="headerlink" title="app/build.gradle文件"></a>app/build.gradle文件</h3><p>第一行应用了一 个插件，一般有两种值可选：com.android.application 表示这是一个应用程序模块， com.android.library 表示这是一个库模块。应用程序模块和库模块的最大区别在于，一个是可以直接运行的，一个只能作为代码库依附于别的应用程序模块来运行。</p><h3 id="android-闭包"><a href="#android-闭包" class="headerlink" title="android 闭包"></a>android 闭包</h3><p>在这个闭包中我们可以配置项目构建的各种属性。其中， compileSdkVersion 用于指定项目的编译版本，buildToolsVersion 用于指定项目构建工具的版本。</p><h3 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig 闭包"></a>defaultConfig 闭包</h3><p>applicationId 用于指定项目的包名，如果想在后面对其进行修改，那么就是在这里修改的。 minSdkVersion 用于指定项目最低兼容的 Android 系统版本。</p><p>targetSdkVersion 指定的值表示在该目标版本上已经做过了充分的测试， 系统将会为你的应用程序启用一些最新的功能和特性。</p><p>versionCode 用于指定项目的版本号，versionName 用于指定项目的版 本名，</p><h3 id="buildTypes-闭包。"><a href="#buildTypes-闭包。" class="headerlink" title="buildTypes 闭包。"></a>buildTypes 闭包。</h3><p>buildTypes 闭包中用于指定生成安装文件的相关配置，通常只会有两个子闭包，一个是 debug，一个是 release。</p><p>debug 闭包用于指定生成测试版安装文件的配置，release 闭包用于指定生成正式版安装文件的配置。另外， debug 闭包是可以忽略不写的。</p><p>release 闭包：</p><p>minifyEnabled 用于指定是否对项目的代码进行混淆，true 表 示混淆，false 表示不混淆。proguardFiles 用于指定混淆时使用的规则文件，这里指定了两个文件，第一个 proguard-android.txt 是在 Android SDK 目录下的，里面是所有项目通用的 混淆规则，第二个 proguard-rules.pro 是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则。</p><h3 id="dependencies-闭包"><a href="#dependencies-闭包" class="headerlink" title="dependencies 闭包"></a>dependencies 闭包</h3><p>这个闭包的功能非常强大，它可以指定当前项目所有的依赖关系。通常 Android Studio 项目一共有3种依 赖方式：本地依赖、库依赖和远程依赖。本地依赖可以对本地的 Jar 包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖则可以对 jcenter 库上的开源项目添加依赖关系。 </p><p>compile fileTree 是一个本地依赖声明，它表示将 libs 目录下所有.jar 后缀的文件都添加到项目的构建路径当中。</p><p>compile 则是远程依赖声明。加上这句声明后，Gradle 在构建项目时会首先检查一下本地是否已经有这个库的缓存，如果没有的话 则会去自动联网下载，然后再添加到项目的构建路径当中。</p><p>库依赖声明的基本格式是 compile project 后面加上要依赖的库名称，比如说有一个库模块的名字叫 helper， 那么添加这个库的依赖关系只需要加入 compile project(‘:helper’)这句声明即可。  </p><h2 id="Chap2-四大组件：活动"><a href="#Chap2-四大组件：活动" class="headerlink" title="Chap2-四大组件：活动"></a>Chap2-四大组件：活动</h2><h3 id="2-1活动基本用法"><a href="#2-1活动基本用法" class="headerlink" title="2.1活动基本用法"></a>2.1活动基本用法</h3><p>活动都要在 AndroidManifest.xml 中进行注册才能生效， 活动的注册声明要放在<application>标签内。</application></p><p>在注册活动之后还需要为程序配置主活动，这样在程序运行时才会找到第一个需要启动的活动。在<activity>标签中加入<intent-filter>标签并添加两句声明。lable属性用来修改标题。</intent-filter></activity></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span>  <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>label</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Fruits<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.category.LAUNCHER<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-1销毁活动"><a href="#2-1-1销毁活动" class="headerlink" title="2.1.1销毁活动"></a>2.1.1销毁活动</h4><p>调用finish()方法。</p><h3 id="2-2menu菜单"><a href="#2-2menu菜单" class="headerlink" title="2.2menu菜单"></a>2.2menu菜单</h3><p>首先在 res 目录下新建一个 menu 文件夹，新建文件夹menu，接着新建一个Menu resource file</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span><span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中一个item表示一个菜单项，可以为其分配id做点击事件的处理。</p><p>在活动中需要重写onCreateOptionsMenu()。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.main, menu); return true;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 getMenuInflater()方法能够得到 MenuInflater 对象，再调用它的 inflate()方法就可以给当前活动创建菜单了。inflate()方法接收两个参数，第一个参数用于指定通过哪 一个资源文件来创建菜单，这里当然传入 R.menu.main。第二个参数用于指定菜单项将添加到哪一个 Menu 对象当中。方法返回 true，表示允许创建的菜单显示出来，返回 false，创建的菜单将无法显示。  </p><p>接着做菜单项的点击事件，我们需要重写onOptionsItemSelected() ，代码很简单无需解释。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.add_item:         break; default: } return true;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3Intent"><a href="#2-3Intent" class="headerlink" title="2.3Intent"></a>2.3Intent</h3><h4 id="2-3-1显式Intent"><a href="#2-3-1显式Intent" class="headerlink" title="2.3.1显式Intent"></a>2.3.1显式Intent</h4><p>Intent 有多个构造函数的重载，其中一个是 Intent(Context packageContext, Class cls)。这个构造函数接收两个参数，第一个参数 Context 要求提供一个启动活动的上下文，第二个参数 Class 则是指定想要启动的目标活动。然后使用Activity 类中提供的startActivity()方法，它接收一个 Intent 参数。</p><h4 id="2-3-2隐式Intent"><a href="#2-3-2隐式Intent" class="headerlink" title="2.3.2隐式Intent"></a>2.3.2隐式Intent</h4><p>不明确指出我们想要启动哪一个活动， 而是指定了一系列更为抽象的 action和category 等信息，然后交由系统去分析这个Intent， 并帮我们找出合适的活动去启动。在 AndroidManifest.xml 中通过在标签下配置的内容，可以指定当前活动能够响应的 action 和 category。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.SecondActivity<span class="token punctuation">"</span></span> <span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.activitytest.ACTION_START<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.category.DEFAULT<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>data</span> <span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码指明了当前活动可以响应 com.example.activitytest.ACTION_ START 这个 action， <category>标签则包含了一些附加信息，只有和中的内容同时能够匹配 上 Intent 中指定的 action 和 category 时,活动才会相应Intent。那么此时Intent中的参数应该是定义的action。 每个 Intent 中只能指定一个 action，但却能指定多个 category。</category></p><p>除此之代还可以配置一个<data>标签，用于更精确地指定当前活动能够响应什么类型的数据。</data></p><ul><li> android:scheme。用于指定数据的协议部分，如上例中的 http 部分。  </li><li> android:host。用于指定数据的主机名部分，如上例中的 <a href="http://www.baidu.com/">www.baidu.com</a> 部分。</li><li> android:port。用于指定数据的端口部分，一般紧随在主机名之后。</li><li> android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。  </li><li> android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。     </li></ul><p>(android.intent.category.DEFAULT 是一种默认的 category，在调用 startActivity()方法的时候会自动将这个 category 添加到 Intent 中。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent intent = new Intent("com.example.activitytest.ACTION_START");//添加categoryintent.addCategory("com.example.activitytest.MY_CATEGORY"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3传递数据"><a href="#2-3-3传递数据" class="headerlink" title="2.3.3传递数据"></a>2.3.3传递数据</h4><p>使用putExtra()方法暂存数据，其接收两个参数，第一个参数是键，第二个参数才是真正要传递的数据。  </p><p>获取intent需要使用getIntent()，方法可以获取到用于启动本活动的 Intent，然后调用 getTypeExtra()方法，传入相应的键值，就可以得到传递的数据。</p><h4 id="2-3-4返回数据"><a href="#2-3-4返回数据" class="headerlink" title="2.3.4返回数据"></a>2.3.4返回数据</h4><p>返回数据给上一个活动可以调用startActivityForResult()，方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在回调中判断数据的来源。请求码需要是一个唯一值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic void onClick(View v) {    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);    startActivityForResult(intent, 1);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了返回数据需要调用setResult()。 方法接收两个参数， 第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这 两个值，第二个参数则把带有数据的 Intent 传递回去。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void onClick(View v) {    Intent intent = new Intent();    intent.putExtra("data_return", "Hello FirstActivity");    setResult(RESULT_OK, intent); }//通过back返回活动传递数据@Overridepublic void onBackPressed() {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 startActivityForResult()方法来启动 SecondActivity，在 SecondActivity 被销毁之后会回调上一个活动的 onActivityResult()方法，因此需要在 FirstActivity 中重写这个方法来得到返回的数据。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void onActivityResult(int requestCode, int resultCode, Intent data) {    switch (requestCode) {    case 1:         beak;    default:    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>onActivityResult()方法带有三个参数，第一个参数 requestCode，即我们在启动活动时传入的请求码。第二个参数 resultCode，即我们在返回数据时传入的处理结果。第三个参数 data，即携带着返回数据的 Intent。因为会有很多活动返回的数据都会回调到 onActivityResult()这个方法 中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。  </p><h3 id="2-4活动生命周期"><a href="#2-4活动生命周期" class="headerlink" title="2.4活动生命周期"></a>2.4活动生命周期</h3><p>Android 使用任务（Task）来管理活动，一个任务就是一组存放在栈里的活动的集合，也被称作返回栈。在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。每当按下 Back 键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。  </p><h3 id="2-5活动回收保存数据"><a href="#2-5活动回收保存数据" class="headerlink" title="2.5活动回收保存数据"></a>2.5活动回收保存数据</h3><p>Activity中提供了一个 onSaveInstanceState()回调方法，方法可以保证在活动被回收之前一定会被调用，因此可以通过这个方法来保存临时数据。  </p><p>onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如 putString()、 putInt()等。每个保存方法需要传入两个参数，第一个参数是键，第二个参数是数据内容。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void onSaveInstanceState(Bundle outState) {    super.onSaveInstanceState(outState);    String tempData = "Something you just typed";    outState.putString("data_key", tempData);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  onCreate()方法中有一个 Bundle 类型的参数 ，在有保存的数据时会Bundle接收。</p><h3 id="2-6活动启动模式"><a href="#2-6活动启动模式" class="headerlink" title="2.6活动启动模式"></a>2.6活动启动模式</h3><h4 id="2-6-1standard"><a href="#2-6-1standard" class="headerlink" title="2.6.1standard"></a>2.6.1standard</h4><p>standard 模式（默认），每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</p><h4 id="2-6-2singleTop"><a href="#2-6-2singleTop" class="headerlink" title="2.6.2singleTop"></a>2.6.2singleTop</h4><p>在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。  只需要在<activity>标签中加入下面的代码。</activity></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">android:launchMode="singleTop" <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-6-3singleTask"><a href="#2-6-3singleTask" class="headerlink" title="2.6.3singleTask"></a>2.6.3singleTask</h4><p>每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。  </p><h4 id="2-6-4singleInstance"><a href="#2-6-4singleInstance" class="headerlink" title="2.6.4singleInstance"></a>2.6.4singleInstance</h4><p>singleInstance 模式的活动会启用一个新的返回栈来管理这个活动（singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈）。在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，解决了共享活动实例的问题。  </p><h3 id="2-7活动进阶编写"><a href="#2-7活动进阶编写" class="headerlink" title="2.7活动进阶编写"></a>2.7活动进阶编写</h3><h4 id="2-7-1知道是哪个活动"><a href="#2-7-1知道是哪个活动" class="headerlink" title="2.7.1知道是哪个活动"></a>2.7.1知道是哪个活动</h4><p> 新建一个Java Class，叫BaseActivity，让其继承 AppCompatActivity  并重写onCreate()方法，在方法中打印名称。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Log.d("BaseActivity", getClass().getSimpleName());} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着让所有活动继承BaseActivity，每当运行一个活动室就会自动打log。</p><h4 id="2-7-2随时退出活动"><a href="#2-7-2随时退出活动" class="headerlink" title="2.7.2随时退出活动"></a>2.7.2随时退出活动</h4><p>新建一个 ActivityCollector 类作为活动管理器, 在活动管理器中，通过一个 List 来暂存活动，然后提供addActivity()和removeActivity()方法用于从 List 中加入、移除活动，提供finishAll()方法用于将 List 中存储的活动全部销毁掉。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ActivityCollector {    public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;();    public static void addActivity(Activity activity){        activities.add(activity);    }    public static void removeActivity(Activity activity){        activities.remove(activity);    }    public static void finishAll(){        for(Activity activity:activities){            if(!activity.isFinishing()){                activity.finish();            }        }        activities.clear();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>杀掉当前进程</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">android.os.Process.killProcess(android.os.Process.myPid());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-7-3最佳启动活动"><a href="#2-7-3最佳启动活动" class="headerlink" title="2.7.3最佳启动活动"></a>2.7.3最佳启动活动</h4><p>以防不知道在启动活动时不知道下一个活动需要什么数据，我们可以添加一个 actionStart()方法，在这个方法中完成了 Intent 的构 建，将活动中需要的数据都通过 actionStart()方法的参数传递过来，然后把它们存储到 Intent 中，最后调用 startActivity()方法启动 。 这样活动所需要的数据在方法参数中全部体现出来了，可以非常清晰地知道启动 活动需要传递哪些数据。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void actionStart(Context context, String data1, String data2) {    Intent intent = new Intent(context, SecondActivity.class);    intent.putExtra("param1", data1);    intent.putExtra("param2", data2);    context.startActivity(intent);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简化后启动活动的代码只需要一行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SecondActivity.actionStart(FirstActivity.this, "data1", "data2"); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Chap3-布局-列表"><a href="#Chap3-布局-列表" class="headerlink" title="Chap3-布局+列表"></a>Chap3-布局+列表</h2><h4 id="3-1控件"><a href="#3-1控件" class="headerlink" title="3.1控件"></a>3.1控件</h4><h4 id="3-1-1Textview"><a href="#3-1-1Textview" class="headerlink" title="3.1.1Textview"></a>3.1.1Textview</h4><p>android:id：定义唯一标识符。</p><p>android:layout_width 和 android:layout_height ：指定控件的宽度和高度。</p><p>android:gravity ：指定文字的对齐方式， top、bottom、left、right、 center 等，可以用“|”来同时指定多个值，center效果等同于 center_ vertical|center_horizontal，表示文字在垂直和水平方向都居中对齐。  </p><p>android:textSize ：指定文字的大小，在 Android 中字体大小使用 sp 作为单位  。</p><p> android:textColor ：指定文字的颜色。</p><p> android:padding ：给控件的周围加上补白。</p><p>android:maxLines ：设置为 true 表示让这个 TextView 只能单行显示。 </p><p>android:ellipsize ：设定当文本内容超出控件宽度时，文本的缩略方式，这里指定成 end 表示在尾部进行缩略。  </p><h4 id="3-1-2Button"><a href="#3-1-2Button" class="headerlink" title="3.1.2Button"></a>3.1.2Button</h4><p> android:textAllCaps  :自动大小写转换开关</p><p>实现点击事件监听的两种方法，1：实现View.OnClickListener 接口 ，2 使用匿名类的方式。</p><h4 id="3-1-3EditText"><a href="#3-1-3EditText" class="headerlink" title="3.1.3EditText"></a>3.1.3EditText</h4><p>android:hint ：指定了一段提示性的文本。</p><p>android:maxLines： 指定 EditText 的最大行数 </p><h4 id="3-1-3ImageView"><a href="#3-1-3ImageView" class="headerlink" title="3.1.3ImageView"></a>3.1.3ImageView</h4><p>android:src ：指定一张图片。</p><h4 id="3-1-4ProgressBar"><a href="#3-1-4ProgressBar" class="headerlink" title="3.1.4ProgressBar"></a>3.1.4ProgressBar</h4><p> android:visibility  ：所有控件都有， visible（可见）、invisible（不可见、透明、占地） 和 gone（不可见、不占地）。</p><p> style：指定成进度条形式。</p><p> android:max ：给进度条设置一个最大值    </p><h4 id="3-1-5AlertDialog"><a href="#3-1-5AlertDialog" class="headerlink" title="3.1.5AlertDialog"></a>3.1.5AlertDialog</h4><p>AlertDialog.Builder创建一个 AlertDialog 的实例，设置标题、 内容、可否用 Back 键关闭对话框，接下来调用 setPositiveButton()、setNegativeButton()方法设置按钮的点击事件，最后调用 show()方法。     </p><h4 id="3-1-6ProgressDialog"><a href="#3-1-6ProgressDialog" class="headerlink" title="3.1.6ProgressDialog"></a>3.1.6ProgressDialog</h4><p>ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时。它的用法和 AlertDialog 也比较相似。（ setCancelable()中传入 false，表示 ProgressDialog 是不能通过 Back 键取消掉的，当数据加载完成后必须要调用 ProgressDialog 的 dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。）  </p><h3 id="3-2四种布局"><a href="#3-2四种布局" class="headerlink" title="3.2四种布局"></a>3.2四种布局</h3><h4 id="3-2-1LinearLayout"><a href="#3-2-1LinearLayout" class="headerlink" title="3.2.1LinearLayout"></a>3.2.1LinearLayout</h4><p>android:layout_gravity ：用于指定控件在布局中的对齐方式。  </p><p>android:layout_weight：使用比例的方式来指定控件的大小，两个控件宽度为0，将weight属性的值指定为1，这表示两个控件将在水平方向平分宽度。  </p><h4 id="3-2-2RelativeLayout"><a href="#3-2-2RelativeLayout" class="headerlink" title="3.2.2RelativeLayout"></a>3.2.2RelativeLayout</h4><p>通过相对定位的方式让控件出现在布局的任何位置。</p><p>android:layout_alignParentLeft： 和父布局的左对齐  </p><p>android:layout_alignParentTop：上</p><p>android:layout_alignParentRight ：和父布局的右对齐  </p><p>android:layout_ alignParentBottom：下</p><p>android:layout_centerInParent  ：居中 </p><p> android:layout_above ：让一个控件位于另一个控件的上方 ，id引用</p><p> android:layout_toLeftOf  ：控件位于另一个控件的左侧，同理还有右侧</p><p> android:layout_alignLeft ：让一个控件的左边缘和另一个控件的左边缘对齐 ，同理还有上下右侧。</p><h4 id="3-2-3FrameLayout"><a href="#3-2-3FrameLayout" class="headerlink" title="3.2.3FrameLayout"></a>3.2.3FrameLayout</h4><p>所有的控件都会默认摆放在布局的左上角。  </p><h4 id="3-2-4PercentFrameLayout"><a href="#3-2-4PercentFrameLayout" class="headerlink" title="3.2.4PercentFrameLayout"></a>3.2.4PercentFrameLayout</h4><p>允许直接指 定控件在布局中所占的百分比。</p><p>百分比布局只为 FrameLayout 和 RelativeLayout 进行了功能扩展，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局。</p><h3 id="3-3-布局进阶"><a href="#3-3-布局进阶" class="headerlink" title="3.3 布局进阶"></a>3.3 布局进阶</h3><h4 id="3-3-1引入布局"><a href="#3-3-1引入布局" class="headerlink" title="3.3.1引入布局"></a>3.3.1引入布局</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">layout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@layout/title<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-3-2自定义控件"><a href="#3-3-2自定义控件" class="headerlink" title="3.3.2自定义控件"></a>3.3.2自定义控件</h4><p>新建 TitleLayout 继承自 LinearLayout，让它成为我们自定义的标题栏控件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TitleLayout extends LinearLayout {    public TitleLayout(Context context, AttributeSet attrs) {    super(context, attrs);    LayoutInflater.from(context).inflate(R.layout.title, this);    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重写LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout 控件就会调用这个构造函数。借助 LayoutInflater 来实现对标题栏布局进行动态加载。通过from()方法可以构建出一个 LayoutInflater 对象，然后调用 inflate()方法就可以动态加载一个布局文件，inflate()方法接收两个参数，第 一个参数是要加载的布局文件的 id，这里我们传入 R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里指定为 TitleLayout，直接传入this。  </p><p>接着在布局中插入我们的自定义控件。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.example.uicustomviews.TitleLayout</span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对控件的具体处理逻辑在TitleLayout中编写。</p><h4 id="3-4ListView"><a href="#3-4ListView" class="headerlink" title="3.4ListView"></a>3.4ListView</h4><h4 id="3-4-1基础"><a href="#3-4-1基础" class="headerlink" title="3.4.1基础"></a>3.4.1基础</h4><p>首先在布局中加入 ListView 控件 ，指定id、宽度、高度。在MainActivity中新建一个ListView实例并为其添加适配器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1, data);ListView listView = (ListView) findViewById(R.id.list_view);listView.setAdapter(adapter); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在ArrayAdapter 的构造函数中依次传入当前上下文、 ListView 子项布局的 id，以及要适配的数据。android.R.layout.simple_ list_item_1 作为 ListView 子项布局的 id，是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。  </p><h4 id="3-4-2进阶"><a href="#3-4-2进阶" class="headerlink" title="3.4.2进阶"></a>3.4.2进阶</h4><p>新建一个Fruit类包括名称和图片ID，创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public FruitAdapter(Context context, int textViewResourceId,    List&lt;Fruit&gt; objects) {    super(context, textViewResourceId, objects);    resourceId = textViewResourceId;} @Overridepublic View getView(int position, View convertView, ViewGroup parent) {    Fruit fruit = getItem(position); // 获取当前项的 Fruit 实例    View view = LayoutInflater.from(getContext()).inflate(resourceId, parent,        false);    ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);    TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);    fruitImage.setImageResource(fruit.getImageId());    fruitName.setText(fruit.getName());    return view; } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据都传递进来。另外又重写了 getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView()方法中，首先通过 getItem()方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。 这里 LayoutInflater 的 inflate()方法接收 3 个参数，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了。  </p><h3 id="3-5RecycleView适配器"><a href="#3-5RecycleView适配器" class="headerlink" title="3.5RecycleView适配器"></a>3.5RecycleView适配器</h3><h4 id="3-5-1适配器定义"><a href="#3-5-1适配器定义" class="headerlink" title="3.5.1适配器定义"></a>3.5.1适配器定义</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; {     private List&lt;Fruit&gt; mFruitList;         static class ViewHolder extends RecyclerView.ViewHolder {     ImageView fruitImage;     TextView fruitName;     public ViewHolder(View view) {         super(view);         fruitImage = (ImageView) view.findViewById(R.id.fruit_image);         fruitName = (TextView) view.findViewById(R.id.fruit_name);         }    }     public FruitAdapter(List&lt;Fruit&gt; fruitList) {     mFruitList = fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {     View view = LayoutInflater.from(parent.getContext())         .inflate(R.layout.fruit_item, parent, false);     ViewHolder holder = new ViewHolder(view);     return holder; } @Override public void onBindViewHolder(ViewHolder holder, int position) {     Fruit fruit = mFruitList.get(position);     holder.fruitImage.setImageResource(fruit.getImageId());     holder.fruitName.setText(fruit.getName()); } @Override public int getItemCount() {     return mFruitList.size(); }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这里首先定义了一个内部类 ViewHolder，ViewHolder 要继承自 RecyclerView.ViewHolder。然后 ViewHolder 的构造函数中要传入一个 View 参数，这个参数通常就是 RecyclerView 子项。我们就可以通过 findViewById()方法来获取到布局中的 ImageView 和 TextView 的实例了。 FruitAdapter 中也有一个构造函数，这个方法用于把要展示的数据源传进来， 并赋值给一个全局变量 mFruitList，我们后续的操作都将在这个数据源的基础上进行。</p><p>由于 FruitAdapter 是继承自 RecyclerView.Adapter 的，那么就必须重写 onCreateViewHolder()、onBindViewHolder()和 getItemCount()这 3 个方法。</p><p>onCreateViewHolder()方法是用于创建 ViewHolder 实例的，在这个方法中将 fruit_item 布局加载进来，然后创建一个 ViewHolder 实例，并把加载出来的布局传入到构造函数当中，最后将 ViewHolder 的实例返回。</p><p>onBindViewHolder()方法是用于对RecyclerView 子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过 position 参数得到当前项的 Fruit 实例，然后再将数据设置到 ViewHolder 的 ImageView 和 TextView 当中即可。</p><p>getItemCount() 用于告诉 RecyclerView 一共有多少子项，直接返回数据源的长度就可以了。  </p><h4 id="3-5-2在MainActivity中调用："><a href="#3-5-2在MainActivity中调用：" class="headerlink" title="3.5.2在MainActivity中调用："></a>3.5.2在MainActivity中调用：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);LinearLayoutManager layoutManager = new LinearLayoutManager(this);recyclerView.setLayoutManager(layoutManager);FruitAdapter adapter = new FruitAdapter(fruitList);recyclerView.setAdapter(adapter); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先获取到 RecyclerView 的实例，然后创建了一个 LinearLayoutManager 对象，并将它设置到 RecyclerView 当中。LayoutManager 用于指定 RecyclerView 的布局方式，这里使用的 LinearLayoutManager 是线性布局，可以实现和 ListView 类似的效果。 接下来创建了 FruitAdapter 的实例，并将水果数据传入到 FruitAdapter 的构造函数中，最后调用 RecyclerView 的 setAdapter()方法来完成适配器设置，这样 RecyclerView 和数据之间的关联就建立完成了。  </p><h4 id="3-5-3点击事件"><a href="#3-5-3点击事件" class="headerlink" title="3.5.3点击事件"></a>3.5.3点击事件</h4><p>RecyclerView 并没有提供类似于 setOnItemClickListener() 这样的注册监听器方法，而是需要自己给子项具体的View 去注册点击事件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; {     private List&lt;Fruit&gt; mFruitList;     static class ViewHolder extends RecyclerView.ViewHolder {     View fruitView;     ImageView fruitImage;     TextView fruitName;     public ViewHolder(View view) {         super(view);                  fruitImage = (ImageView) view.findViewById(R.id.fruit_image);         fruitName = (TextView) view.findViewById(R.id.fruit_name);         }    }     public FruitAdapter(List&lt;Fruit&gt; fruitList) {     mFruitList = fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {     View view = LayoutInflater.from(parent.getContext())         .inflate(R.layout.fruit_item, parent, false);     final ViewHolder holder = new ViewHolder(view);     holder.fruitView.setOnClickListener(new View.OnClickListener() {         @Override         public void onClick(View v) {             int position = holder.getAdapterPosition();             Fruit fruit = mFruitList.get(position);             Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(),                 Toast.LENGTH_SHORT).show();         }     });      return holder; } @Override public void onBindViewHolder(ViewHolder holder, int position) {} @Override public int getItemCount() {}} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先修改ViewHolder，在 ViewHolder 中添加了 fruitView 变量来保存子项最外层布局的实例，然后在onCreateViewHolder()方法中注册点击事件。这里为最外层布局注册了点击事件，RecyclerView 的强大之处也在这里，它可以轻松实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的 position，然后通过 position 拿到相应的 Fruit 实例，再使用 Toast 分别弹出两种不同的内容以示区别。  </p><h2 id="Chap4-碎片"><a href="#Chap4-碎片" class="headerlink" title="Chap4-碎片"></a>Chap4-碎片</h2><h3 id="4-1碎片使用"><a href="#4-1碎片使用" class="headerlink" title="4.1碎片使用"></a>4.1碎片使用</h3><h4 id="4-1-1简单用法"><a href="#4-1-1简单用法" class="headerlink" title="4.1.1简单用法"></a>4.1.1简单用法</h4><p>先新建左右两侧碎片布局， left_fragment.xml、right_fragment.xml。再分别建两个碎片类 LeftFragment、RightFragment继承Fragment类。</p><p>重写父类方法加载刚刚的布局。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container,    Bundle savedInstanceState) {    View view = inflater.inflate(R.layout.left_fragment, container, false);    return view;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主活动界面中添加两个fragment控件。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fragment</span> <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/left_fragment<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.fragmenttest.LeftFragment<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0dp<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>layout_weight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2动态添加碎片"><a href="#4-1-2动态添加碎片" class="headerlink" title="4.1.2动态添加碎片"></a>4.1.2动态添加碎片</h4><ol><li> 创建待添加的碎片实例。  </li><li> 获取FragmentManager，在活动中可以直接通过调用 getSupportFragmentManager()方法得到。  </li><li> 开启一个事务，通过调用 beginTransaction()方法开启。  </li><li> 向容器内添加或替换碎片，一般使用 replace()方法实现，需要传入容器的 id 和待添加的碎片实例。  </li><li> 提交事务，调用 commit()方法来完成。  </li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void replaceFragment(Fragment fragment) {    FragmentManager fragmentManager = getSupportFragmentManager();    FragmentTransaction transaction = fragmentManager.beginTransaction();    transaction.replace(R.id.right_layout, fragment);    transaction.commit();    //碎片中模拟返回栈    transaction.addToBackStack(null);}FragmentManager fragmentManager = getSupportFragmentManager();fragmentManager.beginTransaction()    .replace(R.id.fragment_container, ExampleFragment.class, null)    .setReorderingAllowed(true)    .addToBackStack("name") // name can be null    .commit();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>addToBackStack()方法，它可以接收一个名字用于描述返回栈的状态，一般传入 null 即可。  </p><p>Each FragmentTransaction should use setReorderingAllowed(true)</p><h4 id="4-1-3碎片与活动间通信"><a href="#4-1-3碎片与活动间通信" class="headerlink" title="4.1.3碎片与活动间通信"></a>4.1.3碎片与活动间通信</h4><p>调用 FragmentManager 的 findFragmentById()方法，可以在活动中得到相应碎片的实例， 然后就能调用碎片里的方法。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">RightFragment rightFragment = (RightFragment) getSupportFragmentManager() .findFragmentById(R.id.right_fragment);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在每个碎片中都可以通过调用 getActivity()方法来得到和当前碎片相关联的活动实例。 ( 活动本身就是一个 Context 对象。  )</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">MainActivity activity = (MainActivity) getActivity();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找现有-fragment"><a href="#查找现有-fragment" class="headerlink" title="查找现有 fragment"></a>查找现有 fragment</h3><p>可以使用 findFragmentById() 获取对布局容器中当前 fragment 的引用。从 XML 扩充时，可使用 findFragmentById() 按给定的 ID 查找 fragment；在 FragmentTransaction 中添加时，可使用它按容器 ID 进行查找。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ExampleFragment fragment = (ExampleFragment) fragmentManager.findFragmentById(R.id.fragment_container);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以为 fragment 分配一个唯一的标记，并使用 findFragmentByTag() 获取引用。可以在布局中定义的 fragment 上使用 android:tag属性来分配标记，也可以在 FragmentTransaction 中的 add() 或 replace() 操作期间分配标记。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FragmentManager fragmentManager = getSupportFragmentManager();fragmentManager.beginTransaction()    .replace(R.id.fragment_container, ExampleFragment.class, null, "tag")    .setReorderingAllowed(true)    .addToBackStack(null)    .commit();...ExampleFragment fragment = (ExampleFragment) fragmentManager.findFragmentByTag("tag");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有关子-fragment-和同级-fragment-的特殊注意事项"><a href="#有关子-fragment-和同级-fragment-的特殊注意事项" class="headerlink" title="有关子 fragment 和同级 fragment 的特殊注意事项"></a>有关子 fragment 和同级 fragment 的特殊注意事项</h3><p>在任何给定的时间点，只允许一个 FragmentManager 控制 fragment 返回堆栈。如果应用在屏幕上同时显示多个同级 fragment，或者应用使用子 fragment，则必须指定一个 FragmentManager 来处理应用的主要导航。</p><p>如需在 fragment 事务内定义主要导航 fragment，请对事务调用 <a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/FragmentTransaction#setPrimaryNavigationFragment(androidx.fragment.app.Fragment)">setPrimaryNavigationFragment()</a> 方法，并传入一个 fragment 的实例，该 fragment 的 childFragmentManager 应具有主要控制权。</p><p>将导航结构视为一系列层，其中 activity 作为最外层，封装下面的每一层子 fragment。每一层都必须有一个主要导航 fragment。当发生返回事件时，最内层控制导航行为。一旦最内层再也没有可从其弹回的 fragment 事务，控制权就会向外回一层，此过程会一直重复，直至到达 activity 为止。</p><p>请注意，当同时显示两个或更多 fragment 时，其中只有一个可以是主要导航 fragment。如果将某个 fragment 设为主要导航 fragment，会移除对先前 fragment 的指定。如果将详情 fragment 设为主要导航 fragment，就会移除对主 fragment 的指定。</p><h3 id="支持多个返回堆栈"><a href="#支持多个返回堆栈" class="headerlink" title="支持多个返回堆栈"></a>支持多个返回堆栈</h3><p>使用 addToBackStack() 提交 FragmentTransaction，从而将 fragment 添加到返回堆栈：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">supportFragmentManager.beginTransaction()  .replace(R.id.fragment_container, ExampleFragment.class, null)  // setReorderingAllowed(true) and the optional string argument for  // addToBackStack() are both required if you want to use saveBackStack().  .addToBackStack("replacement")  .commit();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，可以通过调用 saveState() 来保存此 fragment 事务和 ExampleFragment 的状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">supportFragmentManager.saveBackStack("replacement");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用相同的名称参数调用 restoreBackStack()，以恢复所有弹出的事务以及所有保存的 fragment 状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">supportFragmentManager.restoreBackStack("replacement");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2碎片生命周期"><a href="#4-2碎片生命周期" class="headerlink" title="4.2碎片生命周期"></a>4.2碎片生命周期</h3><ul><li> onAttach()。当碎片和活动建立关联的时候调用。  </li><li> onCreateView()。为碎片创建视图（加载布局）时调用。  </li><li> onActivityCreated()。确保与碎片相关联的活动一定已经创建完毕的时候调用。 </li><li> onDestroyView()。当与碎片关联的视图被移除的时候调用。</li><li> onDetach()。当碎片和活动解除关联的时候调用。     </li></ul><h2 id="Chap5-广播"><a href="#Chap5-广播" class="headerlink" title="Chap5-广播"></a>Chap5-广播</h2><h3 id="5-1接收广播"><a href="#5-1接收广播" class="headerlink" title="5.1接收广播"></a>5.1接收广播</h3><p>注册广播的方式一般有两种，在代码中注册和在 AndroidManifest.xml 中注册，其中前者也被称为动态注册，后者也被称为静态注册。  </p><h4 id="5-1-1动态注册监听"><a href="#5-1-1动态注册监听" class="headerlink" title="5.1.1动态注册监听"></a>5.1.1动态注册监听</h4><p>新建一个类，让它继承自 BroadcastReceiver，并重写父类的 onReceive()方法就行了。这样当有广播到来时，onReceive()方法会被执行， 具体的逻辑就可以在这个方法中处理。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private NetworkChangeReceiver networkChangeReceiver;class NetworkChangeReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        //处理逻辑    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的类用来监听网络变化。</p><p>在onCreate（）中添加广播值设置IntentFilter</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">intentFilter = new IntentFilter();intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");networkChangeReceiver = new NetworkChangeReceiver();registerReceiver(networkChangeReceiver, intentFilter); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建一个 IntentFilter 的实例，给它添加一个值为 android.net.conn.CONNECTIVITY_CHANGE 的 action，当网络状态发生变化时，系统广播的值就是android.net.conn.CONNECTIVITY_CHANGE ，广播接收器想要监听什么广播，就在这里添加相应的 action。接下来创建了NetworkChangeReceiver 的实例，然后调用 registerReceiver()方法进行注册，将 NetworkChangeReceiver 的实例和 IntentFilter 的实例都传进去，这样 NetworkChangeReceiver 就会收到所有值为 android.net.conn.CONNECTIVITY_CHANGE 的广播。最后需要在onDestroy()取消注册广播。  </p><p>更进一步判断是否有网</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic void onReceive(Context context, Intent intent) {    ConnectivityManager connectionManager = (ConnectivityManager)    getSystemService(Context.CONNECTIVITY_SERVICE);    NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo();    if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) {        Toast.makeText(context, "network is available",Toast.LENGTH_SHORT).show();    } else {        Toast.makeText(context, "network is unavailable",Toast.LENGTH_SHORT).show();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 getSystemService()方法得到了 ConnectivityManager 的实例，这是一个系统服务类，专门用于管理网络连接的。然后调用它的 getActiveNetworkInfo()方法可以得到 NetworkInfo 的实例，接着调用 NetworkInfo 的 isAvailable()方法， 就可以判断出当前是否有网络了，最后通过 Toast 的方式对用户进行提示。  </p><p><strong>(<strong><strong>注意权限问题</strong></strong>)</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//网络权限<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.permission.ACCESS_NETWORK_STATE<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> //开机广播权限<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>uses-permission</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.permission.RECEIVE_BOOT_COMPLETED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-1-2静态注册"><a href="#5-1-2静态注册" class="headerlink" title="5.1.2静态注册"></a>5.1.2静态注册</h4><p> 可以让程序在未启动的情况下就能接收到广播 。通过右键New→Other→Broadcast Receiver  创建广播接收器。</p><p>这样会自动在 AndroidManifest.xml 文件中注册 ，然后我们可以在<receiver>中添加相应的action。</receiver></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>receiver</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>android.intent.action.BOOT_COMPLETED<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>receiver</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2发送自定义广播"><a href="#5-2发送自定义广播" class="headerlink" title="5.2发送自定义广播"></a>5.2发送自定义广播</h3><h4 id="5-2-1标准广播"><a href="#5-2-1标准广播" class="headerlink" title="5.2.1标准广播"></a>5.2.1标准广播</h4><p>在发送广播之前，需要先定义一个广播接收器来准备接收此广播。接着在  AndroidManifest.xml里的<receiver>中添加相应的action。接着在主活动中发广播。</receiver></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST");sendBroadcast(intent);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-2-2有序广播"><a href="#5-2-2有序广播" class="headerlink" title="5.2.2有序广播"></a>5.2.2有序广播</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">sendOrderedBroadcast(intent, null); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 第二个参数是一个与权限相关的字符串，传入null就行。因为是有序广播，所以可以在 AndroidManifest.xml里的<receiver>中设置优先级。</receiver></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span> <span class="token attr-name"><span class="token namespace">android:</span>priority</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样第一个接受的接收器可以设置是否允许广播继续传递。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//截断方法abortBroadcast();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-3本地广播"><a href="#5-3本地广播" class="headerlink" title="5.3本地广播"></a>5.3本地广播</h3><p>本地广播发出的广播只能够在应用程序的内部进行传递，广播接收器也只能接收来自本应用程序发出的广播。</p><p>实现是通过使用了一个 LocalBroadcastManager 来对广播进行管理， 并提供了发送广播和注册广播接收器的方法。    </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private LocalBroadcastManager localBroadcastManager;    @Override    protected void onCreate(Bundle savedInstanceState) {        localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例        Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");        localBroadcastManager.sendBroadcast(intent); // 发送本地广播        intentFilter = new IntentFilter();        intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");        localReceiver = new LocalReceiver();        localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器 } class LocalReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和上面的动态注册广播差距不大，只不过变成了LocalBroadcastManager 来管理。</p><h2 id="Chap6-数据存储"><a href="#Chap6-数据存储" class="headerlink" title="Chap6-数据存储"></a>Chap6-数据存储</h2><h3 id="6-1文件存储"><a href="#6-1文件存储" class="headerlink" title="6.1文件存储"></a>6.1文件存储</h3><h4 id="6-1-1将数据存储到文件中"><a href="#6-1-1将数据存储到文件中" class="headerlink" title="6.1.1将数据存储到文件中"></a>6.1.1将数据存储到文件中</h4><p>Context 类中提供了一个 openFileOutput()方法，可以用于将数据存储到指定的文件中。 这个方法接收两个参数，第一个参数是文件名，指定的文件名不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下的。第二个参数是文件的操作模式，MODE_PRIVATE、 MODE_APPEND。</p><p>MODE_PRIVATE 是默认的操作模式，表示当指定同样文件名的时候， 写入的内容会覆盖原文件中内容。 MODE_APPEND 则表示如果该文件已存在，则追加内容，不存在就创建新文件。</p><p>openFileOutput ()方法返回的是一个 FileOutputStream 对象，得到了这个对象之后就 可以使用 Java 流的方式将数据写入到文件中。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void save() {    String data = "Data to save";    FileOutputStream out = null;    BufferedWriter writer = null;    try {        out = openFileOutput("data", Context.MODE_PRIVATE);        writer = new BufferedWriter(new OutputStreamWriter(out));        writer.write(data);    } catch (IOException e) {        e.printStackTrace();    } finally {        try {            if (writer != null) {            writer.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-1-2从文件中读数据"><a href="#6-1-2从文件中读数据" class="headerlink" title="6.1.2从文件中读数据"></a>6.1.2从文件中读数据</h4><p>Context 类中提供openFileInput()方法。它只接收一个参数，即文件名，然后系统会自动到/data/data//files/目录下去加载这个文件，并返回一个 FileInputStream 对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String load() {    FileInputStream in = null;    BufferedReader reader = null;    StringBuilder content = new StringBuilder();    try {        in = openFileInput("data");        reader = new BufferedReader(new InputStreamReader(in));        String line = "";        while ((line = reader.readLine()) != null) {            content.append(line);        }    } catch (IOException e) {        e.printStackTrace();    } finally {        if (reader != null) {            try {                reader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    return content.toString();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-SharedPreferences-存储"><a href="#6-2-SharedPreferences-存储" class="headerlink" title="6.2 SharedPreferences 存储"></a>6.2 SharedPreferences 存储</h3><p> SharedPreferences 是使用键值对的方式来存储数据。获取对象有三种方法</p><ol><li> <strong>Context 类中的 getSharedPreferences()方法</strong>  </li></ol><p> 方法接收两个参数，第一个参数用于指定 SharedPreferences 文件的名称，如果指定的文件不存在则会创建，SharedPreferences 文件都是存放/data/data//shared_prefs/ 目录下的。第二个参数用于指定操作模式，目前只有 MODE_PRIVATE 这一种模式可选，它是默认的操作模式，和直接传入 0 效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences 文件进行读写。</p><ol><li> <strong>Activity 类中的 getPreferences()方法</strong></li></ol><p> Context 中的 getSharedPreferences()方法相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的类名作为 SharedPreferences 的文件名。  </p><ol><li> <strong>PreferenceManager 类中的 getDefaultSharedPreferences()方法</strong>     </li></ol><p> 是一个静态方法，接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。  </p><h4 id="6-2-1存储数据步骤："><a href="#6-2-1存储数据步骤：" class="headerlink" title="6.2.1存储数据步骤："></a>6.2.1存储数据步骤：</h4><p> (1) 调用 SharedPreferences 对象的 edit()方法来获取一个 SharedPreferences.Editor 对象。</p><p> (2) 向 SharedPreferences.Editor 对象中添加数据，添加一个布尔型数据就使用 putBoolean()方法以此类推。</p><p> (3) 调用 apply()方法将添加的数据提交，从而完成数据存储操作。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SharedPreferences.Editor editor = getSharedPreferences("data",MODE_PRIVATE).edit();editor.putString("name", "Tom");editor.putInt("age", 28);editor.putBoolean("married", false);editor.apply();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2-2读数据"><a href="#6-2-2读数据" class="headerlink" title="6.2.2读数据"></a>6.2.2读数据</h4><p>SharedPreferences 对象中 提供了一系列的 get 方法，用于对存储的数据进行读取。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SharedPreferences pref = getSharedPreferences("data", MODE_PRIVATE);String name = pref.getString("name", "");int age = pref.getInt("age", 0);boolean married = pref.getBoolean("married", false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3SQLite数据库存储"><a href="#6-3SQLite数据库存储" class="headerlink" title="6.3SQLite数据库存储"></a>6.3SQLite数据库存储</h3><p> Android提供了SQLiteOpenHelper帮助类， 借助这个类就可以非常简单地对数据库进行创建和升级。  </p><p>其中还有两个重要的实例方法：getReadableDatabase()和 getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。  </p><p>构造方法一般选择参数比较少的那个。 第一个参数是 Context。第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。第三个参数允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入 null。第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。  </p><h4 id="6-3-1使用SQLiteOpenHelper构建数据库："><a href="#6-3-1使用SQLiteOpenHelper构建数据库：" class="headerlink" title="6.3.1使用SQLiteOpenHelper构建数据库："></a>6.3.1使用SQLiteOpenHelper构建数据库：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyDatabaseHelper extends SQLiteOpenHelper {    //建表语句    public static final String CREATE_BOOK = "create table Book ("            + "id integer primary key autoincrement,"            + "author text,"            + "price real,"            + "pages integer,"            + "name text)";    //建表语句    public static final String CREATE_CATEGORY = "create table Category ("            + "id integer primary key autoincrement, "            + "category_name text, "            + "category_code integer)";    private Context mContext;    public MyDatabaseHelper(Context context, String name,                            SQLiteDatabase.CursorFactory factory,                            int version) {        super(context, name, factory, version);        mContext = context;    }    @Override    public void onCreate(SQLiteDatabase db) {        db.execSQL(CREATE_BOOK);        db.execSQL(CREATE_CATEGORY);        Toast.makeText(mContext, "Create succeeded",                Toast.LENGTH_SHORT).show();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-3-2升级数据库"><a href="#6-3-2升级数据库" class="headerlink" title="6.3.2升级数据库"></a>6.3.2升级数据库</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {        db.execSQL("drop table if exists Book");        db.execSQL("drop table if exists Category");        onCreate(db);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每一次对数据库升级都需要更改构造方法中的第四个参数，就是版本号的更新。</p><h4 id="6-3-3添加数据"><a href="#6-3-3添加数据" class="headerlink" title="6.3.3添加数据"></a>6.3.3添加数据</h4><p>SQLiteDatabase 中提供了insert()方法用于添加数据。它接收 3 个参数，第一个参数是表名。第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL，一直接传入 null 即可。第三个参数是一个 ContentValues 对象，它提供了一系列的 put()方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues(); // 开始组装第一条数据values.put("name", "The Da Vinci Code");values.put("author", "Dan Brown");values.put("pages", 454);values.put("price", 16.96);db.insert("Book", null, values); // 插入第一条数据values.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-3-4更新数据"><a href="#6-3-4更新数据" class="headerlink" title="6.3.4更新数据"></a>6.3.4更新数据</h4><p>SQLiteDatabase 中提供 update()方法用于对数据进行更新，这个方法接收 4 个参数，第一个参数是表名。第 二个参数是 ContentValues 对象，要把更新数据在这里组装进去。第三、第四个参数用于约束 更新某一行或某几行中的数据，不指定的话默认就是更新所有行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SQLiteDatabase db = dbHelper.getWritableDatabase();ContentValues values = new ContentValues();values.put("price",10.99);db.update("Book",values,"name = ?",new String[] {"The Da Vinco Code"});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-4-4删除数据"><a href="#6-4-4删除数据" class="headerlink" title="6.4.4删除数据"></a>6.4.4删除数据</h4><p>SQLiteDatabase 中提供delete()方法用于删除数据，这个方法接收 3 个参数， 第一个参数是表名， 第二、第三个参数又是用于约束删除某一行 或某几行的数据，不指定的话默认就是删除所有行。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">QLiteDatabase db = dbHelper.getWritableDatabase();db.delete("Book","pages &gt; ?",new String[]{"500"});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="6-4-5查询数据"><a href="#6-4-5查询数据" class="headerlink" title="6.4.5查询数据"></a>6.4.5查询数据</h4><p>SQLiteDatabase 提供 query()方法用于对数据进行查询。需要传入 7 个参数。第一个参数是表名。第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列。第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据。第五个参数用于指定需要去group by 的列，不指定则表示不对查询结果进行 group by 操作。第六个参数用于对 group by 之后的数据进行进一步的过滤，不指定则表示不进行过滤。第七个参数用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SQLiteDatabase db = dbHelper.getWritableDatabase();Cursor cursor = db.query("Book",null,null,null,null,null,null);if (cursor.moveToFirst()){    do {        //遍历Cursor对象，逐条打印        String name = cursor.getString(cursor.getColumnIndexOrThrow("name"));        String author = cursor.getString(cursor.getColumnIndexOrThrow("author"));        int pages = cursor.getInt(cursor.getColumnIndexOrThrow("pages"));        double price = cursor.getDouble(cursor.getColumnIndexOrThrow("pages"));    }while (cursor.moveToNext());}cursor.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询完之后就得到了一个 Cursor 对象，接着我 moveToFirst()方法将数据的指针移动到第一行，然后循环，遍历查询到的每一行数据。循环中可以通过 Cursor 的 getColumnIndex()方法获取到某一列在表中对应的位置索引，然后将索引传入到相应的取值方法中，就可以得到从数据库中读取到的数据了。  </p><h3 id="6-5LitePal"><a href="#6-5LitePal" class="headerlink" title="6.5LitePal"></a>6.5LitePal</h3><p>LitePal 是一款开源的 Android 数据库框架，采用了对象关系映射（ORM）的模式，并将平时开发最常用到的一些数据库功能进行了封装。</p><p><strong>build.gradle配置：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">implementation 'org.litepal.guolindev:core:3.2.3'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是会出现assets文件夹，litepal的配置文件就在里面。</p><p><strong>还要在 AndroidManifest.xml中配置：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">android:name="org.litepal.LitePalApplication"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-5-1创建升级数据库"><a href="#6-5-1创建升级数据库" class="headerlink" title="6.5.1创建升级数据库"></a>6.5.1创建升级数据库</h4><p>定义一个类（Java Bean形式），并实现getter、setter方法。接下来将类映射到模型列表中。使用<mapping> 标签来声明我们要配置的映射模型类 。下载可以直接创建数据库。</mapping></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LitePal.getDatabase();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时如果想添加一个新表或者增加字段，可以直接在类中加入属性和创建一个新的类，并重新运行程序。</p><h4 id="6-5-2添加数据"><a href="#6-5-2添加数据" class="headerlink" title="6.5.2添加数据"></a>6.5.2添加数据</h4><p> 添加数据只需要创建出模型类的实例，再将所有要存储的数据设置好，最后调用一下 save()方法就可以了。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Book book = new Book();book.setName("The Da Vinci Code");book.setAuthor("Dan Brown");book.setPages(454);book.setPrice(16.96);//book.setPress("Unknown");book.save();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-5-3更新数据"><a href="#6-5-3更新数据" class="headerlink" title="6.5.3更新数据"></a>6.5.3更新数据</h4><p>方式：将已存储的对象重新设值，然后重新调用 save()方法。</p><p>对于 LitePal 来说，对象是否已存储就是根据调用 model.isSaved()方法的结果来判断的， 返回 true 就表示已存储，返回 false 就表示未存储。  </p><p>两种情况下会返回true：一种情况是已经调用过 model.save()方法去添加数据了，此时 model会被认为是已存储的对象。另一种情况是 model 对象是通过 LitePal 提供的查询 API 查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象。   </p><p>但上述方式只会改变已存储对象，有限制，所以使用另一种方式; updateAll()方法。 updateAll()方法中可以指定一个条件约束，如果不指定条件语句的话，就表示更新所有数据。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">book.setPress("Anchor");book.updateAll("name = ? and author = ?", "The Lost Symbol", "DanBrown"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>想将数据设置为默认值：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Book book = new Book();book.setToDefault("pages");book.updateAll();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="6-5-4删除数据"><a href="#6-5-4删除数据" class="headerlink" title="6.5.4删除数据"></a>6.5.4删除数据</h4><p>一种方式直接通过delete()删除。第二种是调用DataSupport.deleteAll()方法来删除数据 。 第一个参数用于指定删除哪张表中的数据，后面的参数用于指定约束条件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">DataSupport.deleteAll(Book.class, "price &lt; ?", "15");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-5-5查询数据"><a href="#6-5-5查询数据" class="headerlink" title="6.5.5查询数据"></a>6.5.5查询数据</h4><p><strong>查询全部数据</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Book&gt; books = DataSupport.findAll(Book.class);book.getName();...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>有用的API</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">DataSupport.findFirst(Book.class)            .findLast(Book.class)            .select("name", "author").find(Book.class)            .where("pages &gt; ?", "400").find(Book.class)            .order("price desc").find(Book.class)            .limit(3).find(Book.class)            .limit(3).offset(1).find(Book.class);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chap7-内容提供器"><a href="#Chap7-内容提供器" class="headerlink" title="Chap7-内容提供器"></a>Chap7-内容提供器</h2><p>用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性， 内容提供器可以选 择只对哪一部分数据进行共享。  </p><h3 id="7-1运行时权限"><a href="#7-1运行时权限" class="headerlink" title="7.1运行时权限"></a>7.1运行时权限</h3><h4 id="7-1-1运行时申请"><a href="#7-1-1运行时申请" class="headerlink" title="7.1.1运行时申请"></a>7.1.1运行时申请</h4><p><strong>申请流程：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断权限并申请if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {    ActivityCompat.requestPermissions(MainActivity.this, new    String[]{ Manifest.permission.CALL_PHONE }, 1);}//回调函数@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions,int[] grantResults) {    switch (requestCode) {        case 1:            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {            call();//逻辑方法            } else {                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show();                }        break;    default:    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 第一步就是要先判断用户是不是已经授权了，借助 ContextCompat.checkSelfPermission()方法。方法接收两个参数， 第一个参数是 Context，第二个参数是具体的权限名，然后使用方法的返回值和 PackageManager. PERMISSION_GRANTED 做比较，相等就说明用户已经授权，不等就表示用户没有授权。 </p><p>如果已经授权直接去执行逻辑操作。如果没有授权的话，则需要调用 ActivityCompat. requestPermissions()方法来向用户申请授权。</p><p>requestPermissions()方法接收 3 个参数， 第一个参数要求是 Activity 的实例，第二个参数是一个 String 数组，我们把要申请的权限名放在数组中，第三个参数是请求码，只要是唯一值就可以了，这里传入了 1。 </p><p>调用requestPermissions()方法之后，系统会弹出一个权限申请的对话框，用户可以选择同意或拒绝，不论是哪种结果，最终都会回调到 onRequestPermissionsResult()方法中，而授权的结果则会封装在 grantResults参数当中。这里只需要判断一下最后的授权结果，如果用户同意的话就执行逻辑操作，如果用户拒绝的话放弃操作并弹出一条失败提示。  </p><h3 id="7-2访问其他程序中的数据"><a href="#7-2访问其他程序中的数据" class="headerlink" title="7.2访问其他程序中的数据"></a>7.2访问其他程序中的数据</h3><h4 id="7-2-1-ContentResolver"><a href="#7-2-1-ContentResolver" class="headerlink" title="7.2.1 ContentResolver"></a>7.2.1 ContentResolver</h4><p>想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，可以通过 Context 中的 getContentResolver()方法获取到该类的实例。ContentResolver 中提供了一系列的方法用于对数据进行 CRUD 操作。  </p><p>ContentResolver 中的增删改查方法是不接收表名参数的，而是使用一个 Uri 参数代替，这个参数被称为内容 URI。内容 URI 给内容提供器中的数据建立了唯一标识符，主要由两部分组成：authority 和 path。</p><p>authority 是用于对不同的应用程序做区分的， 一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个程序的包名是 com.example. app，那么该程序对应的 authority 就可以命名为 com.example.app. provider。path 则是用于对同一 应用程序中不同的表做区分的，通常都会添加到 authority 的后面。比如某个程序的数据库里存在 两张表：table1 和 table2，这时就可以将 path 分别命名为/table1 和/table2，然后把 authority 和 path 进行组合，内容 URI 就变成了 com.example.app.provider/table1 和 com.example.app.provider/table2。</p><p> 不过，目前还很难辨认出这两个字符串就是两个内容 URI，我们还需要在字符串的头部加上协议 声明。因此，内容 URI 最标准的格式写法如下：</p><ul><li>content://com.example.app.provider/table1  </li><li>content://com.example.app.provider/table2  </li></ul><p>内容 URI 的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以 id 结尾就表示期望访问该表中拥有相应 id 的数据。  </p><p>在得到了内容 URI 字符串之后，我们还需要将它解析成 Uri 对象才可以作为参数传入。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Uri uri = Uri.parse("content://com.example.app.provider/table1");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 只需要调用 Uri.parse()方法，就可以将内容 URI 字符串解析成 Uri 对象了。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Cursor cursor = getContentResolver().query(         uri,         projection,         selection,         selectionArgs,         sortOrder); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 查询完成后返回的仍然是一个 Cursor 对象，这时我们就可以将数据从 Cursor 对象中逐个读取出来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while (cursor.moveToNext()) {    String column1 = cursor.getString(cursor.getColumnIndex("column1"));    int column2 = cursor.getInt(cursor.getColumnIndex("column2"));}cursor.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>增加</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ContentValues values = new ContentValues();values.put("column1", "text");getContentResolver().insert(uri, values);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>更新</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ContentValues values = new ContentValues();values.put("column1", "");getContentResolver().update(uri, values, "column1 = ? and column2 = ?", newString[] {"text", "1"}); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">getContentResolver().delete(uri, "column2 = ?", new String[] { "1" });<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7-3创建自己的内容提供器"><a href="#7-3创建自己的内容提供器" class="headerlink" title="7.3创建自己的内容提供器"></a>7.3创建自己的内容提供器</h3><p>可以通过新建一个类去继承 ContentProvider 的方式来创建一个自己的内容提供器。ContentProvider 类中有 6 个抽象方法，在继承它的时候，需要将这 6 个方法全部重写。</p><ol><li> <strong>onCreate()</strong>  </li></ol><p>初始化内容提供器的时候调用。在这里完成对数据库的创建和升级等操作，返回 true 表示内容提供器初始化成功，返回 false 则表示失败。  </p><ol start="2"><li><strong>query()</strong>  </li></ol><p>从内容提供器中查询数据。使用 uri 参数来确定查询哪张表，projection 参数用于确定查询哪些列，selection 和 selectionArgs 参数用于约束查询哪些行，sortOrder 参数用于对结果进行排序，查询的结果存放在 Cursor 对象中返回。  </p><ol start="3"><li><strong>insert()</strong>  </li></ol><p>向内容提供器中添加一条数据。使用 uri 参数来确定要添加到的表，待添加的数据保存在 values 参数中。添加完成后，返回一个用于表示这条新记录的 URI。  </p><ol start="4"><li><strong>update()</strong>  </li></ol><p>更新内容提供器中已有的数据。使用 uri 参数来确定更新哪一张表中的数据，新数据保存在 values 参数中，selection 和 selectionArgs 参数用于约束更新哪些行，受影响的行数将作 为返回值返回。  </p><ol><li> <strong>delete()</strong>  </li></ol><p>从内容提供器中删除数据。使用 uri 参数来确定删除哪一张表中的数据，selection 和 selectionArgs 参数用于约束删除哪些行，被删除的行数将作为返回值返回。  </p><ol start="5"><li><strong>getType()</strong>  </li></ol><p> 根据传入的内容 URI 来返回相应的 MIME 类型。  </p><p><strong>MIME:</strong> 主要由 3 部分组成规则如下：</p><p>必须以 vnd 开头。  </p><p>如果内容 URI 以路径结尾，则后接 android.cursor.dir/，如果内容 URI 以 id 结尾， 则后接 android.cursor.item/。   </p><p> 最后接上 vnd.<authority>.<path>。 </path></authority></p><p>UriMatcher 类就可以实现匹配内容 URI 的功能。UriMatcher 中提供了一个 addURI()方法，这个方法接收 3 个参数，可以分别把 authority、path 和一个自定义代码传进去。当调用 UriMatcher 的 match()方法时，就可以将一个 Uri 对象传入， 返回值是某个能够匹配这个 Uri 对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。 </p><p><strong>自定义代码</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DatabaseProvider extends ContentProvider {    public static final int BOOK_DIR = 0;    public static final int BOOK_ITEM = 1;    public static final int CATEGORY_DIR = 2;    public static final int CATEGORY_ITEM = 3;    public static final String AUTHORITY = "com.example.databasetest.provider";    private static UriMatcher uriMatcher;    private MyDatabaseHelper dbHelper;    static {        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);        uriMatcher.addURI(AUTHORITY, "book", BOOK_DIR);        uriMatcher.addURI(AUTHORITY, "book/#", BOOK_ITEM);        uriMatcher.addURI(AUTHORITY, "category", CATEGORY_DIR);        uriMatcher.addURI(AUTHORITY, "category/#", CATEGORY_ITEM);    }    @Override    public boolean onCreate() {        dbHelper = new MyDatabaseHelper(getContext(), "BookStore.db", null, 2);        return true;    }    @Override    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {        // 查询数据        SQLiteDatabase db = dbHelper.getReadableDatabase();        Cursor cursor = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                cursor = db.query("Book", projection, selection, selectionArgs, null, null, sortOrder);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                cursor = db.query("Book", projection, "id = ?", new String[] { bookId }, null, null, sortOrder);                break;            case CATEGORY_DIR:                cursor = db.query("Category", projection, selection, selectionArgs, null, null, sortOrder);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                cursor = db.query("Category", projection, "id = ?", new String[] { categoryId }, null, null, sortOrder);                break;            default:                break;        }        return cursor;    }    @Override    public Uri insert(Uri uri, ContentValues values) {        // 添加数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        Uri uriReturn = null;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:            case BOOK_ITEM:                long newBookId = db.insert("Book", null, values);                uriReturn = Uri.parse("content://" + AUTHORITY + "/book/" + newBookId);                break;            case CATEGORY_DIR:            case CATEGORY_ITEM:                long newCategoryId = db.insert("Category", null, values);                uriReturn = Uri.parse("content://" + AUTHORITY + "/category/" + newCategoryId);                break;            default:                break;        }        return uriReturn;    }    @Override    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {        // 更新数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int updatedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                updatedRows = db.update("Book", values, selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                updatedRows = db.update("Book", values, "id = ?", new String[] { bookId });                break;            case CATEGORY_DIR:                updatedRows = db.update("Category", values, selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                updatedRows = db.update("Category", values, "id = ?", new String[] { categoryId });                break;            default:                break;        }        return updatedRows;    }    @Override    public int delete(Uri uri, String selection, String[] selectionArgs) {        // 删除数据        SQLiteDatabase db = dbHelper.getWritableDatabase();        int deletedRows = 0;        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                deletedRows = db.delete("Book", selection, selectionArgs);                break;            case BOOK_ITEM:                String bookId = uri.getPathSegments().get(1);                deletedRows = db.delete("Book", "id = ?", new String[] { bookId });                break;            case CATEGORY_DIR:                deletedRows = db.delete("Category", selection, selectionArgs);                break;            case CATEGORY_ITEM:                String categoryId = uri.getPathSegments().get(1);                deletedRows = db.delete("Category", "id = ?", new String[] { categoryId });                break;            default:                break;        }        return deletedRows;    }    @Override    public String getType(Uri uri) {        switch (uriMatcher.match(uri)) {            case BOOK_DIR:                return "vnd.android.cursor.dir/vnd.com.example.databasetest. provider.book";            case BOOK_ITEM:                return "vnd.android.cursor.item/vnd.com.example.databasetest. provider.book";            case CATEGORY_DIR:                return "vnd.android.cursor.dir/vnd.com.example.databasetest. provider.category";            case CATEGORY_ITEM:                return "vnd.android.cursor.item/vnd.com.example.databasetest. provider.category";        }        return null;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>onCreate()：</strong></p><p>创建了一个 MyDatabaseHelper 的实例，然后返回 true 表示内容提供器初始化成功，这时数 据库就已经完成了创建或升级操作。 </p><p><strong>query()</strong> <strong>：</strong></p><p>先获取 SQLiteDatabase 的实例，然后根据传入 的 Uri 参数判断出用户想要访问哪张表，再调用 SQLiteDatabase 的 query()进行查询，并将 Cursor 对象返回。注意当访问单条数据时，这里调用了 Uri 对象的 getPathSegments()方法，它会将内容 URI 权限之后的部分以“/”符号进行分割，并把分割后 的结果放入到一个字符串列表中，那这个列表的第 0 个位置存放的就是路径，第 1 个位置存放的 就是 id 了。得到了 id 之后，再通过 selection 和 selectionArgs 参数进行约束。 </p><p><strong>insert()：</strong> </p><p>先获取到了 SQLiteDatabase 的实例，然后根据传入 的 Uri 参数判断出用户想要往哪张表里添加数据，再调用 SQLiteDatabase 的 insert()方法进行添加。</p><p><strong>注意 insert()方法要求返回一个能够表示这条新增数据的 URI，所以还需要调用 Uri.parse()方法来将一个内容 URI 解析成 Uri 对象，当然这个内容 URI 是以新增数据的id结尾的。</strong></p><p><strong>update()：</strong></p><p>先获取 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要更新哪张表里的数据，再调用 SQLiteDatabase 的 update()方法进行更新。</p><p><strong>delete()：</strong> </p><p>是先获取到 SQLiteDatabase 的实例，然后根据传入的 Uri 参数判断出用户想要 删除哪张表里的数据，再调用 SQLiteDatabase 的 delete()方法进行删除。</p><p>Uri 对象的 getPathSegments()方法，它会将内容 URI 权限之后的部分以“/”符号进行分割，并把分割后 的结果放入到一个字符串列表中，那这个列表的第 0 个位置存放的就是路径，第 1 个位置存放的 就是 id 了。  </p><p><strong>注意： 内容提供器一定要在 AndroidManifest.xml 文件中注册才可以使用。</strong>  </p><h2 id="Chap8-通知"><a href="#Chap8-通知" class="headerlink" title="Chap8-通知"></a>Chap8-通知</h2><h3 id="8-1使用通知"><a href="#8-1使用通知" class="headerlink" title="8.1使用通知"></a>8.1使用通知</h3><p>Android8.0最新版本的通知要求</p><ul><li>现在必须将各个通知放入特定渠道中。</li><li>现在，用户可以按渠道关闭通知，而非关闭来自某个应用的所有通知。</li><li>包含有效通知的应用将在主屏幕/启动器屏幕上相应应用图标的上方显示通知“标志”。</li><li>现在，用户可以从抽屉式通知栏中暂停某个通知。您可以为通知设置自动超时时间。</li><li>您还可以设置通知的背景颜色。</li><li>部分与通知行为相关的 API 已从 Notification 移至 NotificationChannel。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String channelId = "channel_1";//channel的name，作为标识String name = "channel";NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);//创建channelNotificationChannel channel = new NotificationChannel(channelId, name, NotificationManager.IMPORTANCE_DEFAULT);manager.createNotificationChannel(channel);//创建PendingIntentIntent intent = new Intent(this,NotificationActivity.class);PendingIntent pi = PendingIntent.getActivity(this,0,intent,FLAG_IMMUTABLE);@SuppressLint("WrongConstant") Notification notification = new Notification.Builder(MainActivity.this)    //标题    .setContentTitle("This is content title")    //.setStyle(new NotificationCompat.BigTextStyle().bigText())    //正文文本    .setContentText()    //    .setWhen(System.currentTimeMillis())    //小图标    .setSmallIcon(R.mipmap.ic_launcher)    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))    .setChannelId(channelId)    .setContentIntent(pi)    .setAutoCancel(true)    //播放音频    .setSound(Uri.fromFile(new File()))    //产生震动（需要权限）    .setVibrate(new long[] {0,1000,1000,1000})//通知到来的时候立刻振动1秒，然后静止1秒，再振动1秒    //设置灯光    .setLights(Color.RED,1000,1000)    //默认设置    .setDefaults(DEFAULT_ALL)    //通知优先级    .setPriority(NotificationCompat.PRIORITY_MAX)    .build();//显示通知 第一个参数为指定id，第二个参数为通知的对象manager.notify(1, notification);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先需要使用 NotificationCompat.Builder 对象设置通知内容和渠道，且这个构造函数需要提供渠道 ID。</p><h4 id="8-1-1创建渠道并设置重要性"><a href="#8-1-1创建渠道并设置重要性" class="headerlink" title="8.1.1创建渠道并设置重要性"></a>8.1.1创建渠道并设置重要性</h4><p>必须先通过向 createNotificationChannel() 传递 NotificationChannel 的实例在系统中注册应用的通知渠道，然后才能在 Android 8.0 及更高版本上提供通知。</p><p>NotificationChannel 构造函数需要一个 importance，它会使用 NotificationManager 类中的一个常量。</p><h4 id="8-1-2设置通知的点按操作"><a href="#8-1-2设置通知的点按操作" class="headerlink" title="8.1.2设置通知的点按操作"></a>8.1.2设置通知的点按操作</h4><p>每个通知的点按操作通常是在应用中打开对应于该通知的 Activity。必须指定通过 PendingIntent 对象定义的内容 Intent，并将其传递给 setContentIntent()。</p><h4 id="8-1-3显示通知"><a href="#8-1-3显示通知" class="headerlink" title="8.1.3显示通知"></a>8.1.3显示通知</h4><p>如需显示通知，请调用 NotificationManagerCompat.notify()，并将通知的唯一 ID 和 NotificationCompat.Builder.build() 的结果传递给它。</p><h4 id="8-1-4添加操作按钮"><a href="#8-1-4添加操作按钮" class="headerlink" title="8.1.4添加操作按钮"></a>8.1.4添加操作按钮</h4><p>一个通知最多可以提供三个操作按钮，让用户能够快速响应，例如暂停提醒，甚至回复短信。但这些操作按钮不应该重复用户在点按通知时执行的操作。如需添加操作按钮，请将 addAction() 传递给 PendingIntent 方法。这就像在设置通知的默认点按操作，不同的是不会启动 Activity，而是可以完成各种其他任务。</p><h3 id="8-2权限弹窗没有时需要加入权限"><a href="#8-2权限弹窗没有时需要加入权限" class="headerlink" title="8.2权限弹窗没有时需要加入权限"></a>8.2权限弹窗没有时需要加入权限</h3><uses-permission android:name="android.permission.READ_CONTACTS"><h2 id="Chap-9网络技术"><a href="#Chap-9网络技术" class="headerlink" title="Chap-9网络技术"></a>Chap-9网络技术</h2><h3 id="9-1WebView控件"><a href="#9-1WebView控件" class="headerlink" title="9.1WebView控件"></a>9.1WebView控件</h3><p><strong>xml（需要权限）</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>WebView</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/web_view<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">WebView webView = (WebView) findViewById(R.id.web_view);webView.getSettings().setJavaScriptEnabled(true);//当一个网页跳转到另一个网页时，使目标网页仍然在当前 WebView 中显示，webView.setWebViewClient(new WebViewClient());webView.loadUrl("http://www.baidu.com");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-2访问网络"><a href="#9-2访问网络" class="headerlink" title="9.2访问网络"></a>9.2访问网络</h3><h4 id="9-2-1HttpURLConnection"><a href="#9-2-1HttpURLConnection" class="headerlink" title="9.2.1HttpURLConnection"></a>9.2.1HttpURLConnection</h4><p>首先获取HttpURLConnection 的实例，接着设置一下 HTTP 请求所使用的方法。常用的方法主要有两个：GET 和 POST。接下来就可以进行一些定制，比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等。 再调用 getInputStream()方法就可以获取到服务器返回的输入流，即可以对输入流进行读取，最后调用 disconnect()方法将这个 HTTP 连接关闭掉。（<strong>权限</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">url = new URL("http://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setRequestMethod("GET");connection.setConnectTimeout(8000);connection.setReadTimeout(8000);InputStream in = connection.getInputStream();connection.disconnect();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在获取到服务器返回的输入流后，利用 BufferedReader 对 服务器返回的流进行读取。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader reader = new BufferedReader(new InputStreamReader(in));StringBuilder response = new StringBuilder();String line;while ((line = reader.readLine()) != null) {    response.append(line);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="9-2-2OkHttp-（主页：https-github-com-square-okhttp-）"><a href="#9-2-2OkHttp-（主页：https-github-com-square-okhttp-）" class="headerlink" title="9.2.2OkHttp （主页：https://github.com/square/okhttp ）"></a>9.2.2OkHttp （主页：<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a> ）</h4><p><strong>添加依赖</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">implementation 'com.squareup.okhttp3:okhttp:3.10.0'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先需要创建一个OkHttpClient 的实例，想要发起一条 HTTP 请求，就需要创建一个 Request 对象，可以在最 终的build()方法之前连缀很多其他方法来丰富这个Request 对象。之后调用 OkHttpClient 的 newCall()方法来创建一个 Call 对象，并调用它的 execute()方法来发送请求并获取服务器返回的数据，其中 Response 对象就是服务器返回的数据了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">OkHttpClient client = new OkHttpClient();Request request = new Request.Builder()    .url("https://127.0.0.1/get_data.xml")    .build();Response response = client.newCall(request).execute();String responseData = response.body().string();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发起一条 POST 需要先构建出一个 Request Body 对象来存放待提交的参数，然后在 Request.Builder 中调用一下 post()方法，并将 RequestBody 对象传入   调用 execute()方法来发送请求并获取服务器返回的数据即可。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">RequestBody requestBody = new FormBody.Builder() .add("username", "admin") .add("password", "123456") .build();Request request = new Request.Builder() .url("http://www.baidu.com") .post(requestBody) .build(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-3解析XML"><a href="#9-3解析XML" class="headerlink" title="9.3解析XML"></a>9.3解析XML</h3><h4 id="9-3-1Pull解析"><a href="#9-3-1Pull解析" class="headerlink" title="9.3.1Pull解析"></a>9.3.1Pull解析</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void parseXMLWithPull(String xmlData) {        try {            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();            XmlPullParser xmlPullParser = factory.newPullParser();            xmlPullParser.setInput(new StringReader(xmlData));            int eventType = xmlPullParser.getEventType();            String id = "";            String name = "";            String version = "";            while (eventType != XmlPullParser.END_DOCUMENT) {                String nodeName = xmlPullParser.getName();                switch (eventType) {                    case XmlPullParser.START_TAG: {                        if ("id".equals(nodeName)) {                            id = xmlPullParser.nextText();                        } else if ("name".equals(nodeName)) {                            name = xmlPullParser.nextText();                        } else if ("version".equals(nodeName)) {                            version = xmlPullParser.nextText();                        }                        break;                    }                    case XmlPullParser.END_TAG: {                        if ("app".equals(nodeName)) {                            Log.d(TAG, "id is " + id);                            Log.d(TAG, "name is " + name);                            Log.d(TAG, "version is " + version);                        }                        break;                    }                    default:                        break;                }                eventType = xmlPullParser.next();            }        } catch (Exception e) {            e.printStackTrace();        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要获取到一个 XmlPullParserFactory 的实例，并借助这个实例得到 XmlPullParser 对象，然后调用 XmlPullParser 的 setInput()方法将服务器返回的 XML 数据设置进去就可以开始解析了。</p><p>解析的过程通过 getEventType()可以得到当前的解析事件，然后在一个 while 循环中不断地进行解析，如果当前的解析事件不等于 XmlPullParser.END_DOCUMENT，说明解析工作还没完成，调用 next()方法后可以获取下一个解析事件。 在 while 循环中，我们通过 getName()方法得到当前节点的名字，如果发现节点名等于 id、 name 或 version，就调用 nextText()方法来获取节点内具体的内容，每当解析完一个 app 节点后 就将获取到的内容打印出来。  </p><h4 id="9-3-2SAX解析"><a href="#9-3-2SAX解析" class="headerlink" title="9.3.2SAX解析"></a>9.3.2SAX解析</h4><p> 新建一个类继承自 DefaultHandler，并重写父类的 5 个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyHandler extends DefaultHandler {    @Override    public void startDocument() throws SAXException {    }    @Override    public void startElement(String uri, String localName, String qName, Attributesattributes) throws SAXException {    }    @Override    public void characters(char[] ch, int start, int length) throws SAXException {    }    @Override    public void endElement(String uri, String localName, String qName) throwsSAXException {    }    @Override    public void endDocument() throws SAXException {    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>startDocument()方法会在开始 XML 解析的时候调用。</p><p>startElement()方法会在开始解析某个节点的时候调用。</p><p>characters()方法会在获取节点中内容的时候调用。</p><p>endElement()方法会在完成解析某个节点的时候调用。</p><p>endDocument()方法会 在完成整个 XML 解析的时候调用。</p><p>其中，startElement()、characters()和 endElement()这 3 个方法是有参数的，从 XML 中解析出的数据就会以参数的形式传入到这些方法中。在获取节点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作 内容解析出来，需要针对这种情况在代码中做好控制。  </p><h3 id="9-4解析JSON"><a href="#9-4解析JSON" class="headerlink" title="9.4解析JSON"></a>9.4解析JSON</h3><h4 id="9-4-1JSONObject"><a href="#9-4-1JSONObject" class="headerlink" title="9.4.1JSONObject"></a>9.4.1JSONObject</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void parseJSONWithJSONObject(String jsonData) {    try {        JSONArray jsonArray = new JSONArray(jsonData);        for (int i = 0; i &lt; jsonArray.length(); i++) {            JSONObject jsonObject = jsonArray.getJSONObject(i);            String id = jsonObject.getString("id");        }    } catch (Exception e) {        e.printStackTrace();    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 将服务器返回的数据传入到了一个 JSONArray 对象中。然后循环遍历这个 JSONArray，从中取出的每一个元素都 是一个 JSONObject 对象，每个 JSONObject 对象中又会包含 id、name 和 version 这些数据。  </p><h4 id="9-4-2GSON"><a href="#9-4-2GSON" class="headerlink" title="9.4.2GSON"></a>9.4.2GSON</h4><h3 id="9-5Java回调机制"><a href="#9-5Java回调机制" class="headerlink" title="9.5Java回调机制"></a>9.5Java回调机制</h3><p>sendOkHttpRequest()方法中有一个 okhttp3.Callback 参数，这个是 OkHttp 库中自带的一个回调接口，类似于我们刚才自己编写的 HttpCallbackListener。然后在 client. newCall()之后没有像之前那样一直调用 execute()方法，而是调用了一个 enqueue()方法，并 把 okhttp3.Callback 参数传入。相信聪明的你已经猜到了，OkHttp 在 enqueue()方法的内部 已经帮我们开好子线程了，然后会在子线程中去执行 HTTP 请求，并将最终的请求结果回调到 okhttp3.Callback 当中。  </p><h3 id="9-6出现ERR-UNKNOWN-URL-SCHEME"><a href="#9-6出现ERR-UNKNOWN-URL-SCHEME" class="headerlink" title="9.6出现ERR_UNKNOWN_URL_SCHEME"></a>9.6出现ERR_UNKNOWN_URL_SCHEME</h3><p><img src="095.png"></p><p>这是因为其自定义了scheme，类似的还有alipays://，weixin:// 等等。而webView只能识别http://或https://开头的url，因此才会报此错。想处理也很简单，对于这种自定义scheme的url单独处理即可。如果需要做成一个类似浏览器的形式，只需判断开头是否是http://或https://。</p><h3 id="9-7Apache安装"><a href="#9-7Apache安装" class="headerlink" title="9.7Apache安装"></a>9.7Apache安装</h3><p>先用管理员身份启动cmd并且cd到Apache的bin目录下。cd到D盘时需要加 “/d”，不然不起作用。</p><p>httpd.exe -k install 命令，如果成功则可以 start httpd.exe，失败则看提示信息哪里出错。</p><p>“ ServerRoot must be a valid directory”。这个错误是在httpd.conf中找不到Apache24文件，修改Options的路径即可。</p><h2 id="Chap10-线程及服务"><a href="#Chap10-线程及服务" class="headerlink" title="Chap10-线程及服务"></a>Chap10-线程及服务</h2><h3 id="10-1多线程"><a href="#10-1多线程" class="headerlink" title="10.1多线程"></a>10.1多线程</h3><h4 id="10-1-1基本用法"><a href="#10-1-1基本用法" class="headerlink" title="10.1.1基本用法"></a>10.1.1基本用法</h4><p><strong>继承Thread类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyThread extends Thread { @Override public void run() { // 处理具体的逻辑 }}//启动new MyThread().start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实现Runnable接口</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class MyThread implements Runnable { @Override public void run() { // 处理具体的逻辑 }} //启动MyThread myThread = new MyThread();new Thread(myThread).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>匿名类</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">new Thread(new Runnable() { @Override public void run() { // 处理具体的逻辑 }}).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-1-2在子线程中操作UI"><a href="#10-1-2在子线程中操作UI" class="headerlink" title="10.1.2在子线程中操作UI"></a>10.1.2在子线程中操作UI</h4><p>新增一个 Handler 对象，并重写父类的 handleMessage()方法，在这里对具体的 Message 进行 处理。创建一个 Message（android.os.Message）对象，并将它的 what 字段的值指定为 UPDATE_TEXT，然后调用 Handler 的 sendMessage()方法将这条 Message 发送出去。  </p><h3 id="10-2异步消息处理机制"><a href="#10-2异步消息处理机制" class="headerlink" title="10.2异步消息处理机制"></a>10.2异步消息处理机制</h3><ol><li> <strong>Message</strong>  </li></ol><p>Message 是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。有Message 的 what 字段，还可以使用 arg1 和 arg2 字 段来携带一些整型数据，使用 obj 字段携带一个 Object 对象。  </p><ol><li> <strong>Handler</strong>  </li></ol><p>Handler 顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用 Handler 的 sendMessage()方法，而发出的消息经过一系列地辗转处理后，最终会传递到 Handler 的 handleMessage()方法中。  </p><ol><li> <strong>MessageQueue</strong>  </li></ol><p>MessageQueue 是消息队列的意思，它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个 MessageQueue 对象。  </p><ol><li> <strong>Looper</strong>  </li></ol><p>Looper 是每个线程中的 MessageQueue 的管家，调用 Looper 的 loop()方法后，就会进入到 一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage()方法中。每个线程中也只会有一个 Looper 对象。  </p><h4 id="10-2-1-使用-AsyncTask"><a href="#10-2-1-使用-AsyncTask" class="headerlink" title="10.2.1 使用 AsyncTask"></a>10.2.1 使用 AsyncTask</h4><p>AsyncTask 是一个抽象类，必须要创建一个子类去继承它。在继承时可以为 AsyncTask 类指定 3 个泛型参数</p><ul><li> <strong>Params</strong>  ： 在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。  </li><li> <strong>Progress</strong>  ： 后台任务执行时，如果需要在界面上显示当前的进度。</li><li> <strong>Result</strong>  ： 当任务执行完毕后，如果需要对结果进行返回 。</li></ul><p> 经常需要去重写的方法有以下 4 个。  </p><ol><li> <strong>onPreExecute()</strong>  </li></ol><p> 这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作 。</p><ol start="2"><li><strong>doInBackground(Params…)</strong>  </li></ol><p>这个方法中的所有代码都会在子线程中运行，应该在这里去处理所有的耗时任务。任务完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行 UI 操作的。</p><ol start="3"><li><strong>onProgressUpdate(Progress…)</strong>  </li></ol><p>当调用了 publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新。  </p><ol start="4"><li><strong>onPostExecute(Result)</strong>  </li></ol><p>当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作。  </p><h3 id="10-3服务的基本用法"><a href="#10-3服务的基本用法" class="headerlink" title="10.3服务的基本用法"></a>10.3服务的基本用法</h3><h4 id="10-3-1启动和停止"><a href="#10-3-1启动和停止" class="headerlink" title="10.3.1启动和停止"></a>10.3.1启动和停止</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent startIntent = new Intent(this, MyService.class);startService(startIntent); // 启动服务Intent stopIntent = new Intent(this, MyService.class);stopService(stopIntent); // 停止服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MyService 的任何一个位置调用 stopSelf()方法就能让这个服务停止。  </p><h4 id="10-3-2活动和服务通信"><a href="#10-3-2活动和服务通信" class="headerlink" title="10.3.2活动和服务通信"></a>10.3.2活动和服务通信</h4><p> <strong>onBind()方法</strong>  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent bindIntent = new Intent(this, MyService.class);bindService(bindIntent, connection, BIND_AUTO_CREATE); // 绑定服务unbindService(connection); // 解绑服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="10-3-3前台服务"><a href="#10-3-3前台服务" class="headerlink" title="10.3.3前台服务"></a>10.3.3前台服务</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Intent intent = new Intent(this, MainActivity.class);PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);Notification notification = new NotificationCompat.Builder(this)    .setContentTitle("This is content title")    .setContentText("This is content text")    .build();startForeground(1, notification);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构建出 Notification 对象后 并没有使用 NotificationManager 来将通知显示出来，而是调用了 startForeground()方法。</p><p>这个方法接收两个参数，第一个参数是通知的 id，类似于 notify()方法的第一个参数，第二个参数则是构建出的 Notification 对象。调用 startForeground()方法后就会让 MyService 变成 一个前台服务，并在系统状态栏显示出来。  </p><h4 id="10-3-4IntentService"><a href="#10-3-4IntentService" class="headerlink" title="10.3.4IntentService"></a>10.3.4IntentService</h4><p> 应该在服务的每个具体的方法里开启一个子线程，然后在这里去处理那些耗时的逻辑。为了可以简单地创建一个异步的、会自动停止的服务，Android 专门提供了一个 IntentService 类。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyIntentService extends IntentService { public MyIntentService() { super("MyIntentService"); // 调用父类的有参构造函数 } @Override protected void onHandleIntent(Intent intent) { // 打印当前线程的 id Log.d("MyIntentService", "Thread id is " + Thread.currentThread(). getId()); }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数。然后要在子类中去实现 onHandleIntent()这个抽象方法，在这个方法中可以去处理一些具体的逻辑， 而且不用担心 ANR 的问题，因为这个方法已经是在子线程中运行的了。  </p><h2 id="Chap11-使用第三方定位软件（百度）"><a href="#Chap11-使用第三方定位软件（百度）" class="headerlink" title="Chap11-使用第三方定位软件（百度）"></a>Chap11-使用第三方定位软件（百度）</h2><h3 id="11-1申请API-Key"><a href="#11-1申请API-Key" class="headerlink" title="11.1申请API Key"></a>11.1申请API Key</h3><p>首先需要创建应用，百度申请网址是：<a href="https://lbsyun.baidu.com/apiconsole/key#/home%E3%80%82%E5%9C%A8%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%AD%BE%E5%90%8D%E6%96%87%E4%BB%B6%EF%BC%8C%E5%9C%A8%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%80%89%E9%A1%B9%E6%A0%8FBuild%E4%B8%8BGenerate">https://lbsyun.baidu.com/apiconsole/key#/home。在创建应用的时候需要自己项目的签名文件，在已有项目中选项栏Build下Generate</a> single文件，选取文件位置并设置密码等信息。</p><p><img src="11.1.png"></p><h3 id="11-2配置Android-Studio环境"><a href="#11-2配置Android-Studio环境" class="headerlink" title="11.2配置Android Studio环境"></a>11.2配置Android Studio环境</h3><p>提交后得到项目的访问应用（AK），在注册文件中添加<meta>信息如下图所示：</p><p><img src="112.png"></p><p>我们需要下载百度地图集成后的SDK并解压到我们的项目文件下。创建与src同级的libs文件夹放置jar包，创建与java同级的jniLibs放置.so文件，并在依赖文件中加入文件路径。</p><p>（具体提示信息网站：<a href="https://lbsyun.baidu.com/index.php?title=android-locsdk/guide/create-project/android-studio%EF%BC%89">https://lbsyun.baidu.com/index.php?title=android-locsdk/guide/create-project/android-studio）</a></p><p><img src="112-2.png" alt="img"></p><h3 id="11-3获取自己的经纬度"><a href="#11-3获取自己的经纬度" class="headerlink" title="11.3获取自己的经纬度"></a>11.3获取自己的经纬度</h3><p>因为获取经纬度需要用到手机位置信息，需要申请权限，所以现在注册文件下将权限申请一下。之后还需要再注册一个 LBS SDK 中的服务。</p><p>图中的权限包括了本项目所有需要申请的权限信息。</p><p><img src="112-3.png"></p><p><img src="112-4.png"></p><h4 id="LocationClient实例"><a href="#LocationClient实例" class="headerlink" title="LocationClient实例"></a>LocationClient实例</h4><p> 在 onCreate()方法中，首先创建了一个 LocationClient 的实例， 构建函数接收 Context 参数，这里调用 getApplicationContext()方法来获取一个全局的 Context 参数并传入。然后调用 LocationClient 的 registerLocationListener()方法来注册一个定位监听器，当获取到位置信息的时候，就会回调这个定位监听器。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public LocationClient mLocationClient;onCreate(){    //新增定位SDK隐私合规接口    LocationClient.setAgreePrivacy(true);     //setAgreePrivacy接口需要在LocationClient实例化之前调用     //如果setAgreePrivacy接口参数设置为了false，则定位功能不会实现     //true，表示用户同意隐私合规政策     //false，表示用户不同意隐私合规政策        //实例化LocationClient时，需要捕获异常信息    mLocationClient = new LocationClient(getApplicationContext());        //在使用mLocationClient时，请注意需要加判空处理    mLocationClient.registerLocationListener(new MyLocationListener());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h4><p>首先创建一个空的 List 集合，然后依次判断权限有没有被授权， 没被授权就添加到 List 集合中，最后将 List 转换成数组，再调用 ActivityCompat. requestPermissions()方法一次性申请。onRequestPermissionsResult()方法中通过一个循环将申请的每个权限都进行了判断，如果有任何一个权限被拒绝， 那么就直接调用 finish()方法关闭当前程序，只有当所有权限都被用户同意了，才会调用 requestLocation()方法开始地理位置定位。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//权限列表List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();if (ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {    permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION);}//其他权限全部这样操作 Manifest.permission.READ_PHONE_STATE、WRITE_EXTERNAL_STORAGE//转换为数组并调用requestPermissions() if (!permissionList.isEmpty()) {    String[] permissions = permissionList.toArray(new String[    permissionList.size()]);    ActivityCompat.requestPermissions(MainActivity.this, permissions, 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>requestLocation()方法中的代码比较简单，只是调用了一下 LocationClient 的 start() 方法就能开始定位了。</p><h4 id="位置监听器"><a href="#位置监听器" class="headerlink" title="位置监听器"></a>位置监听器</h4><p>定位的结果会回调到我们前面注册的监听器当中——MyLocationListener。MyLocationListener 的 onReceiveLocation()方法中，通过 BDLocation 的 getLatitude()方法获取纬度，通过 getLongitude()方法获取经度，通过 getLocType()方法获取当前的定位方式，将结果组装成一个字符串，显示到 TextView 上面。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyLocationListener implements BDLocationListener {    runOnUiThread(new Runnable() {         @Override        public void run() {                    StringBuilder currentPosition = new StringBuilder();                    currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n");                    currentPosition.append("经线：").append(bdLocation.getLongitude()).append("\n");                    currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n");                    currentPosition.append("省：").append(bdLocation.getProvince()).append("\n");                    currentPosition.append("市：").append(bdLocation.getCity()).append("\n");                    currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n");                    currentPosition.append("街道:").append(bdLocation.getStreet()).append("\n");                    currentPosition.append("定位方式");                    positionText.setText(currentPosition);                }            });        }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实时定位自己的位置"><a href="#实时定位自己的位置" class="headerlink" title="实时定位自己的位置"></a>实时定位自己的位置</h4><p> 创建LocationClientOption 对象，然后调用 setScanSpan()方法来设置更新的间隔。这里传入了 5000，表示每 5 秒钟会更新一下当前的位置。 在活动被销毁的时候一定要调用 LocationClient 的 stop()方法来停止定位， 不然程序会持续在后台不停地进行定位，从而严重消耗手机的电量。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LocationClientOption option = new LocationClientOption();option.setScanSpan(5000);mLocationClient.setLocOption(option);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="更改定位模式"><a href="#更改定位模式" class="headerlink" title="更改定位模式"></a>更改定位模式</h4><p> LBS SDK 的定位模式一共有 3 种模式可选：Hight_Accuracy、Battery_Saving 和 Device_Sensors。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="获取详细位置信息"><a href="#获取详细位置信息" class="headerlink" title="获取详细位置信息"></a>获取详细位置信息</h4><p> 调用LocationClientOption 的 setIsNeedAddress() 方法，并传入 true 。接着在 onReceiveLocation()方法中可以get各种信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">option.setIsNeedAddress(true);currentPosition.append("国家：").append(bdLocation.getCountry()).append("\n");currentPosition.append("省：").append(bdLocation.getProvince()).append("\n");currentPosition.append("市：").append(bdLocation.getCity()).append("\n");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-4使用百度地图"><a href="#11-4使用百度地图" class="headerlink" title="11.4使用百度地图"></a>11.4使用百度地图</h3><p>在使用百度地图之前我们需要继续对Android Studio进行配置，详细请见网址：<a href="https://lbsyun.baidu.com/index.php?title=androidsdk/guide/create-map/showmap">https://lbsyun.baidu.com/index.php?title=androidsdk/guide/create-map/showmap</a></p><p>在xml中新建com.baidu.mapapi.map.MapView</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.baidu.mapapi.map.MapView</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/bdmapView<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>clickable</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化地图，在onResume和onPause中更新状态</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">SDKInitializer.setAgreePrivacy(getApplicationContext(),true);SDKInitializer.initialize(getApplicationContext());SDKInitializer.setCoordType(CoordType.BD09LL);mapView = findViewById(R.id.bdmapView);mapView.onResume();mapView.onPause();mapView.onDestroy();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="移动到我的位置"><a href="#移动到我的位置" class="headerlink" title="移动到我的位置"></a>移动到我的位置</h4><p> 百度LBS SDK 的 API 中提供了一个 BaiduMap 类，它是地图的总控制器，调用 MapView 的 getMap()方法就能获取到 BaiduMap 的实例。有了 BaiduMap 后，我们就能对地图进行各种各样的操作了，比如设置地图的缩放级别以及 将地图移动到某一个经纬度上。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">baiduMap = mapView.getMap();//中 MapStatusUpdateFactory 的 zoomTo()方法接收一个 float 型的参数，就是用于设置缩//放级别的，zoomTo()方法返回一个 MapStatusUpdate 对象，我们把这个对象传入 BaiduMap 的 animateMapStatus()方法当中即可完成缩放功能。MapStatusUpdate update = MapStatusUpdateFactory.zoomTo(12.5f);baiduMap.animateMapStatus(update); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>移动地图借助 LatLng 类，它的构造方法接收两个参数，第一个参 数是纬度值，第二个参数是经度值。之后调用 MapStatusUpdateFactory 的 newLatLng()方法将 LatLng 对象传入，newLatLng()方法返回的也是一个 MapStatusUpdate 对象，我们再把这个对 象传入 BaiduMap 的 animateMapStatus()方法当中，就可以将地图移动到指定的经纬度上了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LatLng ll = new LatLng(location.getLatitude(),location.getLongitude());MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);baiduMap.animateMapStatus(update);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="显式我的位置"><a href="#显式我的位置" class="headerlink" title="显式我的位置"></a>显式我的位置</h4><p>百度 LBS SDK 当中提供了一个 MyLocationData.Builder 类，这个类是用来封装设备当前所在位置的，我们只需将经纬度信息传入到这个类的相应方法当中就可以了。</p><p>MyLocationData.Builder 类还提供了一个 build()方法，当我们把要封装的信息都设置完成之后，只需要调用它的 build()方法，就会生成一个 MyLocationData 的实例，然后再将这个 实例传入到 BaiduMap 的 setMyLocationData()方法当中，就可以让设备当前的位置显示在地图上了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//需要将此方法开启才会显式baiduMap.setMyLocationEnabled(true);MyLocationData.Builder locationBuilder = new MyLocationData.Builder();locationBuilder.latitude(location.getLatitude());locationBuilder.longitude(location.getLongitude());MyLocationData locationData = locationBuilder.build();baiduMap.setMyLocationData(locationData);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chap12-Material-Design"><a href="#Chap12-Material-Design" class="headerlink" title="Chap12-Material Design"></a>Chap12-Material Design</h2><h3 id="12-1ToolBar"><a href="#12-1ToolBar" class="headerlink" title="12.1ToolBar"></a>12.1ToolBar</h3><p>使用 Toolbar 来替代 ActionBar，需要指定一个不带 ActionBar 的主题， 通常有Theme.AppCompat.NoActionBar 和Theme.AppCompat.Light.NoActionBar这两种主题可选。修改 activity_main.xml 中的代码创建ToolBar。</p><p> Toolbar 主题，使用 android:theme 属性。</p><p> app:popupTheme 属性单独将弹出的菜单项指定成了淡色主题。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.appcompat.widget.Toolbar</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/toolbar<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/actionBarSize<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/colorPrimary<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@style/ThemeOverlay.AppCompat.Dark.ActionBar<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>layout_scrollFlags</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scroll|enterAlways|snap<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>popupTheme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@style/ThemeOverlay.AppCompat.Light<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现ToolBar</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Toolbar toolbar = findViewById(R.id.toolbar);setSupportActionBar(toolbar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ToolBar技巧，给activity 增加一个 android:label 属性，用于指定在 Toolbar 中显示的文字内容， 如果没有指定的话，会默认使用应用名称 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">android:label="Fruits"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ToolBar样式修改。新建toolbar.xml文件，可通过item标签定义action按钮。showAsAction指定按钮的显示位置  。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/backup<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/ic_backup<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Backup<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>showAsAction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>always<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行toolbar:在 onCreateOptionsMenu()方法中加载toolbar.xml 这个菜单文件，然后 在 onOptionsItemSelected()方法中处理各个按钮的点击事件。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean onCreateOptionsMenu(Menu menu) {        getMenuInflater().inflate(R.menu.toolbar,menu);        return true;    }@Overridepublic boolean onOptionsItemSelected(@NonNull MenuItem item) {    switch (item.getItemId()){        case android.R.id.home://HomeAsUp按钮id永远是这个            mDrawerLayout.openDrawer(GravityCompat.START);            break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-2滑动菜单"><a href="#12-2滑动菜单" class="headerlink" title="12.2滑动菜单"></a>12.2滑动菜单</h3><h4 id="12-2-1DrawerLayout设置滑动菜单"><a href="#12-2-1DrawerLayout设置滑动菜单" class="headerlink" title="12.2.1DrawerLayout设置滑动菜单"></a>12.2.1DrawerLayout设置滑动菜单</h4><p> DrawerLayout是一个布局，在布局中允许放入两个直 接子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。  </p><p>在主界面xml中编写， 第一个子控件是 FrameLayout，用于作为主屏幕中显 示的内容。第二个子控件使用了一个 TextView，用 于作为滑动菜单中显示的内容，内容控件没有要求。  但是第二个控件需要制定layout_gravity 属性，需要告诉 DrawerLayout 滑动菜单是在屏幕的左边还是右边，left 表示滑动菜单在左边，right 表示滑动菜单在右边。start，表示会根据系统语言进行判断。   </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.drawerlayout.widget.DrawerLayout</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FrameLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FrameLayout</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span><span class="token attr-name">\</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.drawerlayout.widget.DrawerLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在ToolBar左边加入菜单栏action"><a href="#在ToolBar左边加入菜单栏action" class="headerlink" title="#### 在ToolBar左边加入菜单栏action"></a>#### 在ToolBar左边加入菜单栏action</h4><p>首先调用 findViewById()方法得到了 DrawerLayout 的实例，然后调用 getSupportActionBar()方法得到了 ActionBar 的实例。接着调用 ActionBar 的 setDisplayHomeAsUpEnabled()方法让导航按钮显示出来，又调用了 setHomeAsUpIndicator()方法来设置一个导航按钮图标。实际上， Toolbar 最左侧的这个按钮就叫作 HomeAsUp 按钮，它默认的图标是一个返回的箭头，含义是返回上一个活动。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mDrawerLayout = findViewById(R.id.drawer_layout);ActionBar actionBar = getSupportActionBar();actionBar.setDisplayHomeAsUpEnabled(true);//设置导航按钮图标actionBar.setHomeAsUpIndicator(R.drawable.ic_menu);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在 onOptionsItemSelected()方法中对 HomeAsUp 按钮的点击事件进行处理， HomeAsUp 按钮的 id 永远都是 android.R.id.home。然后调用 DrawerLayout 的 openDrawer() 方法将滑动菜单展示出来，注意 openDrawer()方法要求传入一个 Gravity 参数，为了保证这里的行为和 XML 中定义的一致，我们传入了 GravityCompat.START。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">case android.R.id.home://HomeAsUp按钮id永远是这个    mDrawerLayout.openDrawer(GravityCompat.START);    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="12-2-2NavigationView-优化滑动菜单"><a href="#12-2-2NavigationView-优化滑动菜单" class="headerlink" title="12.2.2NavigationView 优化滑动菜单"></a>12.2.2NavigationView 优化滑动菜单</h4><p>首先要引用Design Support 和CircleImageView库。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">implementation 'de.hdodenhof:circleimageview:3.1.0'implementation 'com.android.support:design:24.2.1'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>要准备 menu 和 headerLayout 。在menu文件夹下创建 Menu resource file 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>menu</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>group</span> <span class="token attr-name"><span class="token namespace">android:</span>checkableBehavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>single<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span>   <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/nav_call<span class="token punctuation">"</span></span>   <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/nav_call<span class="token punctuation">"</span></span>   <span class="token attr-name"><span class="token namespace">android:</span>title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Call<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>group</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>menu</span><span class="token punctuation">&gt;</span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><menu>中嵌套了一个<group>标签，然后将 group 的 checkableBehavior 属性指定为 single。group 表示一个组，checkableBehavior 指定为 single 表示组中的所有菜单项只能单选。 菜单项使用item定义。其中属性定义id、title、icon。<p>在layout文件夹下创建Layout resource file 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>180dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>background</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/colorPrimary<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>padding</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>de.hdodenhof.circleimageview.CircleImageView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/icon_image<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>70dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>70dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_centerInParent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/nav_icon<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>布局文件的最外层是一个 RelativeLayout，宽度设为 match_parent， 高度设为 180dp，指定背景色为 colorPrimary。 在 RelativeLayout 中我们放置了 3 个控件，CircleImageView 是一个用于将图片圆形化的控件， 它指定了一张图片作为头像，然后设置为居中显示。另外两个 TextView 分别用于显示用户名和邮箱地址。</p><p>准备好header和menu后可以再DrawerLayout中部署NavigationView了。将header和menu设置为刚刚写好的文件。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.navigation.NavigationView</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/nav_view<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>start<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>headerLayout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@layout/nav_header<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>menu</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@menu/nav_menu<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着在MainActivity中配置。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">NavigationView navView = findViewById(R.id.nav_view);navView.setCheckedItem(R.id.nav_call);navView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {    @Override    public boolean onNavigationItemSelected(@NonNull MenuItem item) {        mDrawerLayout.closeDrawers();        return true;    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先获取NavigationView 的实例，然后调用它的setCheckedItem()方法将 Call 菜单项设置为默认选中。调用setNavigationItemSelectedListener()方法来设置一个菜单项选中事件的监听器，当用户点击了任意菜单项时， 就会回调到 onNavigationItemSelected()方法中。在这个方法中写相应的逻辑处理，这里调用了 DrawerLayout 的 closeDrawers()方法将滑动菜单关闭。  </p><h3 id="12-3悬浮按钮和可交互"><a href="#12-3悬浮按钮和可交互" class="headerlink" title="12.3悬浮按钮和可交互"></a>12.3悬浮按钮和可交互</h3><h4 id="12-3-1FloatingActionButton"><a href="#12-3-1FloatingActionButton" class="headerlink" title="12.3.1FloatingActionButton"></a>12.3.1FloatingActionButton</h4><p>在页面中插入悬浮按钮,代码都是一些基础设置，配置了大小、图片、悬浮高度、施放位置。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.floatingactionbutton.FloatingActionButton</span>  <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/fab<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_gravity</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bottom|end<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>16dp<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@drawable/ic_done<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">app:</span>elevation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>8dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>悬浮按钮和普通按钮差异很小，在使用时需要创建实例并且有点击事件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">FloatingActionButton fab = findViewById(R.id.fab);fab.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View v) {        Toast.makeText(MainActivity.this,"FAB clicked ",Toast.LENGTH_SHORT).show();    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-3-2Snackbar"><a href="#12-3-2Snackbar" class="headerlink" title="12.3.2Snackbar"></a>12.3.2Snackbar</h4><p>Snackbar 不是 Toast 的替代品，它们两者之间有着不同的应用场景。Toast 的 作用是告诉用户现在发生了什么事情，但同时用户只能被动接收这个事情，因为没有什么办法能 让用户进行选择。而 Snackbar 则在这方面进行了扩展，它允许在提示当中加入一个可交互按钮， 当用户点击按钮的时候可以执行一些额外的逻辑操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Snackbar.make(v,"Data deleted",Snackbar.LENGTH_SHORT).setAction(                    "Undo", new View.OnClickListener() {    @Override    public void onClick(View v) {        Toast.makeText(MainActivity.this, "Data restored", Toast.LENGTH_SHORT).show();    }}).show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用Snackbar 的 make()方法来创建一个 Snackbar 对象，make()方法的第一个参数需要传入一个 View，只要是当前界面布局的任意一个 View 都可以，Snackbar 会使用 这个 View 来自动查找最外层的布局，用于展示 Snackbar。第二个参数就是 Snackbar 中显示的内容，第三个参数是 Snackbar 显示的时长。又调用 setAction()方法来设置一个动作，从而让 Snackbar 不仅仅是一个提示，而是可以和用户进行交互的。在动作按钮的点击事件里面弹出一个 Toast 提示。最后调用 show()方法让 Snackbar 显示出来。</p><h4 id="12-3-3-CoordinatorLayout"><a href="#12-3-3-CoordinatorLayout" class="headerlink" title="12.3.3 CoordinatorLayout"></a>12.3.3 CoordinatorLayout</h4><p>CoordinatorLayout可以说是一个加强版的FrameLayout,其可以监听其所有子控件的各种事件，然后自动帮助我们做出最为合理的响应。 至于如何使用只需要将原来的FrameLayout 替换一下就可以了 。</p><h3 id="12-4卡片式布局"><a href="#12-4卡片式布局" class="headerlink" title="12.4卡片式布局"></a>12.4卡片式布局</h3><h4 id="12-4-1CardView"><a href="#12-4-1CardView" class="headerlink" title="12.4.1CardView"></a>12.4.1CardView</h4><p>添加依赖库：cardview、recyclelist、glide。Glide 是一个超级强大的图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF 图片、甚至是本地视频。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> //glide依赖implementation 'com.github.bumptech.glide:glide:4.13.2'annotationProcessor 'com.github.bumptech.glide:compiler:4.13.2'//recycler view 依赖implementation "androidx.recyclerview:recyclerview:1.2.1"// For control over item selection of both touch and mouse driven selectionimplementation "androidx.recyclerview:recyclerview-selection:1.1.0"//card view 依赖implementation "androidx.cardview:cardview:1.0.0"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CardView是用于实现卡片式布局效果的重要控。其实也是一个 FrameLayout，只是额外提供了圆角和阴影等效果，看上去会有立体的感觉。通过 app:cardCornerRadius 属性指定卡片圆角的弧度，数值越大，圆角的弧度也越大。通过 app:elevation 属性指定卡片的高度， 高度值越大，投影范围也越大，但是投影效果越淡，高度值越小，投影范围也越小，但是投影效果越浓。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.cardview.widget.CardView</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>cardCornerRadius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.cardview.widget.CardView</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了能够充分利用屏幕的空间，运用一下第 3 章中学到的知识，使用 RecyclerView 来填充 MaterialTest项目的主界面部分。实现一个高配版的水果列表效果。  </p><p>在 CoordinatorLayout中添加了一个 RecyclerView，给它指定一个 id，然后将宽度和高度都设置为 match_parent，这样 RecyclerView 也就占满了整个布局的空间。  </p><p>新建一个Fruit类。Fruit 类中只有两个字段，name 表示水果的名字，imageId 表示水果对应图片的资源 id。  </p><p>需要为RecyclerView的子项指定一个自定义的布局，在 layout目录下新建fruit_item. xml。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.cardview.widget.CardView</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5dp<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">app:</span>cardCornerRadius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>        <span class="token attr-name">&lt;!--scaleType缩放模式--</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>            <span class="token attr-name"><span class="token namespace">android:</span>scaleType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>centerCrop<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.cardview.widget.CardView</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用CardView来作为子项的最外层布局，从而使得 RecyclerView 中的每个元素都是在卡片当中的。CardView 由于是一个 FrameLayout，因此它没有什么方便的定位方式，这里在 CardView 中再嵌套一个 LinearLayout，然后在 LinearLayout 中放置具体的内容。 内容是定义了一个 ImageView 用于显示水果的图片和 一个 TextView 用于显示水果的名称。在 ImageView 中使用了一个 scaleType 属性，这个属性可以指定图片的缩放模式。centerCrop 模式，它可以让图片保持原有比例填充满 ImageView，并将超出屏幕的部分裁剪掉。  </p><p>接下来为RecycleView准备适配器。具体实现去看第三章。这里将其中的两个方法展示一下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic FruitAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {    if (mContext == null) {         mContext = parent.getContext();     }     View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item,         parent, false);     return new ViewHolder(view);}@Overridepublic void onBindViewHolder(@NonNull FruitAdapter.ViewHolder holder, int position) {    Fruit fruit = mFruitList.get(position);    holder.fruitName.setText(fruit.getName());    Glide.with(mContext).load(fruit.getImageId()).into(holder.fruitImage);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用 Glide.with()方法并传入一个 Context、Activity 或 Fragment 参数， 然后调用 load()方法去加载图片，可以是一个 URL 地址，也可以是一个本地路径，或者是一个 资源 id，最后调用 into()方法将图片设置到具体某一个 ImageView 中就可以了。  </p><h5 id="AppbarLayout"><a href="#AppbarLayout" class="headerlink" title="AppbarLayout"></a>AppbarLayout</h5><p>AppBarLayout 实际上是一个垂直方向的 LinearLayout，它在内部做了很多滚动事件的封装。运行上面的代码会出现RecycleList会将ToolBar覆盖住，这是因为FrameLayout会默认将子布局放置在左上角，解决办法是使用AppBarLayout。具体操作： 第一步将 Toolbar 嵌套到 AppBarLayout 中，第二步给 RecyclerView 指定一个布局行为。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.recyclerview.widget.RecyclerView</span> <span class="token attr-name"><span class="token namespace">app:</span>layout_behavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/appbar_scrolling_view_behavior<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了显式AppBarLayout的特性，我们在ToolBar中加入一个属性。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.appcompat.widget.Toolbar</span>  <span class="token attr-name"><span class="token namespace">app:</span>layout_scrollFlags</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scroll|enterAlways|snap<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>scroll 表示当 RecyclerView 向上滚动的时候，Toolbar 会 跟着一起向上滚动并实现隐藏；enterAlways 表示当 RecyclerView 向下滚动的时候，Toolbar 会 跟着一起向下滚动并重新显示。snap 表示当 Toolbar 还没有完全隐藏或显示的时候，会根据当前 滚动的距离，自动选择是隐藏还是显示。  </p><h3 id="12-5下拉刷新-SwipeRefreshLayout"><a href="#12-5下拉刷新-SwipeRefreshLayout" class="headerlink" title="12.5下拉刷新 SwipeRefreshLayout"></a>12.5下拉刷新 SwipeRefreshLayout</h3><p>在这个项目中支持下拉刷新的只有RecycleView，所以修改代码如下。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span><span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/swipe_refresh<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">app:</span>layout_behavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/appbar_scrolling_view_behavior<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.recyclerview.widget.RecyclerView</span><span class="token punctuation">/&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.swiperefreshlayout.widget.SwipeRefreshLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 RecyclerView 现在变成了 SwipeRefreshLayout 的子控件，因此之前使用 app:layout_behavior 声明的布局行为现在也要移到 SwipeRefreshLayout 中才行。  </p><h4 id="12-5-1MainActivity中使用下拉刷新"><a href="#12-5-1MainActivity中使用下拉刷新" class="headerlink" title="12.5.1MainActivity中使用下拉刷新"></a>12.5.1MainActivity中使用下拉刷新</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">private SwipeRefreshLayout swipeRefreshLayout;swipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);swipeRefreshLayout.setColorSchemeResources(R.color.design_default_color_primary);swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {    @Override    public void onRefresh() {        refreshFruits();    }});private void refreshFruits() {        new Thread(new Runnable() {            @Override            public void run() {                try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                //切回主线程                runOnUiThread(new Runnable() {                    @Override                    public void run() {                        initFruits();                        adapter.notifyDataSetChanged();                        swipeRefreshLayout.setRefreshing(false);                    }                });            }        }).start();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 findViewById()方法拿到 SwipeRefreshLayout 的实例，然后调用 setColorSchemeResources()方法来设置下拉刷新进度条的颜色。接着调用 setOnRefreshListener()方法来设置一个下拉刷新的监听器，当触发了下拉刷新操作的时候就会回调这个监听器的 onRefresh() 方法，然在这里去处理具体的刷新逻辑。 </p><p>通常情况下，onRefresh()方法中应该是去网络上请求最新的数据，然后再将这些数据展示出来。这里调用一个 refreshFruits()方法进行本地刷新操作。</p><p>refreshFruits()方法中先是开启了一个线程，然后将线程沉睡两秒钟。</p><p>沉睡结束之后，这里使用了 runOnUiThread()方法将线程切换回主线程，然后调用 initFruits()方法重新生成数据，</p><p>接着再调用 FruitAdapter 的 notifyDataSetChanged() 方法通知数据发生了变化。</p><p>最后调用 SwipeRefreshLayout 的 setRefreshing()方法并传入 false，用于表示刷新事件结束，并隐藏刷新进度条。  </p><h3 id="12-6可折叠式标题栏"><a href="#12-6可折叠式标题栏" class="headerlink" title="12.6可折叠式标题栏"></a>12.6可折叠式标题栏</h3><h4 id="12-6-1-CollapsingToolbarLayout"><a href="#12-6-1-CollapsingToolbarLayout" class="headerlink" title="12.6.1 CollapsingToolbarLayout"></a>12.6.1 CollapsingToolbarLayout</h4><p>CollapsingToolbarLayout 是一个作用于Toolbar 基础之上的布局。CollapsingToolbarLayout 可以让 Toolbar 的效果变得更加丰富。不过，CollapsingToolbarLayout不能独立存在，它在设计的时候就被限定只能作为  AppBarLayout 的直接子布局来使用。而 AppBarLayout 又必须是 CoordinatorLayout 的子布局。</p><p> 首先创建一个 FruitActivity，并将布局名指定成 activity_fruit.xml， 然后开始编写水果详情展示界面的布局。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.coordinatorlayout.widget.CoordinatorLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>app</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res-auto<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">tools:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.FruitActivity<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.appbar.AppBarLayout</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/appBar<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>250dp<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>com.google.android.material.appbar.CollapsingToolbarLayout</span>            <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/collapsing_toolbar<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@style/ThemeOverlay.AppCompat.Dark.ActionBar<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">app:</span>contentScrim</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/colorPrimary<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">app:</span>layout_scrollFlags</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>scroll|exitUntilCollapsed<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ImageView</span>                <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/fruit_image_view<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>fitsSystemWindows</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>scaleType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>centerCrop<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">app:</span>layout_collapseMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>parallax<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.appcompat.widget.Toolbar</span>                <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/toolbar<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>?attr/actionBarSize<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">app:</span>layout_collapseMode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pin<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>com.google.android.material.appbar.CollapsingToolbarLayout</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>com.google.android.material.appbar.AppBarLayout</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.coordinatorlayout.widget.CoordinatorLayout</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CollapsingToolbarLayout中android:theme 属性指定了一个 ThemeOverlay.AppCompat.Dark.ActionBar 的主题。</p><p>app:contentScrim 属性用于指定 CollapsingToolbarLayout 在趋于折叠状态以及折叠之后的背景色，其实 CollapsingToolbarLayout 在折叠之后就是一个普通的 Toolbar，那么背景色肯定应该是 colorPrimary 了，具体的效果我们待会儿就能看到。</p><p>app:layout_scrollFlags 属性我们也是见过的，只不过之前是给 Toolbar 指定的，现在也移到外面来了。其中，scroll 表示 CollapsingToolbarLayout 会随着水 果内容详情的滚动一起滚动，exitUntilCollapsed 表示当 CollapsingToolbarLayout 随着滚动完 成折叠之后就保留在界面上，不再移出屏幕。   </p><p> 定义一个 ImageView 和一个 Toolbar，这个高级版的标题栏将是由普通的标题栏加上图片组合而成的。</p><p>Toolbar中app:layout_collapseMode 用于指定当前控件在 CollapsingToolbarLayout 折叠过程中的折叠模式，其中 Toolbar 指定成 pin，表示在折叠的过程中位置始终保持不变，ImageView 指定成 parallax，表示会在折叠的过程中产生一定的错位偏移。  </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.core.widget.NestedScrollView</span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">app:</span>layout_behavior</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@string/appbar_scrolling_view_behavior<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>LinearLayout</span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>            <span class="token attr-name"><span class="token namespace">android:</span>orientation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>androidx.cardview.widget.CardView</span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginLeft</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>35dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginRight</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">android:</span>layout_marginBottom</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>15dp<span class="token punctuation">"</span></span>                <span class="token attr-name"><span class="token namespace">app:</span>cardCornerRadius</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>4dp<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>                    <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@+id/fruit_content_text<span class="token punctuation">"</span></span>                    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>                    <span class="token attr-name"><span class="token namespace">android:</span>layout_margin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10dp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.cardview.widget.CardView</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>LinearLayout</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>androidx.core.widget.NestedScrollView</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>水果内容详情的最外层布局使用NestedScrollView，注意它和AppBarLayout是平级的。 </p><p>ScrollView允许使用滚动的方式来查看屏幕以外的数据，而 NestedScrollView 在此基础之上还增加了嵌套响应滚动事件的功能。由于 CoordinatorLayout 本身已经可以响应滚动事件了，因此在它的内部就需要使用 NestedScrollView 或 RecyclerView 这样的布局。</p><p>app:layout_behavior 属性指定了一个布局行为，这和之前在 RecyclerView 中的用法是一模一样的。 不管是 ScrollView 还是 NestedScrollView，它们的内部都只允许存在一个直接子布局。因此， 如果我们想要在里面放入很多东西的话，通常都会先嵌套一个 LinearLayout，然后再在 LinearLayout 中放入具体的内容就可以了。</p><p>编写功能逻辑</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FruitActivity extends AppCompatActivity {    public static final String FRUIT_NAME = "fruit_name";    public static final String FRUIT_IMAGE_ID = "fruit_image_id";    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_fruit);        Intent intent = getIntent();        String fruitName = intent.getStringExtra(FRUIT_NAME);        int fruitImageId =  intent.getIntExtra(FRUIT_IMAGE_ID,0);        Toolbar toolbar = findViewById(R.id.toolbar);        CollapsingToolbarLayout collapsingToolbarLayout = findViewById(R.id.collapsing_toolbar);        ImageView fruitImageView = findViewById(R.id.fruit_image_view);        TextView fruitContentText = findViewById(R.id.fruit_content_text);        setSupportActionBar(toolbar);        ActionBar actionBar = getSupportActionBar();        if(actionBar != null){            actionBar.setDisplayHomeAsUpEnabled(true);        }        collapsingToolbarLayout.setTitle(fruitName);        Glide.with(this).load(fruitImageId).into(fruitImageView);        String fruitContent = generateFruitContent(fruitName);        fruitContentText.setText(fruitContent);    }    private String generateFruitContent(String fruitName) {        StringBuilder fruitContent = new StringBuilder();        for (int i = 0;i &lt; 500;i++){            fruitContent.append(fruitName);        }        return fruitContent.toString();    }    @Override    public boolean onOptionsItemSelected(@NonNull MenuItem item) {        switch (item.getItemId()){            case android.R.id.home:                finish();                return true;        }        return super.onOptionsItemSelected(item);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>onCreate()方法中，我们通过 Intent 获取到 传入的水果名和水果图片的资源 id，然后通过 findViewById()方法拿到刚才在布局文件中定义 的各个控件的实例。</p><p>接着就是使用了 Toolbar 的标准用法，将它作为 ActionBar 显示，并启用 HomeAsUp 按钮。</p><p>接这调用 CollapsingToolbarLayout 的 setTitle()方法将水果名设置成当前界面的标题，然后使用 Glide 加载传入的水果图片，并设置到标题栏的 ImageView 上面。</p><p>接着需要填充水果的内容详情，使用了一个 generateFruitContent()方法将水果名循环拼接 500 次，从而生成了一个比较长的字符串，将它设置到了 TextView 上面。</p><p> 最后，我们在 onOptionsItemSelected()方法中处理了 HomeAsUp 按钮的点击事件，当点击了这个按钮时，就调用 finish()方法关闭当前的活动，从而返回上一个活动。  </p><p>修改RecycleList中的点击事件</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override    public FruitAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        if (mContext == null) {            mContext = parent.getContext();        }        View view = LayoutInflater.from(mContext).inflate(R.layout.fruit_item,                parent, false);        final ViewHolder holder = new ViewHolder(view);        holder.cardView.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                int position = holder.getAdapterPosition();                Fruit fruit = mFruitList.get(position);                Intent intent = new Intent(mContext,FruitActivity.class);                intent.putExtra(FruitActivity.FRUIT_NAME,fruit.getName());                intent.putExtra(FruitActivity.FRUIT_IMAGE_ID,fruit.getImageId());                mContext.startActivity(intent);            }        });        return holder;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="12-6-2修改状态栏空间"><a href="#12-6-2修改状态栏空间" class="headerlink" title="12.6.2修改状态栏空间"></a>12.6.2修改状态栏空间</h4><p>将控件的 android:fitsSystemWindows 属性指定成 true，就表示该控件会出现在系统状态栏 里。需要ImageView 布局结构中的所有父布局都设置上这个属性。还必须在程序的主题中将状态栏颜色指定成透明色才行。在主题中将 android:statusBarColor 属性的值指定成@android:color/transparent。  </p><h2 id="Chap13-高级技巧"><a href="#Chap13-高级技巧" class="headerlink" title="Chap13-高级技巧"></a>Chap13-高级技巧</h2><h3 id="13-1全局使用Context"><a href="#13-1全局使用Context" class="headerlink" title="13.1全局使用Context"></a>13.1全局使用Context</h3><p>Android 提供了一个 Application 类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。我们可以定制一个自己的 Application 类，以便于管理程序内一些全局的状态信息，比如说全局 Context。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyApplication extends Application {    private static Context context;    @Override    public void onCreate() {        context = getApplicationContext();    }    public static Context getContext() {        return context;    }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就可以通过getContext获得全局context了。</p><p>接下来需要告知系统，当程序启动的时候应该初始化 MyApplication 类，而不是默认的 Application 类。在 AndroidManifest.xml 文件的标签下进行指定 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span><span class="token punctuation">&gt;</span></span>  android:name="com.example.networktest.MyApplication"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-2使用Intent传递对象"><a href="#13-2使用Intent传递对象" class="headerlink" title="13.2使用Intent传递对象"></a>13.2使用Intent传递对象</h3><h4 id="13-2-1-Serializable-方式"><a href="#13-2-1-Serializable-方式" class="headerlink" title="13.2.1 Serializable 方式"></a>13.2.1 Serializable 方式</h4><p>Serializable 序列化，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。实现方式是让一个类去实现 Serializable 这个接口。  </p><p>在类中将属性的get、set构造完成后就可以通过Intent去使用了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//传入数据Person person = new Person();person.setName("Tom");person.setAge(20);Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra("person_data", person);startActivity(intent); //取数据Person person = (Person) getIntent().getSerializableExtra("person_data"); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里调用 getSerializableExtra()方法来获取通过参数传递过来的序列化对象，接着再将它向下转型成 Person对象，这样就成功实现了使用 Intent 来传递对象的功能。</p><h4 id="13-2-2-Parcelable-方式"><a href="#13-2-2-Parcelable-方式" class="headerlink" title="13.2.2 Parcelable 方式"></a>13.2.2 Parcelable 方式</h4><p>Parcelable 方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是 Intent 所支持的数据类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Parcelable {    private String name;    private int age;    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeString(name); // 写出 name        dest.writeInt(age); // 写出 age    }    public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.            Creator&lt;Person&gt;() {        @Override        public Person createFromParcel(Parcel source) {            Person person = new Person();            person.name = source.readString(); // 读取 name            person.age = source.readInt(); // 读取 age            return person;        }        @Override        public Person[] newArray(int size) {            return new Person[size];        }    };} //调用数据Person person = (Person) getIntent().getParcelableExtra("person_data");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先Person 类实现 Parcelable 接口，这样必须重写 describeContents()和 writeToParcel()。</p><p>describeContents()方法直接返回 0 。</p><p>writeToParcel()方法中需要调用 Parcel 的 writeXxx()方法，将 Person 类中的字段一一写出。注意，字符串型数据就调用 writeString()方法，整型数据就调用 writeInt()方法。</p><p>其次必须在 Person 类中提供一个名为 CREATOR 的常量，这里创建了 Parcelable.Creator 接口的一个实现，并将泛型指定为 Person。接着需要重写 createFromParcel()和 newArray()这两个方法。</p><p>createFromParcel()方法中我们要去读取刚才写出的 name 和 age 字段，并创建一个 Person 对象进行返回，其中 name 和 age 都是调用 Parcel 的 readXxx()方法读取到的，注意读取的顺序一要和刚才写出的顺序完全相同。</p><p>newArray()方法中的实现就简单多了，只需要 new 出一个 Person 数组，并使用方法中传入的 size 作为数组大小就可以了。 </p><p>接下来，在 FirstActivity 中我们使用相同的代码来传递 Person 对象，在 SecondActivity 中获取对象的时候需要稍加改动，这里不再是调用 getSerializableExtra()方法，而是调用 getParcelableExtra() 方法来获取传递过来的对象。</p><h3 id="13-3定制Log工具"><a href="#13-3定制Log工具" class="headerlink" title="13.3定制Log工具"></a>13.3定制Log工具</h3><p>新建一个 LogUtil 类 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LogUtil {    public static final int VERBOSE = 1;    public static final int DEBUG = 2;    public static final int INFO = 3;    public static final int WARN = 4;    public static final int ERROR = 5;    public static final int NOTHING = 6;    public static int level = VERBOSE;    public static void v(String tag, String msg) {        if (level &lt;= VERBOSE) {        Log.v(tag, msg);        }    }    public static void d(String tag, String msg) {        if (level &lt;= DEBUG) {        Log.d(tag, msg);        }    }    public static void i(String tag, String msg) {        if (level &lt;= INFO) {        Log.i(tag, msg);        }    }    public static void w(String tag, String msg) {        if (level &lt;= WARN) {        Log.w(tag, msg);        }    }    public static void e(String tag, String msg) {        if (level &lt;= ERROR) {        Log.e(tag, msg);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 获得日志类后打印一行 DEBUG 级别的日志就可以这样写：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">LogUtil.d("TAG", "debug log");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="13-4创建定时任务"><a href="#13-4创建定时任务" class="headerlink" title="13.4创建定时任务"></a>13.4创建定时任务</h3><h4 id="13-4-1Alarm机制"><a href="#13-4-1Alarm机制" class="headerlink" title="13.4.1Alarm机制"></a>13.4.1Alarm机制</h4><p>借助AlarmManager 类来实现。通过调用 Context 的 getSystemService()方法来获取实例的，需要传入的参数是 Context.ALARM_ SERVICE。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);//设置定时任务long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>set方法中第一个参数是一个整型参数，用于指定 AlarmManager 的工作 型，有4种值ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC和RTC_WAKEUP。ELAPSED_REALTIME 表示让定时任务的触发时间从系统开机开始算起，但不会唤醒 CPU。 ELAPSED_REALTIME_WAKEUP 同样表示触发时间从系统开机开始算起，但会唤醒 CPU。</p><p>RTC 表示让定时任务的触发时间从 1970 年 1 月 1 日 0 点开始算起，但不会唤醒 CPU。 RTC_WAKEUP 同样表示触发时间从 1970 年 1 月 1 日 0 点开始算起，但会唤醒 CPU。</p><p>使用 SystemClock.elapsedRealtime()方法可以获取到系统开机至今所经历时间的毫秒数 </p><p>使用 System.currentTimeMillis()方法可以获取到 1970年1月1日0点至今所经历时间的毫秒数。  </p><p>第二个参数，就是定时任务触发的时间，以毫秒为单位。 </p><p>如果第一个参数使用的是 ELAPSED_REALTIME 或 ELAPSED_REALTIME_WAKEUP，则这里传入开机至今的时间再加上延迟执行的时间。</p><p>如果第一个参数使用的是 RTC 或 RTC_WAKEUP，则这里传入 1970 年 1 月 1 日 0 点至今的时间再加上延迟执行的时间。</p><p> 第三个参数是一个 PendingIntent，这里一般会调用 getService()方法或者 getBroadcast()方法来获取一个能够执行服务或广播的 PendingIntent。这样当定时任务被触发的时候，服务的 onStartCommand()方法或广播接收器的onReceive()方法就可以得到执行。  </p><p>如果要实现一个长时间在后台定时运行的服务需要将触发定时任务的代码写到 onStartCommand()方法中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overridepublic int onStartCommand(Intent intent, int flags, int startId) {    new Thread(new Runnable() {    @Override    public void run() {        // 在这里执行具体的逻辑操作        }    }).start();    AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE);    int anHour = 60 * 60 * 1000; // 这是一小时的毫秒数    long triggerAtTime = SystemClock.elapsedRealtime() + anHour;    Intent i = new Intent(this, LongRunningService.class);    PendingIntent pi = PendingIntent.getService(this, 0, i, 0);    manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);    return super.onStartCommand(intent, flags, startId);} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Alarm 机制用法:先是获取到了 AlarmManager 的实例，然后定义任务的触发时间为一小时后，再使用 PendingIntent 指定处理定时任务 的服务为 LongRunningService，最后调用 set()方法完成设定。  </p></group></menu></uses-permission>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2022/10/17/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2022/10/17/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h2><p>Node.js官方网站：<a href="https://nodejs.org/">https://nodejs.org</a> 选择对应的系统点击安装。<br>sudo su #切换到管理员<br>node -v #查看node版本<br>npm -v #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本</p><hr><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h2><p>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本</p><h2 id="3-建立博客"><a href="#3-建立博客" class="headerlink" title="3.建立博客"></a>3.建立博客</h2><p>mkdir blog    #创建一个目录，博客所有文件都在这里<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建一篇新的文章，新文章在source/_posts/下，可以使用vim命令便携，支持MarkDown</p><hr><h2 id="4-部署到Github上"><a href="#4-部署到Github上" class="headerlink" title="4.部署到Github上"></a>4.部署到Github上</h2><p>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件<br>然后在个人github上创建一个远程仓库，<em>注意：远程仓库名称：“githubname.io”，前缀必须和你github的名字一样，不然会访问不到（404）。</em><br>接着配置根目录下的_config.yml文件，找到deploy：</p><pre class="line-numbers language-none"><code class="language-none"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git repo: https://github.com/YourGithubName/YourGithubName.github.io.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将repo替换为你自己的仓库链接。<strong>这里也可以使用ssh链接。</strong><br>#在blog路径下<br>hexo clean &amp;&amp; hero g #清理+生成（generate）<br>hexo d #部署到远程仓库。<em>注意：如果出现Fatal，可能是因为代理导致，先关掉。或者是配置一下git的ssh密钥。</em><br>这时就可以通过：<a href="https://yourgithubname.github.io/">https://YourGithubName.github.io</a> 访问你的博客。</p><hr><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>Hexo博客主题在themes文件夹下，可以在GitHub上挑选自己喜欢的主题并下载，这里推荐5种主题。</p><ol><li>Sakura 非常炫，缺点加载慢 <a href="https://github.com/honjun/hexo-theme-sakura">https://github.com/honjun/hexo-theme-sakura</a></li><li>Matery 预加载，强推 <a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></li><li>3-hexo 三段式，适合博文多的 <a href="https://github.com/yelog/hexo-theme-3-hexo">https://github.com/yelog/hexo-theme-3-hexo</a></li><li>butterfly 也是个好看的 <a href="https://github.com/jerryc127/hexo-theme-butterfly/tree/dev">https://github.com/jerryc127/hexo-theme-butterfly/tree/dev</a></li><li>Next 功能集成多，简洁 <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></li></ol><p>选好主题之后cd到themes文件夹下，通过 git clone 下载主题代码。<br>修改根目录下的_config.yml 文件 ： theme: sakura。<br>接着运行 hexo clean &amp;&amp; hero g 和 hexo d。耐心等待一段时间再刷新网站。</p><p>这样Hexo快速布置个人博客就结束了，后续想更改主题的细节可以在主题中的_config.yml中进行修改。<br>学习路漫长，诸君一起努力。</p><h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><h3 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h3><p>这里博主使用的是Typora便携MarkDown，在添加图片之前需要更改一下设置。<br>打开typora，选择：<code>偏好设置 - 图像 - 插入图片时</code>，做如下更改：</p><ol><li>复制到指定路径 </li><li>./${filename}</li></ol><p>当插入图片时，会生成一个和文件名相同的文件夹，并将图片存入这个文件夹内。</p><h3 id="Hexo设置"><a href="#Hexo设置" class="headerlink" title="Hexo设置"></a>Hexo设置</h3><ol><li><p>安装 hexo-renderer-marked</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-renderer-marked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在blog根目录下的_config.yml修改配置：post_asset_folder: true。</p></li><li><p>安装插件hex-image-link</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-image-link --saveNOTE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><p>假设文件名: ./test.md</p><p>图片路径: ./test/image.jpg</p><p>当插入图片 image.jpg 到 test.md 中时，<br>typora 的引用路径为</p><pre class="line-numbers language-none"><code class="language-none">![](test/image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Hexo 发布后的引用路径为</p><pre class="line-numbers language-none"><code class="language-none">![](image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此，typora的md文件引入hexo时，应转换路径。即删掉图片路径中的 “test/“部分；（此时md文件已不能正常显示图片，而 hexo server 可正常显示)</p><p>插件hexo-image-link帮助实现了这种路径转换。<br>安装后，typora 文件中正常显示的图片，在hexo发布后依旧能正常显示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
